/*! For license information please see main.js.LICENSE.txt */
(() => {
    var e = {
            546: (e, t, n) => {
                var s = n(123),
                    r = n(686),
                    a = n(316),
                    i = n(806),
                    o = n(4),
                    u = n(802),
                    l = n(421);
                l.alea = s, l.xor128 = r, l.xorwow = a, l.xorshift7 = i, l.xor4096 = o, l.tychei = u, e.exports = l
            },
            123: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = function() {
                                var e = 4022871197,
                                    t = function(t) {
                                        t = t.toString();
                                        for (var n = 0; n < t.length; n++) {
                                            var s = .02519603282416938 * (e += t.charCodeAt(n));
                                            s -= e = s >>> 0, e = (s *= e) >>> 0, e += 4294967296 * (s -= e)
                                        }
                                        return 2.3283064365386963e-10 * (e >>> 0)
                                    };
                                return t
                            }();
                        t.next = function() {
                            var e = 2091639 * t.s0 + 2.3283064365386963e-10 * t.c;
                            return t.s0 = t.s1, t.s1 = t.s2, t.s2 = e - (t.c = 0 | e)
                        }, t.c = 1, t.s0 = n(" "), t.s1 = n(" "), t.s2 = n(" "), t.s0 -= n(e), t.s0 < 0 && (t.s0 += 1), t.s1 -= n(e), t.s1 < 0 && (t.s1 += 1), t.s2 -= n(e), t.s2 < 0 && (t.s2 += 1), n = null
                    }

                    function i(e, t) {
                        return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = n.next;
                        return r.int32 = function() {
                            return 4294967296 * n.next() | 0
                        }, r.double = function() {
                            return r() + 11102230246251565e-32 * (2097152 * r() | 0)
                        }, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.alea = o
                }(0, e = n.nmd(e), n.amdD)
            },
            802: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.next = function() {
                            var e = t.b,
                                n = t.c,
                                s = t.d,
                                r = t.a;
                            return e = e << 25 ^ e >>> 7 ^ n, n = n - s | 0, s = s << 24 ^ s >>> 8 ^ r, r = r - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - s | 0, t.d = s << 16 ^ n >>> 16 ^ r, t.a = r - e | 0
                        }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;
                        for (var s = 0; s < n.length + 20; s++) t.b ^= 0 | n.charCodeAt(s), t.next()
                    }

                    function i(e, t) {
                        return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.tychei = o
                }(0, e = n.nmd(e), n.amdD)
            },
            686: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function() {
                            var e = t.x ^ t.x << 11;
                            return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8
                        }, e === (0 | e) ? t.x = e : n += e;
                        for (var s = 0; s < n.length + 64; s++) t.x ^= 0 | n.charCodeAt(s), t.next()
                    }

                    function i(e, t) {
                        return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xor128 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            4: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this;
                        t.next = function() {
                                var e, n, s = t.w,
                                    r = t.X,
                                    a = t.i;
                                return t.w = s = s + 1640531527 | 0, n = r[a + 34 & 127], e = r[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n ^= n >>> 15, e ^= e >>> 12, n = r[a] = n ^ e, t.i = a, n + (s ^ s >>> 16) | 0
                            },
                            function(e, t) {
                                var n, s, r, a, i, o = [],
                                    u = 128;
                                for (t === (0 | t) ? (s = t, t = null) : (t += "\0", s = 0, u = Math.max(u, t.length)), r = 0, a = -32; a < u; ++a) t && (s ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = s), s ^= s << 10, s ^= s >>> 15, s ^= s << 4, s ^= s >>> 13, a >= 0 && (i = i + 1640531527 | 0, r = 0 == (n = o[127 & a] ^= s + i) ? r + 1 : 0);
                                for (r >= 128 && (o[127 & (t && t.length || 0)] = -1), r = 127, a = 512; a > 0; --a) s = o[r + 34 & 127], n = o[r = r + 1 & 127], s ^= s << 13, n ^= n << 17, s ^= s >>> 15, n ^= n >>> 12, o[r] = s ^ n;
                                e.w = i, e.X = o, e.i = r
                            }(t, e)
                    }

                    function i(e, t) {
                        return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t
                    }

                    function o(e, t) {
                        null == e && (e = +new Date);
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && (s.X && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xor4096 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            806: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this;
                        t.next = function() {
                                var e, n, s = t.x,
                                    r = t.i;
                                return e = s[r], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = s[r + 1 & 7]) ^ e >>> 10, n ^= (e = s[r + 3 & 7]) ^ e >>> 3, n ^= (e = s[r + 4 & 7]) ^ e << 7, e = s[r + 7 & 7], n ^= (e ^= e << 13) ^ e << 9, s[r] = n, t.i = r + 1 & 7, n
                            },
                            function(e, t) {
                                var n, s = [];
                                if (t === (0 | t)) s[0] = t;
                                else
                                    for (t = "" + t, n = 0; n < t.length; ++n) s[7 & n] = s[7 & n] << 15 ^ t.charCodeAt(n) + s[n + 1 & 7] << 13;
                                for (; s.length < 8;) s.push(0);
                                for (n = 0; n < 8 && 0 === s[n]; ++n);
                                for (8 == n ? s[7] = -1 : s[n], e.x = s, e.i = 0, n = 256; n > 0; --n) e.next()
                            }(t, e)
                    }

                    function i(e, t) {
                        return t.x = e.x.slice(), t.i = e.i, t
                    }

                    function o(e, t) {
                        null == e && (e = +new Date);
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && (s.x && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xorshift7 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            316: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.next = function() {
                            var e = t.x ^ t.x >>> 2;
                            return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0
                        }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;
                        for (var s = 0; s < n.length + 64; s++) t.x ^= 0 | n.charCodeAt(s), s == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next()
                    }

                    function i(e, t) {
                        return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xorwow = o
                }(0, e = n.nmd(e), n.amdD)
            },
            421: (e, t, n) => {
                var s;
                ! function(r, a) {
                    var i, o = this,
                        u = 256,
                        l = "random",
                        c = a.pow(u, 6),
                        h = a.pow(2, 52),
                        p = 2 * h,
                        d = 255;

                    function f(e, t, n) {
                        var s = [],
                            d = b(y((t = 1 == t ? {
                                entropy: !0
                            } : t || {}).entropy ? [e, x(r)] : null == e ? function() {
                                try {
                                    var e;
                                    return i && (e = i.randomBytes) ? e = e(u) : (e = new Uint8Array(u), (o.crypto || o.msCrypto).getRandomValues(e)), x(e)
                                } catch (e) {
                                    var t = o.navigator,
                                        n = t && t.plugins;
                                    return [+new Date, o, n, o.screen, x(r)]
                                }
                            }() : e, 3), s),
                            f = new m(s),
                            w = function() {
                                for (var e = f.g(6), t = c, n = 0; e < h;) e = (e + n) * u, t *= u, n = f.g(1);
                                for (; e >= p;) e /= 2, t /= 2, n >>>= 1;
                                return (e + n) / t
                            };
                        return w.int32 = function() {
                            return 0 | f.g(4)
                        }, w.quick = function() {
                            return f.g(4) / 4294967296
                        }, w.double = w, b(x(f.S), r), (t.pass || n || function(e, t, n, s) {
                            return s && (s.S && g(s, f), e.state = function() {
                                return g(f, {})
                            }), n ? (a[l] = e, t) : e
                        })(w, d, "global" in t ? t.global : this == a, t.state)
                    }

                    function m(e) {
                        var t, n = e.length,
                            s = this,
                            r = 0,
                            a = s.i = s.j = 0,
                            i = s.S = [];
                        for (n || (e = [n++]); r < u;) i[r] = r++;
                        for (r = 0; r < u; r++) i[r] = i[a = d & a + e[r % n] + (t = i[r])], i[a] = t;
                        (s.g = function(e) {
                            for (var t, n = 0, r = s.i, a = s.j, i = s.S; e--;) t = i[r = d & r + 1], n = n * u + i[d & (i[r] = i[a = d & a + t]) + (i[a] = t)];
                            return s.i = r, s.j = a, n
                        })(u)
                    }

                    function g(e, t) {
                        return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t
                    }

                    function y(e, t) {
                        var n, s = [],
                            r = typeof e;
                        if (t && "object" == r)
                            for (n in e) try {
                                s.push(y(e[n], t - 1))
                            } catch (e) {}
                        return s.length ? s : "string" == r ? e : e + "\0"
                    }

                    function b(e, t) {
                        for (var n, s = e + "", r = 0; r < s.length;) t[d & r] = d & (n ^= 19 * t[d & r]) + s.charCodeAt(r++);
                        return x(t)
                    }

                    function x(e) {
                        return String.fromCharCode.apply(0, e)
                    }
                    if (a["seed" + l] = f, b(a.random(), r), e.exports) {
                        e.exports = f;
                        try {
                            i = n(351)
                        } catch (e) {}
                    } else void 0 === (s = function() {
                        return f
                    }.call(t, n, t, e)) || (e.exports = s)
                }([], Math)
            },
            264: (e, t, n) => {
                var s = n(297),
                    r = n(72),
                    a = n(950),
                    i = n(436),
                    o = n(242),
                    u = n(668),
                    l = n(456);
                l.alea = s, l.xor128 = r, l.xorwow = a, l.xorshift7 = i, l.xor4096 = o, l.tychei = u, e.exports = l
            },
            297: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = function() {
                                var e = 4022871197,
                                    t = function(t) {
                                        t = t.toString();
                                        for (var n = 0; n < t.length; n++) {
                                            var s = .02519603282416938 * (e += t.charCodeAt(n));
                                            s -= e = s >>> 0, e = (s *= e) >>> 0, e += 4294967296 * (s -= e)
                                        }
                                        return 2.3283064365386963e-10 * (e >>> 0)
                                    };
                                return t
                            }();
                        t.next = function() {
                            var e = 2091639 * t.s0 + 2.3283064365386963e-10 * t.c;
                            return t.s0 = t.s1, t.s1 = t.s2, t.s2 = e - (t.c = 0 | e)
                        }, t.c = 1, t.s0 = n(" "), t.s1 = n(" "), t.s2 = n(" "), t.s0 -= n(e), t.s0 < 0 && (t.s0 += 1), t.s1 -= n(e), t.s1 < 0 && (t.s1 += 1), t.s2 -= n(e), t.s2 < 0 && (t.s2 += 1), n = null
                    }

                    function i(e, t) {
                        return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = n.next;
                        return r.int32 = function() {
                            return 4294967296 * n.next() | 0
                        }, r.double = function() {
                            return r() + 11102230246251565e-32 * (2097152 * r() | 0)
                        }, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.alea = o
                }(0, e = n.nmd(e), n.amdD)
            },
            668: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.next = function() {
                            var e = t.b,
                                n = t.c,
                                s = t.d,
                                r = t.a;
                            return e = e << 25 ^ e >>> 7 ^ n, n = n - s | 0, s = s << 24 ^ s >>> 8 ^ r, r = r - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - s | 0, t.d = s << 16 ^ n >>> 16 ^ r, t.a = r - e | 0
                        }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;
                        for (var s = 0; s < n.length + 20; s++) t.b ^= 0 | n.charCodeAt(s), t.next()
                    }

                    function i(e, t) {
                        return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.tychei = o
                }(0, e = n.nmd(e), n.amdD)
            },
            72: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function() {
                            var e = t.x ^ t.x << 11;
                            return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8
                        }, e === (0 | e) ? t.x = e : n += e;
                        for (var s = 0; s < n.length + 64; s++) t.x ^= 0 | n.charCodeAt(s), t.next()
                    }

                    function i(e, t) {
                        return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xor128 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            242: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this;
                        t.next = function() {
                                var e, n, s = t.w,
                                    r = t.X,
                                    a = t.i;
                                return t.w = s = s + 1640531527 | 0, n = r[a + 34 & 127], e = r[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n ^= n >>> 15, e ^= e >>> 12, n = r[a] = n ^ e, t.i = a, n + (s ^ s >>> 16) | 0
                            },
                            function(e, t) {
                                var n, s, r, a, i, o = [],
                                    u = 128;
                                for (t === (0 | t) ? (s = t, t = null) : (t += "\0", s = 0, u = Math.max(u, t.length)), r = 0, a = -32; a < u; ++a) t && (s ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = s), s ^= s << 10, s ^= s >>> 15, s ^= s << 4, s ^= s >>> 13, a >= 0 && (i = i + 1640531527 | 0, r = 0 == (n = o[127 & a] ^= s + i) ? r + 1 : 0);
                                for (r >= 128 && (o[127 & (t && t.length || 0)] = -1), r = 127, a = 512; a > 0; --a) s = o[r + 34 & 127], n = o[r = r + 1 & 127], s ^= s << 13, n ^= n << 17, s ^= s >>> 15, n ^= n >>> 12, o[r] = s ^ n;
                                e.w = i, e.X = o, e.i = r
                            }(t, e)
                    }

                    function i(e, t) {
                        return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t
                    }

                    function o(e, t) {
                        null == e && (e = +new Date);
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && (s.X && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xor4096 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            436: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this;
                        t.next = function() {
                                var e, n, s = t.x,
                                    r = t.i;
                                return e = s[r], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = s[r + 1 & 7]) ^ e >>> 10, n ^= (e = s[r + 3 & 7]) ^ e >>> 3, n ^= (e = s[r + 4 & 7]) ^ e << 7, e = s[r + 7 & 7], n ^= (e ^= e << 13) ^ e << 9, s[r] = n, t.i = r + 1 & 7, n
                            },
                            function(e, t) {
                                var n, s = [];
                                if (t === (0 | t)) s[0] = t;
                                else
                                    for (t = "" + t, n = 0; n < t.length; ++n) s[7 & n] = s[7 & n] << 15 ^ t.charCodeAt(n) + s[n + 1 & 7] << 13;
                                for (; s.length < 8;) s.push(0);
                                for (n = 0; n < 8 && 0 === s[n]; ++n);
                                for (8 == n ? s[7] = -1 : s[n], e.x = s, e.i = 0, n = 256; n > 0; --n) e.next()
                            }(t, e)
                    }

                    function i(e, t) {
                        return t.x = e.x.slice(), t.i = e.i, t
                    }

                    function o(e, t) {
                        null == e && (e = +new Date);
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && (s.x && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xorshift7 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            950: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.next = function() {
                            var e = t.x ^ t.x >>> 2;
                            return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0
                        }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;
                        for (var s = 0; s < n.length + 64; s++) t.x ^= 0 | n.charCodeAt(s), s == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next()
                    }

                    function i(e, t) {
                        return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xorwow = o
                }(0, e = n.nmd(e), n.amdD)
            },
            456: (e, t, n) => {
                var s;
                ! function(r, a) {
                    var i, o = this,
                        u = 256,
                        l = "random",
                        c = a.pow(u, 6),
                        h = a.pow(2, 52),
                        p = 2 * h,
                        d = 255;

                    function f(e, t, n) {
                        var s = [],
                            d = b(y((t = 1 == t ? {
                                entropy: !0
                            } : t || {}).entropy ? [e, x(r)] : null == e ? function() {
                                try {
                                    var e;
                                    return i && (e = i.randomBytes) ? e = e(u) : (e = new Uint8Array(u), (o.crypto || o.msCrypto).getRandomValues(e)), x(e)
                                } catch (e) {
                                    var t = o.navigator,
                                        n = t && t.plugins;
                                    return [+new Date, o, n, o.screen, x(r)]
                                }
                            }() : e, 3), s),
                            f = new m(s),
                            w = function() {
                                for (var e = f.g(6), t = c, n = 0; e < h;) e = (e + n) * u, t *= u, n = f.g(1);
                                for (; e >= p;) e /= 2, t /= 2, n >>>= 1;
                                return (e + n) / t
                            };
                        return w.int32 = function() {
                            return 0 | f.g(4)
                        }, w.quick = function() {
                            return f.g(4) / 4294967296
                        }, w.double = w, b(x(f.S), r), (t.pass || n || function(e, t, n, s) {
                            return s && (s.S && g(s, f), e.state = function() {
                                return g(f, {})
                            }), n ? (a[l] = e, t) : e
                        })(w, d, "global" in t ? t.global : this == a, t.state)
                    }

                    function m(e) {
                        var t, n = e.length,
                            s = this,
                            r = 0,
                            a = s.i = s.j = 0,
                            i = s.S = [];
                        for (n || (e = [n++]); r < u;) i[r] = r++;
                        for (r = 0; r < u; r++) i[r] = i[a = d & a + e[r % n] + (t = i[r])], i[a] = t;
                        (s.g = function(e) {
                            for (var t, n = 0, r = s.i, a = s.j, i = s.S; e--;) t = i[r = d & r + 1], n = n * u + i[d & (i[r] = i[a = d & a + t]) + (i[a] = t)];
                            return s.i = r, s.j = a, n
                        })(u)
                    }

                    function g(e, t) {
                        return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t
                    }

                    function y(e, t) {
                        var n, s = [],
                            r = typeof e;
                        if (t && "object" == r)
                            for (n in e) try {
                                s.push(y(e[n], t - 1))
                            } catch (e) {}
                        return s.length ? s : "string" == r ? e : e + "\0"
                    }

                    function b(e, t) {
                        for (var n, s = e + "", r = 0; r < s.length;) t[d & r] = d & (n ^= 19 * t[d & r]) + s.charCodeAt(r++);
                        return x(t)
                    }

                    function x(e) {
                        return String.fromCharCode.apply(0, e)
                    }
                    if (a["seed" + l] = f, b(a.random(), r), e.exports) {
                        e.exports = f;
                        try {
                            i = n(857)
                        } catch (e) {}
                    } else void 0 === (s = function() {
                        return f
                    }.call(t, n, t, e)) || (e.exports = s)
                }([], Math)
            },
            412: (e, t) => {
                "use strict";

                function n(e, t, n) {
                    void 0 === n && (n = "ticks");
                    var s = 0,
                        r = e.length,
                        a = r;
                    if (r > 0 && e[r - 1][n] <= t) return r - 1;
                    for (; s < a;) {
                        var i = Math.floor(s + (a - s) / 2),
                            o = e[i],
                            u = e[i + 1];
                        if (o[n] === t) {
                            for (var l = i; l < e.length; l++) {
                                e[l][n] === t && (i = l)
                            }
                            return i
                        }
                        if (o[n] < t && u[n] > t) return i;
                        o[n] > t ? a = i : o[n] < t && (s = i + 1)
                    }
                    return -1
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.insert = t.search = void 0, t.search = n, t.insert = function(e, t, s) {
                    if (void 0 === s && (s = "ticks"), e.length) {
                        var r = n(e, t[s], s);
                        e.splice(r + 1, 0, t)
                    } else e.push(t)
                }
            },
            796: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ControlChange = t.controlChangeIds = t.controlChangeNames = void 0, t.controlChangeNames = {
                    1: "modulationWheel",
                    2: "breath",
                    4: "footController",
                    5: "portamentoTime",
                    7: "volume",
                    8: "balance",
                    10: "pan",
                    64: "sustain",
                    65: "portamentoTime",
                    66: "sostenuto",
                    67: "softPedal",
                    68: "legatoFootswitch",
                    84: "portamentoControl"
                }, t.controlChangeIds = Object.keys(t.controlChangeNames).reduce((function(e, n) {
                    return e[t.controlChangeNames[n]] = n, e
                }), {});
                var n = new WeakMap,
                    s = new WeakMap,
                    r = function() {
                        function e(e, t) {
                            n.set(this, t), s.set(this, e.controllerType), this.ticks = e.absoluteTime, this.value = e.value
                        }
                        return Object.defineProperty(e.prototype, "number", {
                            get: function() {
                                return s.get(this)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "name", {
                            get: function() {
                                return t.controlChangeNames[this.number] ? t.controlChangeNames[this.number] : null
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "time", {
                            get: function() {
                                return n.get(this).ticksToSeconds(this.ticks)
                            },
                            set: function(e) {
                                var t = n.get(this);
                                this.ticks = t.secondsToTicks(e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.toJSON = function() {
                            return {
                                number: this.number,
                                ticks: this.ticks,
                                time: this.time,
                                value: this.value
                            }
                        }, e
                    }();
                t.ControlChange = r
            },
            651: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createControlChanges = void 0;
                var s = n(796);
                t.createControlChanges = function() {
                    return new Proxy({}, {
                        get: function(e, t) {
                            return e[t] ? e[t] : s.controlChangeIds.hasOwnProperty(t) ? e[s.controlChangeIds[t]] : void 0
                        },
                        set: function(e, t, n) {
                            return s.controlChangeIds.hasOwnProperty(t) ? e[s.controlChangeIds[t]] = n : e[t] = n, !0
                        }
                    })
                }
            },
            547: function(e, t, n) {
                "use strict";
                var s = this && this.__spreadArray || function(e, t, n) {
                    if (n || 2 === arguments.length)
                        for (var s, r = 0, a = t.length; r < a; r++) !s && r in t || (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
                    return e.concat(s || Array.prototype.slice.call(t))
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.encode = void 0;
                var r = n(965),
                    a = n(660),
                    i = n(804);

                function o(e) {
                    return (0, i.flatten)(e.notes.map((function(t) {
                        return function(e, t) {
                            return [{
                                absoluteTime: e.ticks,
                                channel: t,
                                deltaTime: 0,
                                noteNumber: e.midi,
                                type: "noteOn",
                                velocity: Math.floor(127 * e.velocity)
                            }, {
                                absoluteTime: e.ticks + e.durationTicks,
                                channel: t,
                                deltaTime: 0,
                                noteNumber: e.midi,
                                type: "noteOff",
                                velocity: Math.floor(127 * e.noteOffVelocity)
                            }]
                        }(t, e.channel)
                    })))
                }

                function u(e, t) {
                    return {
                        absoluteTime: e.ticks,
                        channel: t,
                        controllerType: e.number,
                        deltaTime: 0,
                        type: "controller",
                        value: Math.floor(127 * e.value)
                    }
                }

                function l(e) {
                    return {
                        absoluteTime: 0,
                        channel: e.channel,
                        deltaTime: 0,
                        programNumber: e.instrument.number,
                        type: "programChange"
                    }
                }
                t.encode = function(e) {
                    var t = {
                        header: {
                            format: 1,
                            numTracks: e.tracks.length + 1,
                            ticksPerBeat: e.header.ppq
                        },
                        tracks: s([s(s(s(s([{
                            absoluteTime: 0,
                            deltaTime: 0,
                            meta: !0,
                            text: e.header.name,
                            type: "trackName"
                        }], e.header.keySignatures.map((function(e) {
                            return function(e) {
                                var t = a.keySignatureKeys.indexOf(e.key);
                                return {
                                    absoluteTime: e.ticks,
                                    deltaTime: 0,
                                    key: t + 7,
                                    meta: !0,
                                    scale: "major" === e.scale ? 0 : 1,
                                    type: "keySignature"
                                }
                            }(e)
                        })), !0), e.header.meta.map((function(e) {
                            return {
                                absoluteTime: (t = e).ticks,
                                deltaTime: 0,
                                meta: !0,
                                text: t.text,
                                type: t.type
                            };
                            var t
                        })), !0), e.header.tempos.map((function(e) {
                            return function(e) {
                                return {
                                    absoluteTime: e.ticks,
                                    deltaTime: 0,
                                    meta: !0,
                                    microsecondsPerBeat: Math.floor(6e7 / e.bpm),
                                    type: "setTempo"
                                }
                            }(e)
                        })), !0), e.header.timeSignatures.map((function(e) {
                            return function(e) {
                                return {
                                    absoluteTime: e.ticks,
                                    deltaTime: 0,
                                    denominator: e.timeSignature[1],
                                    meta: !0,
                                    metronome: 24,
                                    numerator: e.timeSignature[0],
                                    thirtyseconds: 8,
                                    type: "timeSignature"
                                }
                            }(e)
                        })), !0)], e.tracks.map((function(e) {
                            return s(s(s([(t = e.name, {
                                absoluteTime: 0,
                                deltaTime: 0,
                                meta: !0,
                                text: t,
                                type: "trackName"
                            }), l(e)], o(e), !0), function(e) {
                                for (var t = [], n = 0; n < 127; n++) e.controlChanges.hasOwnProperty(n) && e.controlChanges[n].forEach((function(n) {
                                    t.push(u(n, e.channel))
                                }));
                                return t
                            }(e), !0), function(e) {
                                var t = [];
                                return e.pitchBends.forEach((function(n) {
                                    t.push(function(e, t) {
                                        return {
                                            absoluteTime: e.ticks,
                                            channel: t,
                                            deltaTime: 0,
                                            type: "pitchBend",
                                            value: e.value
                                        }
                                    }(n, e.channel))
                                })), t
                            }(e), !0);
                            var t
                        })), !0)
                    };
                    return t.tracks = t.tracks.map((function(e) {
                        e = e.sort((function(e, t) {
                            return e.absoluteTime - t.absoluteTime
                        }));
                        var t = 0;
                        return e.forEach((function(e) {
                            e.deltaTime = e.absoluteTime - t, t = e.absoluteTime, delete e.absoluteTime
                        })), e.push({
                            deltaTime: 0,
                            meta: !0,
                            type: "endOfTrack"
                        }), e
                    })), new Uint8Array((0, r.writeMidi)(t))
                }
            },
            660: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Header = t.keySignatureKeys = void 0;
                var s = n(412),
                    r = new WeakMap;
                t.keySignatureKeys = ["Cb", "Gb", "Db", "Ab", "Eb", "Bb", "F", "C", "G", "D", "A", "E", "B", "F#", "C#"];
                var a = function() {
                    function e(e) {
                        var n = this;
                        if (this.tempos = [], this.timeSignatures = [], this.keySignatures = [], this.meta = [], this.name = "", r.set(this, 480), e) {
                            r.set(this, e.header.ticksPerBeat), e.tracks.forEach((function(e) {
                                e.forEach((function(e) {
                                    e.meta && ("timeSignature" === e.type ? n.timeSignatures.push({
                                        ticks: e.absoluteTime,
                                        timeSignature: [e.numerator, e.denominator]
                                    }) : "setTempo" === e.type ? n.tempos.push({
                                        bpm: 6e7 / e.microsecondsPerBeat,
                                        ticks: e.absoluteTime
                                    }) : "keySignature" === e.type && n.keySignatures.push({
                                        key: t.keySignatureKeys[e.key + 7],
                                        scale: 0 === e.scale ? "major" : "minor",
                                        ticks: e.absoluteTime
                                    }))
                                }))
                            }));
                            var s = 0;
                            e.tracks[0].forEach((function(e) {
                                s += e.deltaTime, e.meta && ("trackName" === e.type ? n.name = e.text : "text" !== e.type && "cuePoint" !== e.type && "marker" !== e.type && "lyrics" !== e.type || n.meta.push({
                                    text: e.text,
                                    ticks: s,
                                    type: e.type
                                }))
                            })), this.update()
                        }
                    }
                    return e.prototype.update = function() {
                        var e = this,
                            t = 0,
                            n = 0;
                        this.tempos.sort((function(e, t) {
                            return e.ticks - t.ticks
                        })), this.tempos.forEach((function(s, r) {
                            var a = r > 0 ? e.tempos[r - 1].bpm : e.tempos[0].bpm,
                                i = s.ticks / e.ppq - n,
                                o = 60 / a * i;
                            s.time = o + t, t = s.time, n += i
                        })), this.timeSignatures.sort((function(e, t) {
                            return e.ticks - t.ticks
                        })), this.timeSignatures.forEach((function(t, n) {
                            var s = n > 0 ? e.timeSignatures[n - 1] : e.timeSignatures[0],
                                r = (t.ticks - s.ticks) / e.ppq / s.timeSignature[0] / (s.timeSignature[1] / 4);
                            s.measures = s.measures || 0, t.measures = r + s.measures
                        }))
                    }, e.prototype.ticksToSeconds = function(e) {
                        var t = (0, s.search)(this.tempos, e);
                        if (-1 !== t) {
                            var n = this.tempos[t],
                                r = n.time,
                                a = (e - n.ticks) / this.ppq;
                            return r + 60 / n.bpm * a
                        }
                        return .5 * (e / this.ppq)
                    }, e.prototype.ticksToMeasures = function(e) {
                        var t = (0, s.search)(this.timeSignatures, e);
                        if (-1 !== t) {
                            var n = this.timeSignatures[t],
                                r = (e - n.ticks) / this.ppq;
                            return n.measures + r / (n.timeSignature[0] / n.timeSignature[1]) / 4
                        }
                        return e / this.ppq / 4
                    }, Object.defineProperty(e.prototype, "ppq", {
                        get: function() {
                            return r.get(this)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.secondsToTicks = function(e) {
                        var t = (0, s.search)(this.tempos, e, "time");
                        if (-1 !== t) {
                            var n = this.tempos[t],
                                r = (e - n.time) / (60 / n.bpm);
                            return Math.round(n.ticks + r * this.ppq)
                        }
                        var a = e / .5;
                        return Math.round(a * this.ppq)
                    }, e.prototype.toJSON = function() {
                        return {
                            keySignatures: this.keySignatures,
                            meta: this.meta,
                            name: this.name,
                            ppq: this.ppq,
                            tempos: this.tempos.map((function(e) {
                                return {
                                    bpm: e.bpm,
                                    ticks: e.ticks
                                }
                            })),
                            timeSignatures: this.timeSignatures
                        }
                    }, e.prototype.fromJSON = function(e) {
                        this.name = e.name, this.tempos = e.tempos.map((function(e) {
                            return Object.assign({}, e)
                        })), this.timeSignatures = e.timeSignatures.map((function(e) {
                            return Object.assign({}, e)
                        })), this.keySignatures = e.keySignatures.map((function(e) {
                            return Object.assign({}, e)
                        })), this.meta = e.meta.map((function(e) {
                            return Object.assign({}, e)
                        })), r.set(this, e.ppq), this.update()
                    }, e.prototype.setTempo = function(e) {
                        this.tempos = [{
                            bpm: e,
                            ticks: 0
                        }], this.update()
                    }, e
                }();
                t.Header = a
            },
            980: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Instrument = void 0;
                var s = n(659),
                    r = new WeakMap,
                    a = function() {
                        function e(e, t) {
                            if (this.number = 0, r.set(this, t), this.number = 0, e) {
                                var n = e.find((function(e) {
                                    return "programChange" === e.type
                                }));
                                n && (this.number = n.programNumber)
                            }
                        }
                        return Object.defineProperty(e.prototype, "name", {
                            get: function() {
                                return this.percussion ? s.DrumKitByPatchID[this.number] : s.instrumentByPatchID[this.number]
                            },
                            set: function(e) {
                                var t = s.instrumentByPatchID.indexOf(e); - 1 !== t && (this.number = t)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "family", {
                            get: function() {
                                return this.percussion ? "drums" : s.InstrumentFamilyByID[Math.floor(this.number / 8)]
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "percussion", {
                            get: function() {
                                return 9 === r.get(this).channel
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.toJSON = function() {
                            return {
                                family: this.family,
                                number: this.number,
                                name: this.name
                            }
                        }, e.prototype.fromJSON = function(e) {
                            this.number = e.number
                        }, e
                    }();
                t.Instrument = a
            },
            659: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DrumKitByPatchID = t.InstrumentFamilyByID = t.instrumentByPatchID = void 0, t.instrumentByPatchID = ["acoustic grand piano", "bright acoustic piano", "electric grand piano", "honky-tonk piano", "electric piano 1", "electric piano 2", "harpsichord", "clavi", "celesta", "glockenspiel", "music box", "vibraphone", "marimba", "xylophone", "tubular bells", "dulcimer", "drawbar organ", "percussive organ", "rock organ", "church organ", "reed organ", "accordion", "harmonica", "tango accordion", "acoustic guitar (nylon)", "acoustic guitar (steel)", "electric guitar (jazz)", "electric guitar (clean)", "electric guitar (muted)", "overdriven guitar", "distortion guitar", "guitar harmonics", "acoustic bass", "electric bass (finger)", "electric bass (pick)", "fretless bass", "slap bass 1", "slap bass 2", "synth bass 1", "synth bass 2", "violin", "viola", "cello", "contrabass", "tremolo strings", "pizzicato strings", "orchestral harp", "timpani", "string ensemble 1", "string ensemble 2", "synthstrings 1", "synthstrings 2", "choir aahs", "voice oohs", "synth voice", "orchestra hit", "trumpet", "trombone", "tuba", "muted trumpet", "french horn", "brass section", "synthbrass 1", "synthbrass 2", "soprano sax", "alto sax", "tenor sax", "baritone sax", "oboe", "english horn", "bassoon", "clarinet", "piccolo", "flute", "recorder", "pan flute", "blown bottle", "shakuhachi", "whistle", "ocarina", "lead 1 (square)", "lead 2 (sawtooth)", "lead 3 (calliope)", "lead 4 (chiff)", "lead 5 (charang)", "lead 6 (voice)", "lead 7 (fifths)", "lead 8 (bass + lead)", "pad 1 (new age)", "pad 2 (warm)", "pad 3 (polysynth)", "pad 4 (choir)", "pad 5 (bowed)", "pad 6 (metallic)", "pad 7 (halo)", "pad 8 (sweep)", "fx 1 (rain)", "fx 2 (soundtrack)", "fx 3 (crystal)", "fx 4 (atmosphere)", "fx 5 (brightness)", "fx 6 (goblins)", "fx 7 (echoes)", "fx 8 (sci-fi)", "sitar", "banjo", "shamisen", "koto", "kalimba", "bag pipe", "fiddle", "shanai", "tinkle bell", "agogo", "steel drums", "woodblock", "taiko drum", "melodic tom", "synth drum", "reverse cymbal", "guitar fret noise", "breath noise", "seashore", "bird tweet", "telephone ring", "helicopter", "applause", "gunshot"], t.InstrumentFamilyByID = ["piano", "chromatic percussion", "organ", "guitar", "bass", "strings", "ensemble", "brass", "reed", "pipe", "synth lead", "synth pad", "synth effects", "world", "percussive", "sound effects"], t.DrumKitByPatchID = {
                    0: "standard kit",
                    8: "room kit",
                    16: "power kit",
                    24: "electronic kit",
                    25: "tr-808 kit",
                    32: "jazz kit",
                    40: "brush kit",
                    48: "orchestra kit",
                    56: "sound fx kit"
                }
            },
            748: function(e, t, n) {
                "use strict";
                var s = this && this.__awaiter || function(e, t, n, s) {
                        return new(n || (n = Promise))((function(r, a) {
                            function i(e) {
                                try {
                                    u(s.next(e))
                                } catch (e) {
                                    a(e)
                                }
                            }

                            function o(e) {
                                try {
                                    u(s.throw(e))
                                } catch (e) {
                                    a(e)
                                }
                            }

                            function u(e) {
                                var t;
                                e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                                    e(t)
                                }))).then(i, o)
                            }
                            u((s = s.apply(e, t || [])).next())
                        }))
                    },
                    r = this && this.__generator || function(e, t) {
                        var n, s, r, a, i = {
                            label: 0,
                            sent: function() {
                                if (1 & r[0]) throw r[1];
                                return r[1]
                            },
                            trys: [],
                            ops: []
                        };
                        return a = {
                            next: o(0),
                            throw: o(1),
                            return: o(2)
                        }, "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                            return this
                        }), a;

                        function o(a) {
                            return function(o) {
                                return function(a) {
                                    if (n) throw new TypeError("Generator is already executing.");
                                    for (; i;) try {
                                        if (n = 1, s && (r = 2 & a[0] ? s.return : a[0] ? s.throw || ((r = s.return) && r.call(s), 0) : s.next) && !(r = r.call(s, a[1])).done) return r;
                                        switch (s = 0, r && (a = [2 & a[0], r.value]), a[0]) {
                                            case 0:
                                            case 1:
                                                r = a;
                                                break;
                                            case 4:
                                                return i.label++, {
                                                    value: a[1],
                                                    done: !1
                                                };
                                            case 5:
                                                i.label++, s = a[1], a = [0];
                                                continue;
                                            case 7:
                                                a = i.ops.pop(), i.trys.pop();
                                                continue;
                                            default:
                                                if (!(r = i.trys, (r = r.length > 0 && r[r.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                                    i = 0;
                                                    continue
                                                }
                                                if (3 === a[0] && (!r || a[1] > r[0] && a[1] < r[3])) {
                                                    i.label = a[1];
                                                    break
                                                }
                                                if (6 === a[0] && i.label < r[1]) {
                                                    i.label = r[1], r = a;
                                                    break
                                                }
                                                if (r && i.label < r[2]) {
                                                    i.label = r[2], i.ops.push(a);
                                                    break
                                                }
                                                r[2] && i.ops.pop(), i.trys.pop();
                                                continue
                                        }
                                        a = t.call(e, i)
                                    } catch (e) {
                                        a = [6, e], s = 0
                                    } finally {
                                        n = r = 0
                                    }
                                    if (5 & a[0]) throw a[1];
                                    return {
                                        value: a[0] ? a[1] : void 0,
                                        done: !0
                                    }
                                }([a, o])
                            }
                        }
                    };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Header = t.Track = t.Midi = void 0;
                var a = n(965),
                    i = n(660),
                    o = n(710),
                    u = n(547),
                    l = function() {
                        function e(e) {
                            var t = this,
                                n = null;
                            if (e) {
                                var s = e instanceof ArrayBuffer ? new Uint8Array(e) : e;
                                (n = (0, a.parseMidi)(s)).tracks.forEach((function(e) {
                                    var t = 0;
                                    e.forEach((function(e) {
                                        t += e.deltaTime, e.absoluteTime = t
                                    }))
                                })), n.tracks = function(e) {
                                    for (var t = [], n = 0; n < e.length; n++)
                                        for (var s = t.length, r = new Map, a = Array(16).fill(0), i = 0, o = e[n]; i < o.length; i++) {
                                            var u = o[i],
                                                l = s,
                                                c = u.channel;
                                            if (void 0 !== c) {
                                                "programChange" === u.type && (a[c] = u.programNumber);
                                                var h = a[c],
                                                    p = "".concat(h, " ").concat(c);
                                                r.has(p) ? l = r.get(p) : (l = s + r.size, r.set(p, l))
                                            }
                                            t[l] || t.push([]), t[l].push(u)
                                        }
                                    return t
                                }(n.tracks)
                            }
                            this.header = new i.Header(n), this.tracks = [], e && (this.tracks = n.tracks.map((function(e) {
                                return new o.Track(e, t.header)
                            })), 1 === n.header.format && 0 === this.tracks[0].duration && this.tracks.shift())
                        }
                        return e.fromUrl = function(t) {
                            return s(this, void 0, void 0, (function() {
                                var n;
                                return r(this, (function(s) {
                                    switch (s.label) {
                                        case 0:
                                            return [4, fetch(t)];
                                        case 1:
                                            return (n = s.sent()).ok ? [4, n.arrayBuffer()] : [3, 3];
                                        case 2:
                                            return [2, new e(s.sent())];
                                        case 3:
                                            throw new Error("Could not load '".concat(t, "'"))
                                    }
                                }))
                            }))
                        }, Object.defineProperty(e.prototype, "name", {
                            get: function() {
                                return this.header.name
                            },
                            set: function(e) {
                                this.header.name = e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "duration", {
                            get: function() {
                                var e = this.tracks.map((function(e) {
                                    return e.duration
                                }));
                                return Math.max.apply(Math, e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "durationTicks", {
                            get: function() {
                                var e = this.tracks.map((function(e) {
                                    return e.durationTicks
                                }));
                                return Math.max.apply(Math, e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.addTrack = function() {
                            var e = new o.Track(void 0, this.header);
                            return this.tracks.push(e), e
                        }, e.prototype.toArray = function() {
                            return (0, u.encode)(this)
                        }, e.prototype.toJSON = function() {
                            return {
                                header: this.header.toJSON(),
                                tracks: this.tracks.map((function(e) {
                                    return e.toJSON()
                                }))
                            }
                        }, e.prototype.fromJSON = function(e) {
                            var t = this;
                            this.header = new i.Header, this.header.fromJSON(e.header), this.tracks = e.tracks.map((function(e) {
                                var n = new o.Track(void 0, t.header);
                                return n.fromJSON(e), n
                            }))
                        }, e.prototype.clone = function() {
                            var t = new e;
                            return t.fromJSON(this.toJSON()), t
                        }, e
                    }();
                t.Midi = l;
                var c = n(710);
                Object.defineProperty(t, "Track", {
                    enumerable: !0,
                    get: function() {
                        return c.Track
                    }
                });
                var h = n(660);
                Object.defineProperty(t, "Header", {
                    enumerable: !0,
                    get: function() {
                        return h.Header
                    }
                })
            },
            445: (e, t) => {
                "use strict";

                function n(e) {
                    return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"][e % 12]
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Note = void 0;
                var s, r, a = (s = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i, r = {
                        cbb: -2,
                        cb: -1,
                        c: 0,
                        "c#": 1,
                        cx: 2,
                        dbb: 0,
                        db: 1,
                        d: 2,
                        "d#": 3,
                        dx: 4,
                        ebb: 2,
                        eb: 3,
                        e: 4,
                        "e#": 5,
                        ex: 6,
                        fbb: 3,
                        fb: 4,
                        f: 5,
                        "f#": 6,
                        fx: 7,
                        gbb: 5,
                        gb: 6,
                        g: 7,
                        "g#": 8,
                        gx: 9,
                        abb: 7,
                        ab: 8,
                        a: 9,
                        "a#": 10,
                        ax: 11,
                        bbb: 9,
                        bb: 10,
                        b: 11,
                        "b#": 12,
                        bx: 13
                    }, function(e) {
                        var t = s.exec(e),
                            n = t[1],
                            a = t[2];
                        return r[n.toLowerCase()] + 12 * (parseInt(a, 10) + 1)
                    }),
                    i = new WeakMap,
                    o = function() {
                        function e(e, t, n) {
                            i.set(this, n), this.midi = e.midi, this.velocity = e.velocity, this.noteOffVelocity = t.velocity, this.ticks = e.ticks, this.durationTicks = t.ticks - e.ticks
                        }
                        return Object.defineProperty(e.prototype, "name", {
                            get: function() {
                                return e = this.midi, t = Math.floor(e / 12) - 1, n(e) + t.toString();
                                var e, t
                            },
                            set: function(e) {
                                this.midi = a(e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "octave", {
                            get: function() {
                                return Math.floor(this.midi / 12) - 1
                            },
                            set: function(e) {
                                var t = e - this.octave;
                                this.midi += 12 * t
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "pitch", {
                            get: function() {
                                return n(this.midi)
                            },
                            set: function(e) {
                                this.midi = 12 * (this.octave + 1) + ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"].indexOf(e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "duration", {
                            get: function() {
                                var e = i.get(this);
                                return e.ticksToSeconds(this.ticks + this.durationTicks) - e.ticksToSeconds(this.ticks)
                            },
                            set: function(e) {
                                var t = i.get(this).secondsToTicks(this.time + e);
                                this.durationTicks = t - this.ticks
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "time", {
                            get: function() {
                                return i.get(this).ticksToSeconds(this.ticks)
                            },
                            set: function(e) {
                                var t = i.get(this);
                                this.ticks = t.secondsToTicks(e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "bars", {
                            get: function() {
                                return i.get(this).ticksToMeasures(this.ticks)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.toJSON = function() {
                            return {
                                duration: this.duration,
                                durationTicks: this.durationTicks,
                                midi: this.midi,
                                name: this.name,
                                ticks: this.ticks,
                                time: this.time,
                                velocity: this.velocity
                            }
                        }, e
                    }();
                t.Note = o
            },
            996: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.PitchBend = void 0;
                var n = new WeakMap,
                    s = function() {
                        function e(e, t) {
                            n.set(this, t), this.ticks = e.absoluteTime, this.value = e.value
                        }
                        return Object.defineProperty(e.prototype, "time", {
                            get: function() {
                                return n.get(this).ticksToSeconds(this.ticks)
                            },
                            set: function(e) {
                                var t = n.get(this);
                                this.ticks = t.secondsToTicks(e)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.toJSON = function() {
                            return {
                                ticks: this.ticks,
                                time: this.time,
                                value: this.value
                            }
                        }, e
                    }();
                t.PitchBend = s
            },
            710: (e, t, n) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Track = void 0;
                var s = n(412),
                    r = n(796),
                    a = n(651),
                    i = n(996),
                    o = n(980),
                    u = n(445),
                    l = new WeakMap,
                    c = function() {
                        function e(e, t) {
                            var n = this;
                            if (this.name = "", this.notes = [], this.controlChanges = (0, a.createControlChanges)(), this.pitchBends = [], l.set(this, t), e) {
                                var s = e.find((function(e) {
                                    return "trackName" === e.type
                                }));
                                this.name = s ? s.text : ""
                            }
                            if (this.instrument = new o.Instrument(e, this), this.channel = 0, e) {
                                for (var r = e.filter((function(e) {
                                        return "noteOn" === e.type
                                    })), i = e.filter((function(e) {
                                        return "noteOff" === e.type
                                    })), u = function() {
                                        var e = r.shift();
                                        c.channel = e.channel;
                                        var t = i.findIndex((function(t) {
                                            return t.noteNumber === e.noteNumber && t.absoluteTime >= e.absoluteTime
                                        }));
                                        if (-1 !== t) {
                                            var n = i.splice(t, 1)[0];
                                            c.addNote({
                                                durationTicks: n.absoluteTime - e.absoluteTime,
                                                midi: e.noteNumber,
                                                noteOffVelocity: n.velocity / 127,
                                                ticks: e.absoluteTime,
                                                velocity: e.velocity / 127
                                            })
                                        }
                                    }, c = this; r.length;) u();
                                e.filter((function(e) {
                                    return "controller" === e.type
                                })).forEach((function(e) {
                                    n.addCC({
                                        number: e.controllerType,
                                        ticks: e.absoluteTime,
                                        value: e.value / 127
                                    })
                                })), e.filter((function(e) {
                                    return "pitchBend" === e.type
                                })).forEach((function(e) {
                                    n.addPitchBend({
                                        ticks: e.absoluteTime,
                                        value: e.value / Math.pow(2, 13)
                                    })
                                }));
                                var h = e.find((function(e) {
                                    return "endOfTrack" === e.type
                                }));
                                this.endOfTrackTicks = void 0 !== h ? h.absoluteTime : void 0
                            }
                        }
                        return e.prototype.addNote = function(e) {
                            var t = l.get(this),
                                n = new u.Note({
                                    midi: 0,
                                    ticks: 0,
                                    velocity: 1
                                }, {
                                    ticks: 0,
                                    velocity: 0
                                }, t);
                            return Object.assign(n, e), (0, s.insert)(this.notes, n, "ticks"), this
                        }, e.prototype.addCC = function(e) {
                            var t = l.get(this),
                                n = new r.ControlChange({
                                    controllerType: e.number
                                }, t);
                            return delete e.number, Object.assign(n, e), Array.isArray(this.controlChanges[n.number]) || (this.controlChanges[n.number] = []), (0, s.insert)(this.controlChanges[n.number], n, "ticks"), this
                        }, e.prototype.addPitchBend = function(e) {
                            var t = l.get(this),
                                n = new i.PitchBend({}, t);
                            return Object.assign(n, e), (0, s.insert)(this.pitchBends, n, "ticks"), this
                        }, Object.defineProperty(e.prototype, "duration", {
                            get: function() {
                                if (!this.notes.length) return 0;
                                for (var e = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration, t = 0; t < this.notes.length - 1; t++) {
                                    var n = this.notes[t].time + this.notes[t].duration;
                                    e < n && (e = n)
                                }
                                return e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "durationTicks", {
                            get: function() {
                                if (!this.notes.length) return 0;
                                for (var e = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks, t = 0; t < this.notes.length - 1; t++) {
                                    var n = this.notes[t].ticks + this.notes[t].durationTicks;
                                    e < n && (e = n)
                                }
                                return e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.prototype.fromJSON = function(e) {
                            var t = this;
                            for (var n in this.name = e.name, this.channel = e.channel, this.instrument = new o.Instrument(void 0, this), this.instrument.fromJSON(e.instrument), void 0 !== e.endOfTrackTicks && (this.endOfTrackTicks = e.endOfTrackTicks), e.controlChanges) e.controlChanges[n] && e.controlChanges[n].forEach((function(e) {
                                t.addCC({
                                    number: e.number,
                                    ticks: e.ticks,
                                    value: e.value
                                })
                            }));
                            e.notes.forEach((function(e) {
                                t.addNote({
                                    durationTicks: e.durationTicks,
                                    midi: e.midi,
                                    ticks: e.ticks,
                                    velocity: e.velocity
                                })
                            }))
                        }, e.prototype.toJSON = function() {
                            for (var e = {}, t = 0; t < 127; t++) this.controlChanges.hasOwnProperty(t) && (e[t] = this.controlChanges[t].map((function(e) {
                                return e.toJSON()
                            })));
                            var n = {
                                channel: this.channel,
                                controlChanges: e,
                                pitchBends: this.pitchBends.map((function(e) {
                                    return e.toJSON()
                                })),
                                instrument: this.instrument.toJSON(),
                                name: this.name,
                                notes: this.notes.map((function(e) {
                                    return e.toJSON()
                                }))
                            };
                            return void 0 !== this.endOfTrackTicks && (n.endOfTrackTicks = this.endOfTrackTicks), n
                        }, e
                    }();
                t.Track = c
            },
            804: (e, t, n) => {
                "use strict";

                function s(e) {
                    var t = [];
                    return r(e, t), t
                }

                function r(e, t) {
                    for (var n = 0; n < e.length; n++) {
                        var s = e[n];
                        Array.isArray(s) ? r(s, t) : t.push(s)
                    }
                }
                n.r(t), n.d(t, {
                    flatten: () => s
                })
            },
            570: e => {
                e.exports = n;
                var t = null;
                try {
                    t = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports
                } catch (e) {}

                function n(e, t, n) {
                    this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n
                }

                function s(e) {
                    return !0 === (e && e.__isLong__)
                }
                n.prototype.__isLong__, Object.defineProperty(n.prototype, "__isLong__", {
                    value: !0
                }), n.isLong = s;
                var r = {},
                    a = {};

                function i(e, t) {
                    var n, s, i;
                    return t ? (i = 0 <= (e >>>= 0) && e < 256) && (s = a[e]) ? s : (n = u(e, (0 | e) < 0 ? -1 : 0, !0), i && (a[e] = n), n) : (i = -128 <= (e |= 0) && e < 128) && (s = r[e]) ? s : (n = u(e, e < 0 ? -1 : 0, !1), i && (r[e] = n), n)
                }

                function o(e, t) {
                    if (isNaN(e)) return t ? y : g;
                    if (t) {
                        if (e < 0) return y;
                        if (e >= d) return v
                    } else {
                        if (e <= -f) return I;
                        if (e + 1 >= f) return k
                    }
                    return e < 0 ? o(-e, t).neg() : u(e % p | 0, e / p | 0, t)
                }

                function u(e, t, s) {
                    return new n(e, t, s)
                }
                n.fromInt = i, n.fromNumber = o, n.fromBits = u;
                var l = Math.pow;

                function c(e, t, n) {
                    if (0 === e.length) throw Error("empty string");
                    if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return g;
                    if ("number" == typeof t ? (n = t, t = !1) : t = !!t, (n = n || 10) < 2 || 36 < n) throw RangeError("radix");
                    var s;
                    if ((s = e.indexOf("-")) > 0) throw Error("interior hyphen");
                    if (0 === s) return c(e.substring(1), t, n).neg();
                    for (var r = o(l(n, 8)), a = g, i = 0; i < e.length; i += 8) {
                        var u = Math.min(8, e.length - i),
                            h = parseInt(e.substring(i, i + u), n);
                        if (u < 8) {
                            var p = o(l(n, u));
                            a = a.mul(p).add(o(h))
                        } else a = (a = a.mul(r)).add(o(h))
                    }
                    return a.unsigned = t, a
                }

                function h(e, t) {
                    return "number" == typeof e ? o(e, t) : "string" == typeof e ? c(e, t) : u(e.low, e.high, "boolean" == typeof t ? t : e.unsigned)
                }
                n.fromString = c, n.fromValue = h;
                var p = 4294967296,
                    d = p * p,
                    f = d / 2,
                    m = i(1 << 24),
                    g = i(0);
                n.ZERO = g;
                var y = i(0, !0);
                n.UZERO = y;
                var b = i(1);
                n.ONE = b;
                var x = i(1, !0);
                n.UONE = x;
                var w = i(-1);
                n.NEG_ONE = w;
                var k = u(-1, 2147483647, !1);
                n.MAX_VALUE = k;
                var v = u(-1, -1, !0);
                n.MAX_UNSIGNED_VALUE = v;
                var I = u(0, -2147483648, !1);
                n.MIN_VALUE = I;
                var N = n.prototype;
                N.toInt = function() {
                    return this.unsigned ? this.low >>> 0 : this.low
                }, N.toNumber = function() {
                    return this.unsigned ? (this.high >>> 0) * p + (this.low >>> 0) : this.high * p + (this.low >>> 0)
                }, N.toString = function(e) {
                    if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
                    if (this.isZero()) return "0";
                    if (this.isNegative()) {
                        if (this.eq(I)) {
                            var t = o(e),
                                n = this.div(t),
                                s = n.mul(t).sub(this);
                            return n.toString(e) + s.toInt().toString(e)
                        }
                        return "-" + this.neg().toString(e)
                    }
                    for (var r = o(l(e, 6), this.unsigned), a = this, i = "";;) {
                        var u = a.div(r),
                            c = (a.sub(u.mul(r)).toInt() >>> 0).toString(e);
                        if ((a = u).isZero()) return c + i;
                        for (; c.length < 6;) c = "0" + c;
                        i = "" + c + i
                    }
                }, N.getHighBits = function() {
                    return this.high
                }, N.getHighBitsUnsigned = function() {
                    return this.high >>> 0
                }, N.getLowBits = function() {
                    return this.low
                }, N.getLowBitsUnsigned = function() {
                    return this.low >>> 0
                }, N.getNumBitsAbs = function() {
                    if (this.isNegative()) return this.eq(I) ? 64 : this.neg().getNumBitsAbs();
                    for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && !(e & 1 << t); t--);
                    return 0 != this.high ? t + 33 : t + 1
                }, N.isZero = function() {
                    return 0 === this.high && 0 === this.low
                }, N.eqz = N.isZero, N.isNegative = function() {
                    return !this.unsigned && this.high < 0
                }, N.isPositive = function() {
                    return this.unsigned || this.high >= 0
                }, N.isOdd = function() {
                    return !(1 & ~this.low)
                }, N.isEven = function() {
                    return !(1 & this.low)
                }, N.equals = function(e) {
                    return s(e) || (e = h(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && (this.high === e.high && this.low === e.low)
                }, N.eq = N.equals, N.notEquals = function(e) {
                    return !this.eq(e)
                }, N.neq = N.notEquals, N.ne = N.notEquals, N.lessThan = function(e) {
                    return this.comp(e) < 0
                }, N.lt = N.lessThan, N.lessThanOrEqual = function(e) {
                    return this.comp(e) <= 0
                }, N.lte = N.lessThanOrEqual, N.le = N.lessThanOrEqual, N.greaterThan = function(e) {
                    return this.comp(e) > 0
                }, N.gt = N.greaterThan, N.greaterThanOrEqual = function(e) {
                    return this.comp(e) >= 0
                }, N.gte = N.greaterThanOrEqual, N.ge = N.greaterThanOrEqual, N.compare = function(e) {
                    if (s(e) || (e = h(e)), this.eq(e)) return 0;
                    var t = this.isNegative(),
                        n = e.isNegative();
                    return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1
                }, N.comp = N.compare, N.negate = function() {
                    return !this.unsigned && this.eq(I) ? I : this.not().add(b)
                }, N.neg = N.negate, N.add = function(e) {
                    s(e) || (e = h(e));
                    var t = this.high >>> 16,
                        n = 65535 & this.high,
                        r = this.low >>> 16,
                        a = 65535 & this.low,
                        i = e.high >>> 16,
                        o = 65535 & e.high,
                        l = e.low >>> 16,
                        c = 0,
                        p = 0,
                        d = 0,
                        f = 0;
                    return d += (f += a + (65535 & e.low)) >>> 16, p += (d += r + l) >>> 16, c += (p += n + o) >>> 16, c += t + i, u((d &= 65535) << 16 | (f &= 65535), (c &= 65535) << 16 | (p &= 65535), this.unsigned)
                }, N.subtract = function(e) {
                    return s(e) || (e = h(e)), this.add(e.neg())
                }, N.sub = N.subtract, N.multiply = function(e) {
                    if (this.isZero()) return g;
                    if (s(e) || (e = h(e)), t) return u(t.mul(this.low, this.high, e.low, e.high), t.get_high(), this.unsigned);
                    if (e.isZero()) return g;
                    if (this.eq(I)) return e.isOdd() ? I : g;
                    if (e.eq(I)) return this.isOdd() ? I : g;
                    if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
                    if (e.isNegative()) return this.mul(e.neg()).neg();
                    if (this.lt(m) && e.lt(m)) return o(this.toNumber() * e.toNumber(), this.unsigned);
                    var n = this.high >>> 16,
                        r = 65535 & this.high,
                        a = this.low >>> 16,
                        i = 65535 & this.low,
                        l = e.high >>> 16,
                        c = 65535 & e.high,
                        p = e.low >>> 16,
                        d = 65535 & e.low,
                        f = 0,
                        y = 0,
                        b = 0,
                        x = 0;
                    return b += (x += i * d) >>> 16, y += (b += a * d) >>> 16, b &= 65535, y += (b += i * p) >>> 16, f += (y += r * d) >>> 16, y &= 65535, f += (y += a * p) >>> 16, y &= 65535, f += (y += i * c) >>> 16, f += n * d + r * p + a * c + i * l, u((b &= 65535) << 16 | (x &= 65535), (f &= 65535) << 16 | (y &= 65535), this.unsigned)
                }, N.mul = N.multiply, N.divide = function(e) {
                    if (s(e) || (e = h(e)), e.isZero()) throw Error("division by zero");
                    var n, r, a;
                    if (t) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? u((this.unsigned ? t.div_u : t.div_s)(this.low, this.high, e.low, e.high), t.get_high(), this.unsigned) : this;
                    if (this.isZero()) return this.unsigned ? y : g;
                    if (this.unsigned) {
                        if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return y;
                        if (e.gt(this.shru(1))) return x;
                        a = y
                    } else {
                        if (this.eq(I)) return e.eq(b) || e.eq(w) ? I : e.eq(I) ? b : (n = this.shr(1).div(e).shl(1)).eq(g) ? e.isNegative() ? b : w : (r = this.sub(e.mul(n)), a = n.add(r.div(e)));
                        if (e.eq(I)) return this.unsigned ? y : g;
                        if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
                        if (e.isNegative()) return this.div(e.neg()).neg();
                        a = g
                    }
                    for (r = this; r.gte(e);) {
                        n = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));
                        for (var i = Math.ceil(Math.log(n) / Math.LN2), c = i <= 48 ? 1 : l(2, i - 48), p = o(n), d = p.mul(e); d.isNegative() || d.gt(r);) d = (p = o(n -= c, this.unsigned)).mul(e);
                        p.isZero() && (p = b), a = a.add(p), r = r.sub(d)
                    }
                    return a
                }, N.div = N.divide, N.modulo = function(e) {
                    return s(e) || (e = h(e)), t ? u((this.unsigned ? t.rem_u : t.rem_s)(this.low, this.high, e.low, e.high), t.get_high(), this.unsigned) : this.sub(this.div(e).mul(e))
                }, N.mod = N.modulo, N.rem = N.modulo, N.not = function() {
                    return u(~this.low, ~this.high, this.unsigned)
                }, N.and = function(e) {
                    return s(e) || (e = h(e)), u(this.low & e.low, this.high & e.high, this.unsigned)
                }, N.or = function(e) {
                    return s(e) || (e = h(e)), u(this.low | e.low, this.high | e.high, this.unsigned)
                }, N.xor = function(e) {
                    return s(e) || (e = h(e)), u(this.low ^ e.low, this.high ^ e.high, this.unsigned)
                }, N.shiftLeft = function(e) {
                    return s(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? u(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : u(0, this.low << e - 32, this.unsigned)
                }, N.shl = N.shiftLeft, N.shiftRight = function(e) {
                    return s(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? u(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : u(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned)
                }, N.shr = N.shiftRight, N.shiftRightUnsigned = function(e) {
                    if (s(e) && (e = e.toInt()), 0 === (e &= 63)) return this;
                    var t = this.high;
                    return e < 32 ? u(this.low >>> e | t << 32 - e, t >>> e, this.unsigned) : u(32 === e ? t : t >>> e - 32, 0, this.unsigned)
                }, N.shru = N.shiftRightUnsigned, N.shr_u = N.shiftRightUnsigned, N.toSigned = function() {
                    return this.unsigned ? u(this.low, this.high, !1) : this
                }, N.toUnsigned = function() {
                    return this.unsigned ? this : u(this.low, this.high, !0)
                }, N.toBytes = function(e) {
                    return e ? this.toBytesLE() : this.toBytesBE()
                }, N.toBytesLE = function() {
                    var e = this.high,
                        t = this.low;
                    return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24]
                }, N.toBytesBE = function() {
                    var e = this.high,
                        t = this.low;
                    return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t]
                }, n.fromBytes = function(e, t, s) {
                    return s ? n.fromBytesLE(e, t) : n.fromBytesBE(e, t)
                }, n.fromBytesLE = function(e, t) {
                    return new n(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t)
                }, n.fromBytesBE = function(e, t) {
                    return new n(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t)
                }
            },
            965: (e, t, n) => {
                t.parseMidi = n(786), t.writeMidi = n(498)
            },
            786: e => {
                function t(e) {
                    for (var t, s = new n(e), r = []; !s.eof();) {
                        var a = i();
                        r.push(a)
                    }
                    return r;

                    function i() {
                        var e = {};
                        e.deltaTime = s.readVarInt();
                        var n = s.readUInt8();
                        if (240 & ~n) {
                            var r;
                            if (128 & n) r = s.readUInt8(), t = n;
                            else {
                                if (null === t) throw "Running status byte encountered before status byte";
                                r = n, n = t, e.running = !0
                            }
                            var a = n >> 4;
                            switch (e.channel = 15 & n, a) {
                                case 8:
                                    return e.type = "noteOff", e.noteNumber = r, e.velocity = s.readUInt8(), e;
                                case 9:
                                    var i = s.readUInt8();
                                    return e.type = 0 === i ? "noteOff" : "noteOn", e.noteNumber = r, e.velocity = i, 0 === i && (e.byte9 = !0), e;
                                case 10:
                                    return e.type = "noteAftertouch", e.noteNumber = r, e.amount = s.readUInt8(), e;
                                case 11:
                                    return e.type = "controller", e.controllerType = r, e.value = s.readUInt8(), e;
                                case 12:
                                    return e.type = "programChange", e.programNumber = r, e;
                                case 13:
                                    return e.type = "channelAftertouch", e.amount = r, e;
                                case 14:
                                    return e.type = "pitchBend", e.value = r + (s.readUInt8() << 7) - 8192, e;
                                default:
                                    throw "Unrecognised MIDI event type: " + a
                            }
                        } else {
                            if (255 !== n) {
                                if (240 == n) {
                                    e.type = "sysEx";
                                    u = s.readVarInt();
                                    return e.data = s.readBytes(u), e
                                }
                                if (247 == n) {
                                    e.type = "endSysEx";
                                    u = s.readVarInt();
                                    return e.data = s.readBytes(u), e
                                }
                                throw "Unrecognised MIDI event type byte: " + n
                            }
                            e.meta = !0;
                            var o = s.readUInt8(),
                                u = s.readVarInt();
                            switch (o) {
                                case 0:
                                    if (e.type = "sequenceNumber", 2 !== u) throw "Expected length for sequenceNumber event is 2, got " + u;
                                    return e.number = s.readUInt16(), e;
                                case 1:
                                    return e.type = "text", e.text = s.readString(u), e;
                                case 2:
                                    return e.type = "copyrightNotice", e.text = s.readString(u), e;
                                case 3:
                                    return e.type = "trackName", e.text = s.readString(u), e;
                                case 4:
                                    return e.type = "instrumentName", e.text = s.readString(u), e;
                                case 5:
                                    return e.type = "lyrics", e.text = s.readString(u), e;
                                case 6:
                                    return e.type = "marker", e.text = s.readString(u), e;
                                case 7:
                                    return e.type = "cuePoint", e.text = s.readString(u), e;
                                case 32:
                                    if (e.type = "channelPrefix", 1 != u) throw "Expected length for channelPrefix event is 1, got " + u;
                                    return e.channel = s.readUInt8(), e;
                                case 33:
                                    if (e.type = "portPrefix", 1 != u) throw "Expected length for portPrefix event is 1, got " + u;
                                    return e.port = s.readUInt8(), e;
                                case 47:
                                    if (e.type = "endOfTrack", 0 != u) throw "Expected length for endOfTrack event is 0, got " + u;
                                    return e;
                                case 81:
                                    if (e.type = "setTempo", 3 != u) throw "Expected length for setTempo event is 3, got " + u;
                                    return e.microsecondsPerBeat = s.readUInt24(), e;
                                case 84:
                                    if (e.type = "smpteOffset", 5 != u) throw "Expected length for smpteOffset event is 5, got " + u;
                                    var l = s.readUInt8();
                                    return e.frameRate = {
                                        0: 24,
                                        32: 25,
                                        64: 29,
                                        96: 30
                                    } [96 & l], e.hour = 31 & l, e.min = s.readUInt8(), e.sec = s.readUInt8(), e.frame = s.readUInt8(), e.subFrame = s.readUInt8(), e;
                                case 88:
                                    if (e.type = "timeSignature", 2 != u && 4 != u) throw "Expected length for timeSignature event is 4 or 2, got " + u;
                                    return e.numerator = s.readUInt8(), e.denominator = 1 << s.readUInt8(), 4 === u ? (e.metronome = s.readUInt8(), e.thirtyseconds = s.readUInt8()) : (e.metronome = 36, e.thirtyseconds = 8), e;
                                case 89:
                                    if (e.type = "keySignature", 2 != u) throw "Expected length for keySignature event is 2, got " + u;
                                    return e.key = s.readInt8(), e.scale = s.readUInt8(), e;
                                case 127:
                                    return e.type = "sequencerSpecific", e.data = s.readBytes(u), e;
                                default:
                                    return e.type = "unknownMeta", e.data = s.readBytes(u), e.metatypeByte = o, e
                            }
                        }
                    }
                }

                function n(e) {
                    this.buffer = e, this.bufferLen = this.buffer.length, this.pos = 0
                }
                n.prototype.eof = function() {
                    return this.pos >= this.bufferLen
                }, n.prototype.readUInt8 = function() {
                    var e = this.buffer[this.pos];
                    return this.pos += 1, e
                }, n.prototype.readInt8 = function() {
                    var e = this.readUInt8();
                    return 128 & e ? e - 256 : e
                }, n.prototype.readUInt16 = function() {
                    return (this.readUInt8() << 8) + this.readUInt8()
                }, n.prototype.readInt16 = function() {
                    var e = this.readUInt16();
                    return 32768 & e ? e - 65536 : e
                }, n.prototype.readUInt24 = function() {
                    return (this.readUInt8() << 16) + (this.readUInt8() << 8) + this.readUInt8()
                }, n.prototype.readInt24 = function() {
                    var e = this.readUInt24();
                    return 8388608 & e ? e - 16777216 : e
                }, n.prototype.readUInt32 = function() {
                    return (this.readUInt8() << 24) + (this.readUInt8() << 16) + (this.readUInt8() << 8) + this.readUInt8()
                }, n.prototype.readBytes = function(e) {
                    var t = this.buffer.slice(this.pos, this.pos + e);
                    return this.pos += e, t
                }, n.prototype.readString = function(e) {
                    var t = this.readBytes(e);
                    return String.fromCharCode.apply(null, t)
                }, n.prototype.readVarInt = function() {
                    for (var e = 0; !this.eof();) {
                        var t = this.readUInt8();
                        if (!(128 & t)) return e + t;
                        e += 127 & t, e <<= 7
                    }
                    return e
                }, n.prototype.readChunk = function() {
                    var e = this.readString(4),
                        t = this.readUInt32();
                    return {
                        id: e,
                        length: t,
                        data: this.readBytes(t)
                    }
                }, e.exports = function(e) {
                    var s = new n(e),
                        r = s.readChunk();
                    if ("MThd" != r.id) throw "Bad MIDI file.  Expected 'MHdr', got: '" + r.id + "'";
                    for (var a = function(e) {
                            var t = new n(e),
                                s = t.readUInt16(),
                                r = t.readUInt16(),
                                a = {
                                    format: s,
                                    numTracks: r
                                },
                                i = t.readUInt16();
                            32768 & i ? (a.framesPerSecond = 256 - (i >> 8), a.ticksPerFrame = 255 & i) : a.ticksPerBeat = i;
                            return a
                        }(r.data), i = [], o = 0; !s.eof() && o < a.numTracks; o++) {
                        var u = s.readChunk();
                        if ("MTrk" != u.id) throw "Bad MIDI file.  Expected 'MTrk', got: '" + u.id + "'";
                        var l = t(u.data);
                        i.push(l)
                    }
                    return {
                        header: a,
                        tracks: i
                    }
                }
            },
            498: e => {
                function t(e, t, r) {
                    var a, i = new s,
                        o = t.length,
                        u = null;
                    for (a = 0; a < o; a++) !1 !== r.running && (r.running || t[a].running) || (u = null), u = n(i, t[a], u, r.useByte9ForNoteOff);
                    e.writeChunk("MTrk", i.buffer)
                }

                function n(e, t, n, s) {
                    var r = t.type,
                        a = t.deltaTime,
                        i = t.text || "",
                        o = t.data || [],
                        u = null;
                    switch (e.writeVarInt(a), r) {
                        case "sequenceNumber":
                            e.writeUInt8(255), e.writeUInt8(0), e.writeVarInt(2), e.writeUInt16(t.number);
                            break;
                        case "text":
                            e.writeUInt8(255), e.writeUInt8(1), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "copyrightNotice":
                            e.writeUInt8(255), e.writeUInt8(2), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "trackName":
                            e.writeUInt8(255), e.writeUInt8(3), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "instrumentName":
                            e.writeUInt8(255), e.writeUInt8(4), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "lyrics":
                            e.writeUInt8(255), e.writeUInt8(5), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "marker":
                            e.writeUInt8(255), e.writeUInt8(6), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "cuePoint":
                            e.writeUInt8(255), e.writeUInt8(7), e.writeVarInt(i.length), e.writeString(i);
                            break;
                        case "channelPrefix":
                            e.writeUInt8(255), e.writeUInt8(32), e.writeVarInt(1), e.writeUInt8(t.channel);
                            break;
                        case "portPrefix":
                            e.writeUInt8(255), e.writeUInt8(33), e.writeVarInt(1), e.writeUInt8(t.port);
                            break;
                        case "endOfTrack":
                            e.writeUInt8(255), e.writeUInt8(47), e.writeVarInt(0);
                            break;
                        case "setTempo":
                            e.writeUInt8(255), e.writeUInt8(81), e.writeVarInt(3), e.writeUInt24(t.microsecondsPerBeat);
                            break;
                        case "smpteOffset":
                            e.writeUInt8(255), e.writeUInt8(84), e.writeVarInt(5);
                            var l = 31 & t.hour | {
                                24: 0,
                                25: 32,
                                29: 64,
                                30: 96
                            } [t.frameRate];
                            e.writeUInt8(l), e.writeUInt8(t.min), e.writeUInt8(t.sec), e.writeUInt8(t.frame), e.writeUInt8(t.subFrame);
                            break;
                        case "timeSignature":
                            e.writeUInt8(255), e.writeUInt8(88), e.writeVarInt(4), e.writeUInt8(t.numerator);
                            var c = 255 & Math.floor(Math.log(t.denominator) / Math.LN2);
                            e.writeUInt8(c), e.writeUInt8(t.metronome), e.writeUInt8(t.thirtyseconds || 8);
                            break;
                        case "keySignature":
                            e.writeUInt8(255), e.writeUInt8(89), e.writeVarInt(2), e.writeInt8(t.key), e.writeUInt8(t.scale);
                            break;
                        case "sequencerSpecific":
                            e.writeUInt8(255), e.writeUInt8(127), e.writeVarInt(o.length), e.writeBytes(o);
                            break;
                        case "unknownMeta":
                            null != t.metatypeByte && (e.writeUInt8(255), e.writeUInt8(t.metatypeByte), e.writeVarInt(o.length), e.writeBytes(o));
                            break;
                        case "sysEx":
                            e.writeUInt8(240), e.writeVarInt(o.length), e.writeBytes(o);
                            break;
                        case "endSysEx":
                            e.writeUInt8(247), e.writeVarInt(o.length), e.writeBytes(o);
                            break;
                        case "noteOff":
                            (u = (!1 !== s && t.byte9 || s && 0 == t.velocity ? 144 : 128) | t.channel) !== n && e.writeUInt8(u), e.writeUInt8(t.noteNumber), e.writeUInt8(t.velocity);
                            break;
                        case "noteOn":
                            (u = 144 | t.channel) !== n && e.writeUInt8(u), e.writeUInt8(t.noteNumber), e.writeUInt8(t.velocity);
                            break;
                        case "noteAftertouch":
                            (u = 160 | t.channel) !== n && e.writeUInt8(u), e.writeUInt8(t.noteNumber), e.writeUInt8(t.amount);
                            break;
                        case "controller":
                            (u = 176 | t.channel) !== n && e.writeUInt8(u), e.writeUInt8(t.controllerType), e.writeUInt8(t.value);
                            break;
                        case "programChange":
                            (u = 192 | t.channel) !== n && e.writeUInt8(u), e.writeUInt8(t.programNumber);
                            break;
                        case "channelAftertouch":
                            (u = 208 | t.channel) !== n && e.writeUInt8(u), e.writeUInt8(t.amount);
                            break;
                        case "pitchBend":
                            (u = 224 | t.channel) !== n && e.writeUInt8(u);
                            var h = 8192 + t.value,
                                p = 127 & h,
                                d = h >> 7 & 127;
                            e.writeUInt8(p), e.writeUInt8(d);
                            break;
                        default:
                            throw "Unrecognized event type: " + r
                    }
                    return u
                }

                function s() {
                    this.buffer = []
                }
                s.prototype.writeUInt8 = function(e) {
                    this.buffer.push(255 & e)
                }, s.prototype.writeInt8 = s.prototype.writeUInt8, s.prototype.writeUInt16 = function(e) {
                    var t = e >> 8 & 255,
                        n = 255 & e;
                    this.writeUInt8(t), this.writeUInt8(n)
                }, s.prototype.writeInt16 = s.prototype.writeUInt16, s.prototype.writeUInt24 = function(e) {
                    var t = e >> 16 & 255,
                        n = e >> 8 & 255,
                        s = 255 & e;
                    this.writeUInt8(t), this.writeUInt8(n), this.writeUInt8(s)
                }, s.prototype.writeInt24 = s.prototype.writeUInt24, s.prototype.writeUInt32 = function(e) {
                    var t = e >> 24 & 255,
                        n = e >> 16 & 255,
                        s = e >> 8 & 255,
                        r = 255 & e;
                    this.writeUInt8(t), this.writeUInt8(n), this.writeUInt8(s), this.writeUInt8(r)
                }, s.prototype.writeInt32 = s.prototype.writeUInt32, s.prototype.writeBytes = function(e) {
                    this.buffer = this.buffer.concat(Array.prototype.slice.call(e, 0))
                }, s.prototype.writeString = function(e) {
                    var t, n = e.length,
                        s = [];
                    for (t = 0; t < n; t++) s.push(e.codePointAt(t));
                    this.writeBytes(s)
                }, s.prototype.writeVarInt = function(e) {
                    if (e < 0) throw "Cannot write negative variable-length integer";
                    if (e <= 127) this.writeUInt8(e);
                    else {
                        var t = e,
                            n = [];
                        for (n.push(127 & t), t >>= 7; t;) {
                            var s = 127 & t | 128;
                            n.push(s), t >>= 7
                        }
                        this.writeBytes(n.reverse())
                    }
                }, s.prototype.writeChunk = function(e, t) {
                    this.writeString(e), this.writeUInt32(t.length), this.writeBytes(t)
                }, e.exports = function(e, n) {
                    if ("object" != typeof e) throw "Invalid MIDI data";
                    n = n || {};
                    var r, a = e.header || {},
                        i = e.tracks || [],
                        o = i.length,
                        u = new s;
                    for (function(e, t, n) {
                            var r = null == t.format ? 1 : t.format,
                                a = 128;
                            t.timeDivision ? a = t.timeDivision : t.ticksPerFrame && t.framesPerSecond ? a = -(255 & t.framesPerSecond) << 8 | 255 & t.ticksPerFrame : t.ticksPerBeat && (a = 32767 & t.ticksPerBeat);
                            var i = new s;
                            i.writeUInt16(r), i.writeUInt16(n), i.writeUInt16(a), e.writeChunk("MThd", i.buffer)
                        }(u, a, o), r = 0; r < o; r++) t(u, i[r], n);
                    return u.buffer
                }
            },
            391: (e, t, n) => {
                var s = n(180),
                    r = n(181),
                    a = n(31),
                    i = n(67),
                    o = n(833),
                    u = n(717),
                    l = n(801);
                l.alea = s, l.xor128 = r, l.xorwow = a, l.xorshift7 = i, l.xor4096 = o, l.tychei = u, e.exports = l
            },
            180: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = function() {
                                var e = 4022871197,
                                    t = function(t) {
                                        t = t.toString();
                                        for (var n = 0; n < t.length; n++) {
                                            var s = .02519603282416938 * (e += t.charCodeAt(n));
                                            s -= e = s >>> 0, e = (s *= e) >>> 0, e += 4294967296 * (s -= e)
                                        }
                                        return 2.3283064365386963e-10 * (e >>> 0)
                                    };
                                return t
                            }();
                        t.next = function() {
                            var e = 2091639 * t.s0 + 2.3283064365386963e-10 * t.c;
                            return t.s0 = t.s1, t.s1 = t.s2, t.s2 = e - (t.c = 0 | e)
                        }, t.c = 1, t.s0 = n(" "), t.s1 = n(" "), t.s2 = n(" "), t.s0 -= n(e), t.s0 < 0 && (t.s0 += 1), t.s1 -= n(e), t.s1 < 0 && (t.s1 += 1), t.s2 -= n(e), t.s2 < 0 && (t.s2 += 1), n = null
                    }

                    function i(e, t) {
                        return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = n.next;
                        return r.int32 = function() {
                            return 4294967296 * n.next() | 0
                        }, r.double = function() {
                            return r() + 11102230246251565e-32 * (2097152 * r() | 0)
                        }, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.alea = o
                }(0, e = n.nmd(e), n.amdD)
            },
            717: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.next = function() {
                            var e = t.b,
                                n = t.c,
                                s = t.d,
                                r = t.a;
                            return e = e << 25 ^ e >>> 7 ^ n, n = n - s | 0, s = s << 24 ^ s >>> 8 ^ r, r = r - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - s | 0, t.d = s << 16 ^ n >>> 16 ^ r, t.a = r - e | 0
                        }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;
                        for (var s = 0; s < n.length + 20; s++) t.b ^= 0 | n.charCodeAt(s), t.next()
                    }

                    function i(e, t) {
                        return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.tychei = o
                }(0, e = n.nmd(e), n.amdD)
            },
            181: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function() {
                            var e = t.x ^ t.x << 11;
                            return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8
                        }, e === (0 | e) ? t.x = e : n += e;
                        for (var s = 0; s < n.length + 64; s++) t.x ^= 0 | n.charCodeAt(s), t.next()
                    }

                    function i(e, t) {
                        return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xor128 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            833: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this;
                        t.next = function() {
                                var e, n, s = t.w,
                                    r = t.X,
                                    a = t.i;
                                return t.w = s = s + 1640531527 | 0, n = r[a + 34 & 127], e = r[a = a + 1 & 127], n ^= n << 13, e ^= e << 17, n ^= n >>> 15, e ^= e >>> 12, n = r[a] = n ^ e, t.i = a, n + (s ^ s >>> 16) | 0
                            },
                            function(e, t) {
                                var n, s, r, a, i, o = [],
                                    u = 128;
                                for (t === (0 | t) ? (s = t, t = null) : (t += "\0", s = 0, u = Math.max(u, t.length)), r = 0, a = -32; a < u; ++a) t && (s ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = s), s ^= s << 10, s ^= s >>> 15, s ^= s << 4, s ^= s >>> 13, a >= 0 && (i = i + 1640531527 | 0, r = 0 == (n = o[127 & a] ^= s + i) ? r + 1 : 0);
                                for (r >= 128 && (o[127 & (t && t.length || 0)] = -1), r = 127, a = 512; a > 0; --a) s = o[r + 34 & 127], n = o[r = r + 1 & 127], s ^= s << 13, n ^= n << 17, s ^= s >>> 15, n ^= n >>> 12, o[r] = s ^ n;
                                e.w = i, e.X = o, e.i = r
                            }(t, e)
                    }

                    function i(e, t) {
                        return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t
                    }

                    function o(e, t) {
                        null == e && (e = +new Date);
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && (s.X && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xor4096 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            67: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this;
                        t.next = function() {
                                var e, n, s = t.x,
                                    r = t.i;
                                return e = s[r], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = s[r + 1 & 7]) ^ e >>> 10, n ^= (e = s[r + 3 & 7]) ^ e >>> 3, n ^= (e = s[r + 4 & 7]) ^ e << 7, e = s[r + 7 & 7], n ^= (e ^= e << 13) ^ e << 9, s[r] = n, t.i = r + 1 & 7, n
                            },
                            function(e, t) {
                                var n, s = [];
                                if (t === (0 | t)) s[0] = t;
                                else
                                    for (t = "" + t, n = 0; n < t.length; ++n) s[7 & n] = s[7 & n] << 15 ^ t.charCodeAt(n) + s[n + 1 & 7] << 13;
                                for (; s.length < 8;) s.push(0);
                                for (n = 0; n < 8 && 0 === s[n]; ++n);
                                for (8 == n ? s[7] = -1 : s[n], e.x = s, e.i = 0, n = 256; n > 0; --n) e.next()
                            }(t, e)
                    }

                    function i(e, t) {
                        return t.x = e.x.slice(), t.i = e.i, t
                    }

                    function o(e, t) {
                        null == e && (e = +new Date);
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && (s.x && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xorshift7 = o
                }(0, e = n.nmd(e), n.amdD)
            },
            31: function(e, t, n) {
                var s;
                ! function(e, r) {
                    function a(e) {
                        var t = this,
                            n = "";
                        t.next = function() {
                            var e = t.x ^ t.x >>> 2;
                            return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0
                        }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;
                        for (var s = 0; s < n.length + 64; s++) t.x ^= 0 | n.charCodeAt(s), s == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next()
                    }

                    function i(e, t) {
                        return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t
                    }

                    function o(e, t) {
                        var n = new a(e),
                            s = t && t.state,
                            r = function() {
                                return (n.next() >>> 0) / 4294967296
                            };
                        return r.double = function() {
                            do {
                                var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                            } while (0 === e);
                            return e
                        }, r.int32 = n.next, r.quick = r, s && ("object" == typeof s && i(s, n), r.state = function() {
                            return i(n, {})
                        }), r
                    }
                    r && r.exports ? r.exports = o : n.amdD && n.amdO ? void 0 === (s = function() {
                        return o
                    }.call(t, n, t, r)) || (r.exports = s) : this.xorwow = o
                }(0, e = n.nmd(e), n.amdD)
            },
            801: (e, t, n) => {
                var s;
                ! function(r, a) {
                    var i, /*o = (0, eval)("this"),*/
                        u = 256,
                        l = "random",
                        c = a.pow(u, 6),
                        h = a.pow(2, 52),
                        p = 2 * h,
                        d = 255;

                    function f(e, t, n) {
                        var s = [],
                            d = b(y((t = 1 == t ? {
                                entropy: !0
                            } : t || {}).entropy ? [e, x(r)] : null == e ? function() {
                                try {
                                    var e;
                                    return i && (e = i.randomBytes) ? e = e(u) : (e = new Uint8Array(u), (o.crypto || o.msCrypto).getRandomValues(e)), x(e)
                                } catch (e) {
                                    var t = o.navigator,
                                        n = t && t.plugins;
                                    return [+new Date, o, n, o.screen, x(r)]
                                }
                            }() : e, 3), s),
                            f = new m(s),
                            w = function() {
                                for (var e = f.g(6), t = c, n = 0; e < h;) e = (e + n) * u, t *= u, n = f.g(1);
                                for (; e >= p;) e /= 2, t /= 2, n >>>= 1;
                                return (e + n) / t
                            };
                        return w.int32 = function() {
                            return 0 | f.g(4)
                        }, w.quick = function() {
                            return f.g(4) / 4294967296
                        }, w.double = w, b(x(f.S), r), (t.pass || n || function(e, t, n, s) {
                            return s && (s.S && g(s, f), e.state = function() {
                                return g(f, {})
                            }), n ? (a[l] = e, t) : e
                        })(w, d, "global" in t ? t.global : this == a, t.state)
                    }

                    function m(e) {
                        var t, n = e.length,
                            s = this,
                            r = 0,
                            a = s.i = s.j = 0,
                            i = s.S = [];
                        for (n || (e = [n++]); r < u;) i[r] = r++;
                        for (r = 0; r < u; r++) i[r] = i[a = d & a + e[r % n] + (t = i[r])], i[a] = t;
                        (s.g = function(e) {
                            for (var t, n = 0, r = s.i, a = s.j, i = s.S; e--;) t = i[r = d & r + 1], n = n * u + i[d & (i[r] = i[a = d & a + t]) + (i[a] = t)];
                            return s.i = r, s.j = a, n
                        })(u)
                    }

                    function g(e, t) {
                        return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t
                    }

                    function y(e, t) {
                        var n, s = [],
                            r = typeof e;
                        if (t && "object" == r)
                            for (n in e) try {
                                s.push(y(e[n], t - 1))
                            } catch (e) {}
                        return s.length ? s : "string" == r ? e : e + "\0"
                    }

                    function b(e, t) {
                        for (var n, s = e + "", r = 0; r < s.length;) t[d & r] = d & (n ^= 19 * t[d & r]) + s.charCodeAt(r++);
                        return x(t)
                    }

                    function x(e) {
                        return String.fromCharCode.apply(0, e)
                    }
                    if (a["seed" + l] = f, b(a.random(), r), e.exports) {
                        e.exports = f;
                        try {
                            i = n(234)
                        } catch (e) {}
                    } else void 0 === (s = function() {
                        return f
                    }.call(t, n, t, e)) || (e.exports = s)
                }([], Math)
            },
            351: () => {},
            817: () => {},
            590: () => {},
            857: () => {},
            530: () => {},
            108: () => {},
            551: () => {},
            234: () => {}
        },
        t = {};

    function n(s) {
        var r = t[s];
        if (void 0 !== r) return r.exports;
        var a = t[s] = {
            id: s,
            loaded: !1,
            exports: {}
        };
        return e[s].call(a.exports, a, a.exports, n), a.loaded = !0, a.exports
    }
    n.amdD = function() {
        throw new Error("define cannot be used indirect")
    }, n.amdO = {}, n.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return n.d(t, {
            a: t
        }), t
    }, n.d = (e, t) => {
        for (var s in t) n.o(t, s) && !n.o(e, s) && Object.defineProperty(e, s, {
            enumerable: !0,
            get: t[s]
        })
    }, n.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window) return window
        }
    }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, n.nmd = e => (e.paths = [], e.children || (e.children = []), e), (() => {
        "use strict";
        var e = {};
        n.r(e), n.d(e, {
            assertParamsValid: () => Xa,
            computeFlatOffset: () => ui,
            computeOutShape: () => Ja,
            getNormalizedAxes: () => ti,
            isSliceContinous: () => oi,
            maskToAxes: () => Ya,
            parseSliceParams: () => li,
            sliceInfo: () => ci,
            startForAxis: () => ai,
            startIndicesWithElidedDims: () => ni,
            stopForAxis: () => ii,
            stopIndicesWithElidedDims: () => si,
            stridesForAxis: () => ri,
            stridesWithElidedDims: () => Za
        });
        var t = {};
        n.r(t), n.d(t, {
            collectGatherOpShapeInfo: () => dh,
            computeOutShape: () => ph,
            segOpComputeOptimalWindowSize: () => hh
        });
        var s = {};
        n.r(s), n.d(s, {
            ERF_A1: () => Ec,
            ERF_A2: () => Ac,
            ERF_A3: () => Rc,
            ERF_A4: () => Fc,
            ERF_A5: () => Dc,
            ERF_P: () => Cc,
            PARALLELIZE_THRESHOLD: () => fc,
            SELU_SCALE: () => $c,
            SELU_SCALEALPHA: () => Tc,
            applyActivation: () => Hu,
            assertAndGetBroadcastShape: () => Ga,
            assertAxesAreInnerMostDims: () => Vo,
            assertParamsConsistent: () => pc,
            assignToTypedArray: () => Bc,
            axesAreInnerMostDims: () => Bo,
            calculateShapes: () => Sc,
            checkEinsumDimSizes: () => Kc,
            checkPadOnDimRoundingMode: () => Wi,
            combineLocations: () => Po,
            complexWithEvenIndex: () => Mc,
            complexWithOddIndex: () => Lc,
            computeConv2DInfo: () => Fi,
            computeConv3DInfo: () => Di,
            computeDefaultPad: () => _i,
            computeDilation2DInfo: () => Ei,
            computeOptimalWindowSize: () => mc,
            computeOutAndReduceShapes: () => Uo,
            computeOutShape: () => dc,
            computePool2DInfo: () => Ai,
            computePool3DInfo: () => Ri,
            convertConv2DDataFormat: () => Ui,
            decodeEinsumEquation: () => jc,
            eitherStridesOrDilationsAreOne: () => Pi,
            expandShapeToKeepDim: () => Wo,
            exponent: () => Uc,
            exponents: () => Pc,
            fromStringArrayToUint8: () => mh,
            fromUint8ToStringArray: () => fh,
            getAxesPermutation: () => Go,
            getBroadcastDims: () => Wa,
            getComplexWithIndex: () => zc,
            getEinsumComputePath: () => Xc,
            getEinsumPermutation: () => qc,
            getFusedBiasGradient: () => Gu,
            getFusedDyActivation: () => Vu,
            getImageCenter: () => gc,
            getInnerMostAxes: () => jo,
            getPermuted: () => bc,
            getReductionAxes: () => Va,
            getReshaped: () => yc,
            getReshapedPermuted: () => xc,
            getSliceBeginCoords: () => wc,
            getSliceSize: () => kc,
            getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => Qc,
            getSparseFillEmptyRowsNegativeIndexErrorMessage: () => eh,
            getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => th,
            getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => rh,
            getSparseReshapeInputOutputMismatchErrorMessage: () => ih,
            getSparseReshapeInputOutputMultipleErrorMessage: () => ah,
            getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => nh,
            getSparseReshapeNegativeOutputDimErrorMessage: () => sh,
            getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => ch,
            getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => oh,
            getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => uh,
            getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => lh,
            getUndoAxesPermutation: () => Ho,
            isIdentityPermutation: () => Yc,
            log: () => Ns,
            mergeRealAndImagArrays: () => _c,
            prepareAndValidate: () => vc,
            prepareSplitSize: () => Zc,
            segment_util: () => t,
            shouldFuse: () => ju,
            slice_util: () => e,
            splitRealAndImagArrays: () => Oc,
            tupleValuesAreOne: () => Bi,
            upcastType: () => xr,
            validateInput: () => Nc,
            validateUpdateShape: () => Ic,
            warn: () => Is
        });
        var r = {};
        n.r(r), n.d(r, {
            json: () => Hx
        });
        var a = {};
        n.r(a), n.d(a, {
            json: () => jx
        });
        var i = {};
        n.r(i), n.d(i, {
            json: () => qx
        });
        var o = {};
        n.r(o), n.d(o, {
            json: () => Kx
        });
        var u = {};
        n.r(u), n.d(u, {
            json: () => Xx
        });
        var l = {};
        n.r(l), n.d(l, {
            json: () => Yx
        });
        var c = {};
        n.r(c), n.d(c, {
            json: () => Jx
        });
        var h = {};
        n.r(h), n.d(h, {
            json: () => Zx
        });
        var p = {};
        n.r(p), n.d(p, {
            json: () => Qx
        });
        var d = {};
        n.r(d), n.d(d, {
            json: () => ew
        });
        var f = {};
        n.r(f), n.d(f, {
            json: () => tw
        });
        var m = {};
        n.r(m), n.d(m, {
            json: () => nw
        });
        var g = {};
        n.r(g), n.d(g, {
            json: () => sw
        });
        var y = {};
        n.r(y), n.d(y, {
            json: () => rw
        });
        var b = {};
        n.r(b), n.d(b, {
            json: () => aw
        });
        var x = {};
        n.r(x), n.d(x, {
            json: () => iw
        });
        var w = {};
        n.r(w), n.d(w, {
            json: () => ow
        });
        var k = {};
        n.r(k), n.d(k, {
            json: () => uw
        });
        var v = {};
        n.r(v), n.d(v, {
            json: () => lw
        });
        var I = {};
        n.r(I), n.d(I, {
            mx: () => Nv,
            XI: () => gI,
            Nk: () => yI,
            YG: () => wI,
            hH: () => TI,
            z3: () => lN,
            sG: () => wN,
            uM: () => SN,
            vS: () => WN,
            qB: () => YN,
            GG: () => ZN,
            lg: () => sS,
            rq: () => eS,
            cu: () => gS,
            WR: () => dS,
            GE: () => xS,
            px: () => kS,
            jC: () => MS,
            He: () => BS,
            hE: () => XS,
            BF: () => tN,
            Dk: () => iT,
            cl: () => fT,
            _B: () => $T,
            qy: () => ET,
            Zy: () => UT,
            bu: () => GT,
            zv: () => hv,
            dH: () => Dv,
            HS: () => pI,
            yH: () => c$,
            l3: () => p$,
            z9: () => f$,
            x6: () => x$,
            eW: () => C$,
            GK: () => R$,
            SP: () => _$,
            f6: () => M$,
            dl: () => RN,
            Dw: () => U$,
            xT: () => H$,
            _X: () => Pv,
            wz: () => Z$
        });
        class N {
            constructor(e, t) {
                this.backend = e, this.dataMover = t, this.data = new WeakMap, this.dataIdsCount = 0
            }
            get(e) {
                return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e)
            }
            set(e, t) {
                this.dataIdsCount++, this.data.set(e, t)
            }
            has(e) {
                return this.data.has(e)
            }
            delete(e) {
                return this.dataIdsCount--, this.data.delete(e)
            }
            numDataIds() {
                return this.dataIdsCount
            }
        }
        class S {
            refCount(e) {
                return T("refCount")
            }
            incRef(e) {
                return T("incRef")
            }
            timerAvailable() {
                return !0
            }
            time(e) {
                return T("time")
            }
            read(e) {
                return T("read")
            }
            readSync(e) {
                return T("readSync")
            }
            readToGPU(e, t) {
                return T("readToGPU")
            }
            numDataIds() {
                return T("numDataIds")
            }
            disposeData(e, t) {
                return T("disposeData")
            }
            write(e, t, n) {
                return T("write")
            }
            move(e, t, n, s, r) {
                return T("move")
            }
            memory() {
                return T("memory")
            }
            floatPrecision() {
                return T("floatPrecision")
            }
            epsilon() {
                return 32 === this.floatPrecision() ? 1e-7 : 1e-4
            }
            dispose() {
                return T("dispose")
            }
        }

        function T(e) {
            throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)
        }

        function $(e) {
            let t = e.length,
                n = 0;
            for (; t > 0;) n = Math.random() * t | 0, t--, A(e, t, n)
        }

        function C(e, t, n) {
            return Math.max(e, Math.min(t, n))
        }

        function E(e) {
            return e % 2 == 0 ? e : e + 1
        }

        function A(e, t, n) {
            const s = e[t];
            e[t] = e[n], e[n] = s
        }

        function R(e, t) {
            if (!e) throw new Error("string" == typeof t ? t : t())
        }

        function F(e, t, n = "") {
            R(M(e, t), (() => n + ` Shapes ${e} and ${t} must match`))
        }

        function D(e) {
            R(null != e, (() => "The input to the tensor constructor must be a non-null value."))
        }

        function _(e, t = [], n = !1) {
            if (null == t && (t = []), Array.isArray(e) || q(e) && !n)
                for (let s = 0; s < e.length; ++s) _(e[s], t, n);
            else t.push(e);
            return t
        }

        function O(e) {
            if (0 === e.length) return 1;
            let t = e[0];
            for (let n = 1; n < e.length; n++) t *= e[n];
            return t
        }

        function M(e, t) {
            if (e === t) return !0;
            if (null == e || null == t) return !1;
            if (e.length !== t.length) return !1;
            for (let n = 0; n < e.length; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function L(e) {
            return e % 1 == 0
        }

        function z(e) {
            const t = Math.ceil(Math.sqrt(e));
            return [t, Math.ceil(e / t)]
        }

        function B(e, t) {
            return t <= e.length ? e : e + " ".repeat(t - e.length)
        }

        function P(e, t = e => 0, n) {
            return new Promise(((s, r) => {
                let a = 0;
                const i = () => {
                    if (e()) return void s();
                    a++;
                    const o = t(a);
                    null != n && a >= n ? r() : setTimeout(i, o)
                };
                i()
            }))
        }

        function U(e, t) {
            let n = 1,
                s = -1;
            for (let t = 0; t < e.length; ++t)
                if (e[t] >= 0) n *= e[t];
                else if (-1 === e[t]) {
                if (-1 !== s) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${t}`);
                s = t
            } else if (e[t] < 0) throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);
            if (-1 === s) {
                if (t > 0 && t !== n) throw Error(`Size(${t}) must match the product of shape ${e}`);
                return e
            }
            if (0 === n) throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);
            if (t % n != 0) throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);
            const r = e.slice();
            return r[s] = t / n, r
        }

        function W(e, t) {
            const n = t.length;
            return R((e = null == e ? t.map(((e, t) => t)) : [].concat(e)).every((e => e >= -n && e < n)), (() => `All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)), R(e.every((e => L(e))), (() => `All values in axis param must be integers but got axis ${e}`)), e.map((e => e < 0 ? n + e : e))
        }

        function V(e, t) {
            const n = [],
                s = [],
                r = null != t && Array.isArray(t) && 0 === t.length,
                a = null == t || r ? null : W(t, e).sort();
            let i = 0;
            for (let t = 0; t < e.length; ++t) {
                if (null != a) {
                    if (a[i] === t && 1 !== e[t]) throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);
                    (null == a[i] || a[i] > t) && 1 === e[t] && (n.push(e[t]), s.push(t)), a[i] <= t && i++
                }
                1 !== e[t] && (n.push(e[t]), s.push(t))
            }
            return {
                newShape: n,
                keptDims: s
            }
        }

        function G(e, t) {
            let n = null;
            if (null == e || "float32" === e) n = new Float32Array(t);
            else if ("int32" === e) n = new Int32Array(t);
            else {
                if ("bool" !== e) throw new Error(`Unknown data type ${e}`);
                n = new Uint8Array(t)
            }
            return n
        }

        function H(e, t) {
            let n = null;
            if (null == e || "float32" === e) n = new Float32Array(t);
            else if ("int32" === e) n = new Int32Array(t);
            else if ("bool" === e) n = new Uint8Array(t);
            else {
                if ("string" !== e) throw new Error(`Unknown data type ${e}`);
                n = new Array(t)
            }
            return n
        }

        function j(e, t) {
            return "complex64" !== t && (("float32" !== t || "complex64" === e) && (("int32" !== t || "float32" === e || "complex64" === e) && ("bool" !== t || "bool" !== e)))
        }

        function q(e) {
            return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray
        }

        function K(e) {
            if ("float32" === e || "int32" === e) return 4;
            if ("complex64" === e) return 8;
            if ("bool" === e) return 1;
            throw new Error(`Unknown dtype ${e}`)
        }

        function X(e) {
            return "string" == typeof e || e instanceof String
        }

        function Y(e) {
            return "number" == typeof e
        }

        function J(e) {
            return Array.isArray(e) ? J(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray ? "int32" : Y(e) ? "float32" : X(e) ? "string" : "boolean" == typeof e ? "bool" : "float32"
        }

        function Z(e) {
            return !!(e && e.constructor && e.call && e.apply)
        }

        function Q(e, t) {
            for (let n = t; n < e; ++n)
                if (e % n == 0) return n;
            return e
        }

        function ee(e) {
            const t = e.length;
            if (t < 2) return [];
            const n = new Array(t - 1);
            n[t - 2] = e[t - 1];
            for (let s = t - 3; s >= 0; --s) n[s] = n[s + 1] * e[s + 1];
            return n
        }

        function te(e, t, n, s = !1) {
            const r = new Array;
            if (1 === t.length) {
                const a = t[0] * (s ? 2 : 1);
                for (let t = 0; t < a; t++) r[t] = n[e + t]
            } else {
                const a = t[0],
                    i = t.slice(1),
                    o = i.reduce(((e, t) => e * t)) * (s ? 2 : 1);
                for (let t = 0; t < a; t++) r[t] = te(e + t * o, i, n, s)
            }
            return r
        }

        function ne(e, t, n = !1) {
            if (0 === e.length) return t[0];
            const s = e.reduce(((e, t) => e * t)) * (n ? 2 : 1);
            if (0 === s) return [];
            if (s !== t.length) throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);
            return te(0, e, t, n)
        }

        function se(e, t) {
            const n = re(e, t);
            for (let e = 0; e < n.length; e++) n[e] = 1;
            return n
        }

        function re(e, t) {
            if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
            if ("int32" === t) return new Int32Array(e);
            if ("bool" === t) return new Uint8Array(e);
            throw new Error(`Unknown data type ${t}`)
        }

        function ae(e, t) {
            const n = e.reduce(((e, t) => e * t), 1);
            if (null == t || "float32" === t) return ne(e, new Float32Array(n));
            if ("int32" === t) return ne(e, new Int32Array(n));
            if ("bool" === t) return ne(e, new Uint8Array(n));
            throw new Error(`Unknown data type ${t}`)
        }

        function ie(e) {
            e.forEach((t => {
                R(Number.isInteger(t) && t >= 0, (() => `Tensor must have a shape comprised of positive integers but got shape [${e}].`))
            }))
        }

        function oe(e, t, n) {
            if (0 === t) return 0;
            if (1 === t) return e[0];
            let s = e[e.length - 1];
            for (let t = 0; t < e.length - 1; ++t) s += n[t] * e[t];
            return s
        }

        function ue(e, t, n) {
            if (0 === t) return [];
            if (1 === t) return [e];
            const s = new Array(t);
            for (let t = 0; t < s.length - 1; ++t) s[t] = Math.floor(e / n[t]), e -= s[t] * n[t];
            return s[s.length - 1] = e, s
        }

        function le(e) {
            return e && e.then && "function" == typeof e.then
        }
        const ce = "tfjsflags";
        class he {
            constructor(e) {
                this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = pe, this.populateURLFlags()
            }
            setPlatform(e, t) {
                null != this.platform && (de().getBool("IS_TEST") || de().getBool("PROD") || console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)), this.platformName = e, this.platform = t
            }
            registerFlag(e, t, n) {
                if (this.flagRegistry[e] = {
                        evaluationFn: t,
                        setHook: n
                    }, null != this.urlFlags[e]) {
                    const t = this.urlFlags[e];
                    de().getBool("IS_TEST") || de().getBool("PROD") || console.warn(`Setting feature override from URL ${e}: ${t}.`), this.set(e, t)
                }
            }
            async getAsync(e) {
                return e in this.flags || (this.flags[e] = await this.evaluateFlag(e)), this.flags[e]
            }
            get(e) {
                if (e in this.flags) return this.flags[e];
                const t = this.evaluateFlag(e);
                if (le(t)) throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
                return this.flags[e] = t, this.flags[e]
            }
            getNumber(e) {
                return this.get(e)
            }
            getBool(e) {
                return this.get(e)
            }
            getFlags() {
                return this.flags
            }
            get features() {
                return this.flags
            }
            set(e, t) {
                if (null == this.flagRegistry[e]) throw new Error(`Cannot set flag ${e} as it has not been registered.`);
                this.flags[e] = t, null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t)
            }
            evaluateFlag(e) {
                if (null == this.flagRegistry[e]) throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
                return this.flagRegistry[e].evaluationFn()
            }
            setFlags(e) {
                this.flags = Object.assign({}, e)
            }
            reset() {
                this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
            }
            populateURLFlags() {
                if (void 0 === this.global || void 0 === this.global.location || void 0 === this.global.location.search) return;
                const e = this.getQueryParams(this.global.location.search);
                if (ce in e) {
                    e[ce].split(",").forEach((e => {
                        const [t, n] = e.split(":");
                        this.urlFlags[t] = function(e, t) {
                            if ("true" === (t = t.toLowerCase()) || "false" === t) return "true" === t;
                            if ("" + +t === t) return +t;
                            throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)
                        }(t, n)
                    }))
                }
            }
        }

        function pe(e) {
            const t = {};
            return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, ((e, ...n) => (function(e, t, n) {
                e[decodeURIComponent(t)] = decodeURIComponent(n || "")
            }(t, n[0], n[1]), n.join("=")))), t
        }

        function de() {
            return me
        }
        let fe, me = null;

        function ge() {
            if (null == fe) {
                let e;
                if ("undefined" != typeof window) e = window;
                else if (void 0 !== n.g) e = n.g;
                else if ("undefined" != typeof process) e = process;
                else {
                    if ("undefined" == typeof self) throw new Error("Could not find a global object");
                    e = self
                }
                fe = e
            }
            return fe
        }

        function ye(e, t) {
            const n = function() {
                const e = ge();
                return null == e._tfGlobals && (e._tfGlobals = new Map), e._tfGlobals
            }();
            if (n.has(e)) return n.get(e);
            {
                const s = t();
                return n.set(e, s), n.get(e)
            }
        }
        const be = "Abs",
            xe = "Acos",
            we = "Acosh",
            ke = "Add",
            ve = "AddN",
            Ie = "All",
            Ne = "Any",
            Se = "ArgMax",
            Te = "ArgMin",
            $e = "Asin",
            Ce = "Asinh",
            Ee = "Atan",
            Ae = "Atanh",
            Re = "Atan2",
            Fe = "AvgPool",
            De = "AvgPoolGrad",
            _e = "AvgPool3D",
            Oe = "AvgPool3DGrad",
            Me = "BatchMatMul",
            Le = "BatchToSpaceND",
            ze = "Bincount",
            Be = "BroadcastArgs",
            Pe = "Cast",
            Ue = "Ceil",
            We = "ClipByValue",
            Ve = "Complex",
            Ge = "ComplexAbs",
            He = "Concat",
            je = "Conv2D",
            qe = "Conv2DBackpropFilter",
            Ke = "Conv2DBackpropInput",
            Xe = "Conv3D",
            Ye = "Conv3DBackpropFilterV2",
            Je = "Conv3DBackpropInputV2",
            Ze = "Cos",
            Qe = "Cosh",
            et = "Cumprod",
            tt = "Cumsum",
            nt = "CropAndResize",
            st = "DenseBincount",
            rt = "DepthToSpace",
            at = "DepthwiseConv2dNative",
            it = "DepthwiseConv2dNativeBackpropFilter",
            ot = "DepthwiseConv2dNativeBackpropInput",
            ut = "Diag",
            lt = "Dilation2D",
            ct = "Dilation2DBackpropInput",
            ht = "Dilation2DBackpropFilter",
            pt = "RealDiv",
            dt = "Einsum",
            ft = "Elu",
            mt = "EluGrad",
            gt = "Erf",
            yt = "Equal",
            bt = "Exp",
            xt = "ExpandDims",
            wt = "Expm1",
            kt = "FFT",
            vt = "Fill",
            It = "FlipLeftRight",
            Nt = "Floor",
            St = "FloorDiv",
            Tt = "FusedBatchNorm",
            $t = "GatherV2",
            Ct = "GatherNd",
            Et = "Greater",
            At = "GreaterEqual",
            Rt = "Identity",
            Ft = "IFFT",
            Dt = "Imag",
            _t = "IsFinite",
            Ot = "IsInf",
            Mt = "IsNan",
            Lt = "LeakyRelu",
            zt = "Less",
            Bt = "LessEqual",
            Pt = "LinSpace",
            Ut = "Log",
            Wt = "Log1p",
            Vt = "LogicalAnd",
            Gt = "LogicalNot",
            Ht = "LogicalOr",
            jt = "LRN",
            qt = "LRNGrad",
            Kt = "Max",
            Xt = "Maximum",
            Yt = "MaxPool",
            Jt = "MaxPoolGrad",
            Zt = "MaxPool3D",
            Qt = "MaxPool3DGrad",
            en = "MaxPoolWithArgmax",
            tn = "Mean",
            nn = "Min",
            sn = "Minimum",
            rn = "MirrorPad",
            an = "Mod",
            on = "Multinomial",
            un = "Multiply",
            ln = "Neg",
            cn = "NotEqual",
            hn = "NonMaxSuppressionV3",
            pn = "NonMaxSuppressionV4",
            dn = "NonMaxSuppressionV5",
            fn = "OnesLike",
            mn = "OneHot",
            gn = "Pack",
            yn = "PadV2",
            bn = "Pow",
            xn = "Prelu",
            wn = "Prod",
            kn = "Range",
            vn = "Real",
            In = "Reciprocal",
            Nn = "Relu",
            Sn = "Reshape",
            Tn = "ResizeNearestNeighbor",
            $n = "ResizeNearestNeighborGrad",
            Cn = "ResizeBilinear",
            En = "ResizeBilinearGrad",
            An = "Relu6",
            Rn = "Reverse",
            Fn = "Round",
            Dn = "Rsqrt",
            _n = "ScatterNd",
            On = "SearchSorted",
            Mn = "Select",
            Ln = "Selu",
            zn = "Slice",
            Bn = "Sin",
            Pn = "Sinh",
            Un = "Sign",
            Wn = "Sigmoid",
            Vn = "Softplus",
            Gn = "Sqrt",
            Hn = "Sum",
            jn = "SpaceToBatchND",
            qn = "SplitV",
            Kn = "Softmax",
            Xn = "SparseFillEmptyRows",
            Yn = "SparseReshape",
            Jn = "SparseSegmentMean",
            Zn = "SparseSegmentSum",
            Qn = "SparseToDense",
            es = "SquaredDifference",
            ts = "Square",
            ns = "StridedSlice",
            ss = "StringNGrams",
            rs = "StringSplit",
            as = "StringToHashBucketFast",
            is = "Sub",
            os = "Tan",
            us = "Tanh",
            ls = "Tile",
            cs = "TopK",
            hs = "Transform",
            ps = "Transpose",
            ds = "Unique",
            fs = "Unpack",
            ms = "UnsortedSegmentSum",
            gs = "ZerosLike",
            ys = "Step",
            bs = "FromPixels",
            xs = "RotateWithOffset",
            ws = "_FusedMatMul",
            ks = "FusedConv2D",
            vs = "FusedDepthwiseConv2D";

        function Is(...e) {
            de().getBool("IS_TEST") || de().getBool("PROD") || console.warn(...e)
        }

        function Ns(...e) {
            de().getBool("IS_TEST") || de().getBool("PROD") || console.log(...e)
        }
        const Ss = ye("kernelRegistry", (() => new Map)),
            Ts = ye("gradRegistry", (() => new Map));

        function $s(e, t) {
            const n = Fs(e, t);
            return Ss.get(n)
        }

        function Cs(e) {
            return Ts.get(e)
        }

        function Es(e) {
            const t = Ss.entries(),
                n = [];
            for (;;) {
                const {
                    done: s,
                    value: r
                } = t.next();
                if (s) break;
                const [a, i] = r, [o] = a.split("_");
                o === e && n.push(i)
            }
            return n
        }

        function As(e) {
            const {
                kernelName: t,
                backendName: n
            } = e, s = Fs(t, n);
            Ss.has(s) && Is(`The kernel '${t}' for backend '${n}' is already registered`), Ss.set(s, e)
        }

        function Rs(e) {
            const {
                kernelName: t
            } = e;
            Ts.has(t) && de().getBool("DEBUG") && Is(`Overriding the gradient for '${t}'`), Ts.set(t, e)
        }

        function Fs(e, t) {
            return `${t}_${e}`
        }
        var Ds = n(570);
        const _s = n.n(Ds)() || Ds;

        function Os(e) {
            return _s.fromString(e, !0, 16)
        }
        const Ms = Os("c3a5c85c97cb3127"),
            Ls = Os("b492b66fbe98f273"),
            zs = Os("9ae16a3b2f90404f");

        function Bs(e) {
            return e.xor(e.shru(47))
        }

        function Ps(e, t, n) {
            const s = e.slice(t, t + n);
            return _s.fromBytes(Array.from(s), !0, !0)
        }

        function Us(e, t) {
            return Ps(e, t, 8)
        }

        function Ws(e, t) {
            return Ps(e, t, 4)
        }

        function Vs(e, t) {
            return 0 === t ? e : e.shru(t).or(e.shl(64 - t))
        }

        function Gs(e, t, n = Os("9ddfea08eb382d69")) {
            let s = e.xor(t).mul(n);
            s = s.xor(s.shru(47));
            let r = t.xor(s).mul(n);
            return r = r.xor(r.shru(47)), r = r.mul(n), r
        }

        function Hs(e, t, n, s) {
            return function(e, t, n, s, r, a) {
                r = r.add(e), a = Vs(a.add(r).add(s), 21);
                const i = r;
                return r = (r = r.add(t)).add(n), a = a.add(Vs(r, 44)), [r.add(s), a.add(i)]
            }(Us(e, t), Us(e, t + 8), Us(e, t + 16), Us(e, t + 24), n, s)
        }

        function js(e, t = e.length) {
            const n = _s.fromNumber(81, !0);
            if (t <= 32) return t <= 16 ? function(e, t = e.length) {
                if (t >= 8) {
                    const n = zs.add(2 * t),
                        s = Us(e, 0).add(zs),
                        r = Us(e, t - 8);
                    return Gs(Vs(r, 37).mul(n).add(s), Vs(s, 25).add(r).mul(n), n)
                }
                if (t >= 4) {
                    const n = zs.add(2 * t);
                    return Gs(Ws(e, 0).shl(3).add(t), Ws(e, t - 4), n)
                }
                if (t > 0) {
                    const n = e[0] + (e[t >> 1] << 8),
                        s = t + (e[t - 1] << 2);
                    return Bs(zs.mul(n).xor(Ms.mul(s))).mul(zs)
                }
                return zs
            }(e, t) : function(e, t = e.length) {
                const n = zs.add(2 * t),
                    s = Us(e, 0).mul(Ls),
                    r = Us(e, 8),
                    a = Us(e, t - 8).mul(n),
                    i = Us(e, t - 16).mul(zs);
                return Gs(Vs(s.add(r), 43).add(Vs(a, 30)).add(i), s.add(Vs(r.add(zs), 18)).add(a), n)
            }(e, t);
            if (t <= 64) return function(e, t = e.length) {
                const n = zs.add(2 * t),
                    s = Us(e, 0).mul(zs),
                    r = Us(e, 8),
                    a = Us(e, t - 8).mul(n),
                    i = Us(e, t - 16).mul(zs),
                    o = Vs(s.add(r), 43).add(Vs(a, 30)).add(i),
                    u = Gs(o, s.add(Vs(r.add(zs), 18)).add(a), n),
                    l = Us(e, 16).mul(n),
                    c = Us(e, 24),
                    h = o.add(Us(e, t - 32)).mul(n),
                    p = u.add(Us(e, t - 24)).mul(n);
                return Gs(Vs(l.add(c), 43).add(Vs(h, 30)).add(p), l.add(Vs(c.add(s), 18)).add(h), n)
            }(e, t);
            let s = n,
                r = n.mul(Ls).add(113),
                a = Bs(r.mul(zs).add(113)).mul(zs),
                i = [_s.UZERO, _s.UZERO],
                o = [_s.UZERO, _s.UZERO];
            s = s.mul(zs).add(Us(e, 0));
            let u = 0;
            const l = 64 * (t - 1 >> 6),
                c = l + (t - 1 & 63) - 63;
            do {
                s = Vs(s.add(r).add(i[0]).add(Us(e, u + 8)), 37).mul(Ls), r = Vs(r.add(i[1]).add(Us(e, u + 48)), 42).mul(Ls), s = s.xor(o[1]), r = r.add(i[0]).add(Us(e, u + 40)), a = Vs(a.add(o[0]), 33).mul(Ls), i = Hs(e, u, i[1].mul(Ls), s.add(o[0])), o = Hs(e, u + 32, a.add(o[1]), r.add(Us(e, u + 16))), [a, s] = [s, a], u += 64
            } while (u !== l);
            const h = Ls.add(a.and(255).shl(1));
            return u = c, o[0] = o[0].add(t - 1 & 63), i[0] = i[0].add(o[0]), o[0] = o[0].add(i[0]), s = Vs(s.add(r).add(i[0]).add(Us(e, u + 8)), 37).mul(h), r = Vs(r.add(i[1]).add(Us(e, u + 48)), 42).mul(h), s = s.xor(o[1].mul(9)), r = r.add(i[0].mul(9).add(Us(e, u + 40))), a = Vs(a.add(o[0]), 33).mul(h), i = Hs(e, u, i[1].mul(h), s.add(o[0])), o = Hs(e, u + 32, a.add(o[1]), r.add(Us(e, u + 16))), [a, s] = [s, a], Gs(Gs(i[0], o[0], h).add(Bs(r).mul(Ms)).add(a), Gs(i[1], o[1], h).add(s), h)
        }

        function qs(e, t) {
            return "string" === t ? Ys(e) : Ks([e], t)
        }

        function Ks(e, t) {
            if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
            if (Array.isArray(e) && (e = _(e)), de().getBool("DEBUG") && function(e, t) {
                    for (let n = 0; n < e.length; n++) {
                        const s = e[n];
                        if (isNaN(s) || !isFinite(s)) throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)
                    }
                }(e, t), function(e, t) {
                    return e instanceof Float32Array && "float32" === t || e instanceof Int32Array && "int32" === t || e instanceof Uint8Array && "bool" === t
                }(e, t)) return e;
            if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
            if ("int32" === t) return new Int32Array(e);
            if ("bool" === t) {
                const t = new Uint8Array(e.length);
                for (let n = 0; n < t.length; ++n) 0 !== Math.round(e[n]) && (t[n] = 1);
                return t
            }
            throw new Error(`Unknown data type ${t}`)
        }

        function Xs() {
            return de().platform.now()
        }

        function Ys(e, t = "utf-8") {
            return t = t || "utf-8", de().platform.encode(e, t)
        }

        function Js(e, t = "utf-8") {
            return t = t || "utf-8", de().platform.decode(e, t)
        }
        class Zs {
            constructor(e, t) {
                this.backendTimer = e, this.logger = t, null == t && (this.logger = new er)
            }
            profileKernel(e, t, n) {
                let s;
                const r = () => {
                    s = n()
                };
                let a;
                const i = Xs();
                if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(r);
                else {
                    r();
                    for (const e of s) e.dataSync();
                    a = Promise.resolve({
                        kernelMs: Xs() - i
                    })
                }
                if (de().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
                    for (let t = 0; t < s.length; t++) {
                        const n = s[t];
                        n.data().then((t => {
                            Qs(t, n.dtype, e)
                        }))
                    }
                return {
                    kernelName: e,
                    outputs: s,
                    inputs: t,
                    timeMs: a.then((e => e.kernelMs)),
                    extraInfo: a.then((e => null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : ""))
                }
            }
            logKernelProfile(e) {
                const {
                    kernelName: t,
                    outputs: n,
                    timeMs: s,
                    inputs: r,
                    extraInfo: a
                } = e;
                n.forEach((e => {
                    Promise.all([e.data(), s, a]).then((n => {
                        this.logger.logKernelProfile(t, e, n[0], n[1], r, n[2])
                    }))
                }))
            }
        }

        function Qs(e, t, n) {
            if ("float32" !== t) return !1;
            for (let t = 0; t < e.length; t++) {
                const s = e[t];
                if (isNaN(s) || !isFinite(s)) return console.warn(`Found ${s} in the result of '${n}'`), !0
            }
            return !1
        }
        class er {
            logKernelProfile(e, t, n, s, r, a) {
                const i = "number" == typeof s ? B(`${s}ms`, 9) : s.error,
                    o = B(e, 25),
                    u = t.rank,
                    l = t.size,
                    c = B(t.shape.toString(), 14);
                let h = "";
                for (const e in r) {
                    const n = r[e];
                    if (null != n) {
                        const s = n.shape || t.shape,
                            r = s.length;
                        h += `${e}: ${r}D ${r>0?s:""} `
                    }
                }
                console.log(`%c${o}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
            }
        }

        function tr(e, t, n, s) {
            const r = ee(t),
                a = function(e, t, n, s) {
                    const r = O(t),
                        a = s[s.length - 1],
                        i = new Array(a).fill(0),
                        o = t.length,
                        u = "complex64" === n ? ar(e) : e;
                    if (o > 1)
                        for (let e = 0; e < r / a; e++) {
                            const t = e * a;
                            for (let e = 0; e < a; e++) i[e] = Math.max(i[e], nr(u[t + e], 0, n).length)
                        }
                    return i
                }(e, t, n, r),
                i = t.length,
                o = rr(e, t, n, r, a),
                u = ["Tensor"];
            return s && (u.push(`  dtype: ${n}`), u.push(`  rank: ${i}`), u.push(`  shape: [${t}]`), u.push("  values:")), u.push(o.map((e => "    " + e)).join("\n")), u.join("\n")
        }

        function nr(e, t, n) {
            let s;
            return s = Array.isArray(e) ? `${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j` : X(e) ? `'${e}'` : "bool" === n ? sr(e) : parseFloat(e.toFixed(7)).toString(), B(s, t)
        }

        function sr(e) {
            return 0 === e ? "false" : "true"
        }

        function rr(e, t, n, s, r, a = !0) {
            const i = "complex64" === n ? 2 : 1,
                o = t[0],
                u = t.length;
            if (0 === u) {
                if ("complex64" === n) {
                    return [nr(ar(e)[0], 0, n)]
                }
                return "bool" === n ? [sr(e[0])] : [e[0].toString()]
            }
            if (1 === u) {
                if (o > 20) {
                    const t = 3 * i;
                    let s = Array.from(e.slice(0, t)),
                        a = Array.from(e.slice((o - 3) * i, o * i));
                    return "complex64" === n && (s = ar(s), a = ar(a)), ["[" + s.map(((e, t) => nr(e, r[t], n))).join(", ") + ", ..., " + a.map(((e, t) => nr(e, r[o - 3 + t], n))).join(", ") + "]"]
                }
                return ["[" + ("complex64" === n ? ar(e) : Array.from(e)).map(((e, t) => nr(e, r[t], n))).join(", ") + "]"]
            }
            const l = t.slice(1),
                c = s.slice(1),
                h = s[0] * i,
                p = [];
            if (o > 20) {
                for (let t = 0; t < 3; t++) {
                    const s = t * h,
                        a = s + h;
                    p.push(...rr(e.slice(s, a), l, n, c, r, !1))
                }
                p.push("...");
                for (let t = o - 3; t < o; t++) {
                    const s = t * h,
                        a = s + h;
                    p.push(...rr(e.slice(s, a), l, n, c, r, t === o - 1))
                }
            } else
                for (let t = 0; t < o; t++) {
                    const s = t * h,
                        a = s + h;
                    p.push(...rr(e.slice(s, a), l, n, c, r, t === o - 1))
                }
            const d = 2 === u ? "," : "";
            p[0] = "[" + p[0] + d;
            for (let e = 1; e < p.length - 1; e++) p[e] = " " + p[e] + d;
            let f = ",\n";
            for (let e = 2; e < u; e++) f += "\n";
            return p[p.length - 1] = " " + p[p.length - 1] + "]" + (a ? "" : f), p
        }

        function ar(e) {
            const t = [];
            for (let n = 0; n < e.length; n += 2) t.push([e[n], e[n + 1]]);
            return t
        }
        class ir {
            constructor(e, t, n) {
                if (this.dtype = t, this.shape = e.slice(), this.size = O(e), null != n) {
                    const e = n.length;
                    R(e === this.size, (() => `Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))
                }
                if ("complex64" === t) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
                this.values = n || H(t, this.size), this.strides = ee(e)
            }
            set(e, ...t) {
                0 === t.length && (t = [0]), R(t.length === this.rank, (() => `The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));
                const n = this.locToIndex(t);
                this.values[n] = e
            }
            get(...e) {
                0 === e.length && (e = [0]);
                let t = 0;
                for (const n of e) {
                    if (n < 0 || n >= this.shape[t]) {
                        const t = `Requested out of range element at ${e}.   Buffer shape=${this.shape}`;
                        throw new Error(t)
                    }
                    t++
                }
                let n = e[e.length - 1];
                for (let t = 0; t < e.length - 1; ++t) n += this.strides[t] * e[t];
                return this.values[n]
            }
            locToIndex(e) {
                if (0 === this.rank) return 0;
                if (1 === this.rank) return e[0];
                let t = e[e.length - 1];
                for (let n = 0; n < e.length - 1; ++n) t += this.strides[n] * e[n];
                return t
            }
            indexToLoc(e) {
                if (0 === this.rank) return [];
                if (1 === this.rank) return [e];
                const t = new Array(this.shape.length);
                for (let n = 0; n < t.length - 1; ++n) t[n] = Math.floor(e / this.strides[n]), e -= t[n] * this.strides[n];
                return t[t.length - 1] = e, t
            }
            get rank() {
                return this.shape.length
            }
            toTensor() {
                return or().makeTensor(this.values, this.shape, this.dtype)
            }
        }
        let or = null,
            ur = null,
            lr = null;
        class cr {
            constructor(e, t, n, s) {
                this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", this.size = O(e), this.strides = ee(e), this.dataId = n, this.id = s, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
            }
            get rank() {
                return this.shape.length
            }
            async buffer() {
                const e = await this.data();
                return ur.buffer(this.shape, this.dtype, e)
            }
            bufferSync() {
                return ur.buffer(this.shape, this.dtype, this.dataSync())
            }
            async array() {
                const e = await this.data();
                return ne(this.shape, e, "complex64" === this.dtype)
            }
            arraySync() {
                return ne(this.shape, this.dataSync(), "complex64" === this.dtype)
            }
            async data() {
                this.throwIfDisposed();
                const e = or().read(this.dataId);
                if ("string" === this.dtype) {
                    const t = await e;
                    try {
                        return t.map((e => Js(e)))
                    } catch (e) {
                        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                    }
                }
                return e
            }
            dataToGPU(e) {
                return this.throwIfDisposed(), or().readToGPU(this.dataId, e)
            }
            dataSync() {
                this.throwIfDisposed();
                const e = or().readSync(this.dataId);
                if ("string" === this.dtype) try {
                    return e.map((e => Js(e)))
                } catch (e) {
                    throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
                return e
            }
            async bytes() {
                this.throwIfDisposed();
                const e = await or().read(this.dataId);
                return "string" === this.dtype ? e : new Uint8Array(e.buffer)
            }
            dispose() {
                this.isDisposed || (or().disposeTensor(this), this.isDisposedInternal = !0)
            }
            get isDisposed() {
                return this.isDisposedInternal
            }
            throwIfDisposed() {
                if (this.isDisposed) throw new Error("Tensor is disposed.")
            }
            print(e = !1) {
                return ur.print(this, e)
            }
            clone() {
                return this.throwIfDisposed(), ur.clone(this)
            }
            toString(e = !1) {
                return tr(this.dataSync(), this.shape, this.dtype, e)
            }
            cast(e) {
                return this.throwIfDisposed(), ur.cast(this, e)
            }
            variable(e = !0, t, n) {
                return this.throwIfDisposed(), or().makeVariable(this, e, t, n)
            }
        }

        function hr() {
            return ye("Tensor", (() => cr))
        }
        Object.defineProperty(cr, Symbol.hasInstance, {
            value: e => !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed
        }), hr();
        class pr extends cr {
            constructor(e, t, n, s) {
                super(e.shape, e.dtype, e.dataId, s), this.trainable = t, this.name = n
            }
            assign(e) {
                if (e.dtype !== this.dtype) throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
                if (!M(e.shape, this.shape)) throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
                or().disposeTensor(this), this.dataId = e.dataId, or().incRef(this, null)
            }
            dispose() {
                or().disposeVariable(this), this.isDisposedInternal = !0
            }
        }
        var dr, fr, mr, gr, yr;
        Object.defineProperty(pr, Symbol.hasInstance, {
                value: e => e instanceof cr && null != e.assign && e.assign instanceof Function
            }),
            function(e) {
                e.R0 = "R0", e.R1 = "R1", e.R2 = "R2", e.R3 = "R3", e.R4 = "R4", e.R5 = "R5", e.R6 = "R6"
            }(dr || (dr = {})),
            function(e) {
                e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64"
            }(fr || (fr = {})),
            function(e) {
                e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64"
            }(mr || (mr = {})),
            function(e) {
                e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64"
            }(gr || (gr = {})),
            function(e) {
                e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64"
            }(yr || (yr = {}));
        const br = {
            float32: gr,
            int32: fr,
            bool: mr,
            complex64: yr
        };

        function xr(e, t) {
            if ("string" === e || "string" === t) {
                if ("string" === e && "string" === t) return "string";
                throw new Error(`Can not upcast ${e} with ${t}`)
            }
            return br[e][t]
        }

        function wr(e) {
            return xr(e, "int32")
        }

        function kr(e, t) {
            if (e.dtype === t.dtype) return [e, t];
            const n = xr(e.dtype, t.dtype);
            return [e.cast(n), t.cast(n)]
        }

        function vr(e, t) {
            return t.some((t => t.id === e.id))
        }

        function Ir(e) {
            const t = [];
            return Nr(e, t, new Set), t
        }

        function Nr(e, t, n) {
            if (null == e) return;
            if (e instanceof cr) return void t.push(e);
            if (s = e, !Array.isArray(s) && "object" != typeof s) return;
            var s;
            const r = e;
            for (const e in r) {
                const s = r[e];
                n.has(s) || (n.add(s), Nr(s, t, n))
            }
        }

        function Sr(e) {
            return null != e.kernelName
        }
        class Tr {
            constructor() {
                this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
                    newBytes: 0,
                    newTensors: 0,
                    peakBytes: 0,
                    kernels: [],
                    result: null,
                    get kernelNames() {
                        return Array.from(new Set(this.kernels.map((e => e.name))))
                    }
                }
            }
            dispose() {
                for (const e in this.registeredVariables) this.registeredVariables[e].dispose()
            }
        }
        class $r {
            constructor(e) {
                this.ENV = e, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Tr
            }
            async ready() {
                if (null != this.pendingBackendInit) return this.pendingBackendInit.then((() => {}));
                if (null != this.backendInstance) return;
                const e = this.getSortedBackends();
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    if (await this.initializeBackend(n).success) return void await this.setBackend(n)
                }
                throw new Error("Could not initialize any backends, all backend initializations failed.")
            }
            get backend() {
                if (null != this.pendingBackendInit) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
                if (null == this.backendInstance) {
                    const {
                        name: e,
                        asyncInit: t
                    } = this.initializeBackendsAndReturnBest();
                    if (t) throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
                    this.setBackend(e)
                }
                return this.backendInstance
            }
            backendNames() {
                return Object.keys(this.registryFactory)
            }
            findBackend(e) {
                if (!(e in this.registry)) {
                    if (!(e in this.registryFactory)) return null;
                    {
                        const {
                            asyncInit: t
                        } = this.initializeBackend(e);
                        if (t) return null
                    }
                }
                return this.registry[e]
            }
            findBackendFactory(e) {
                return e in this.registryFactory ? this.registryFactory[e].factory : null
            }
            registerBackend(e, t, n = 1) {
                return e in this.registryFactory ? (Is(`${e} backend was already registered. Reusing existing backend factory.`), !1) : (this.registryFactory[e] = {
                    factory: t,
                    priority: n
                }, !0)
            }
            async setBackend(e) {
                if (null == this.registryFactory[e]) throw new Error(`Backend name '${e}' not found in registry`);
                if (this.backendName = e, null == this.registry[e]) {
                    this.backendInstance = null;
                    const {
                        success: t,
                        asyncInit: n
                    } = this.initializeBackend(e);
                    if (!(n ? await t : t)) return !1
                }
                return this.backendInstance = this.registry[e], this.setupRegisteredKernels(), this.profiler = new Zs(this.backendInstance), !0
            }
            setupRegisteredKernels() {
                Es(this.backendName).forEach((e => {
                    null != e.setupFunc && e.setupFunc(this.backendInstance)
                }))
            }
            disposeRegisteredKernels(e) {
                Es(e).forEach((t => {
                    null != t.disposeFunc && t.disposeFunc(this.registry[e])
                }))
            }
            initializeBackend(e) {
                const t = this.registryFactory[e];
                if (null == t) throw new Error(`Cannot initialize backend ${e}, no registration found.`);
                try {
                    const n = t.factory();
                    if (!n || n instanceof S || "function" != typeof n.then) return this.registry[e] = n, {
                        success: !0,
                        asyncInit: !1
                    };
                    {
                        const t = ++this.pendingBackendInitId,
                            s = n.then((n => !(t < this.pendingBackendInitId) && (this.registry[e] = n, this.pendingBackendInit = null, !0))).catch((n => (t < this.pendingBackendInitId || (this.pendingBackendInit = null, Is(`Initialization of backend ${e} failed`), Is(n.stack || n.message)), !1)));
                        return this.pendingBackendInit = s, {
                            success: s,
                            asyncInit: !0
                        }
                    }
                } catch (t) {
                    return Is(`Initialization of backend ${e} failed`), Is(t.stack || t.message), {
                        success: !1,
                        asyncInit: !1
                    }
                }
            }
            removeBackend(e) {
                if (!(e in this.registryFactory)) throw new Error(`${e} backend not found in registry`);
                this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
            }
            getSortedBackends() {
                if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
                return Object.keys(this.registryFactory).sort(((e, t) => this.registryFactory[t].priority - this.registryFactory[e].priority))
            }
            initializeBackendsAndReturnBest() {
                const e = this.getSortedBackends();
                for (let t = 0; t < e.length; t++) {
                    const n = e[t],
                        {
                            success: s,
                            asyncInit: r
                        } = this.initializeBackend(n);
                    if (r || s) return {
                        name: n,
                        asyncInit: r
                    }
                }
                throw new Error("Could not initialize any backends, all backend initializations failed.")
            }
            moveData(e, t) {
                const n = this.state.tensorInfo.get(t),
                    s = n.backend,
                    r = this.readSync(t),
                    a = s.refCount(t);
                s.disposeData(t, !0), n.backend = e, e.move(t, r, n.shape, n.dtype, a), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
            }
            tidy(e, t) {
                let n, s = null;
                if (null == t) {
                    if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
                    t = e
                } else {
                    if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
                    if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
                    s = e
                }
                return this.scopedRun((() => this.startScope(s)), (() => this.endScope(n)), (() => (n = t(), n instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n)))
            }
            scopedRun(e, t, n) {
                e();
                try {
                    const e = n();
                    return t(), e
                } catch (e) {
                    throw t(), e
                }
            }
            nextTensorId() {
                return $r.nextTensorId++
            }
            nextVariableId() {
                return $r.nextVariableId++
            }
            clone(e) {
                const t = Er.runKernel(Rt, {
                        x: e
                    }),
                    n = {
                        x: e
                    };
                return this.addTapeNode(this.state.activeScope.name, n, [t], (e => ({
                    x: () => {
                        const t = {
                                x: e
                            },
                            n = {
                                dtype: "float32"
                            };
                        return Er.runKernel(Pe, t, n)
                    }
                })), [], {}), t
            }
            runKernel(e, t, n) {
                null == this.backendName && this.backend;
                if (!(null != $s(e, this.backendName))) throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);
                return this.runKernelFunc({
                    kernelName: e,
                    inputs: t,
                    attrs: n
                })
            }
            shouldCheckForMemLeaks() {
                return this.ENV.getBool("IS_TEST")
            }
            checkKernelForMemLeak(e, t, n) {
                const s = this.backend.numDataIds();
                let r = 0;
                n.forEach((e => {
                    r += "complex64" === e.dtype ? 3 : 1
                }));
                const a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
                    i = s - t - r - a;
                if (i > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)
            }
            runKernelFunc(e) {
                let t, n = [];
                const s = this.isTapeOn(),
                    r = this.state.numBytes,
                    a = this.state.numTensors;
                let i, o;
                this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0), null == this.backendName && this.backend;
                const u = Sr(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
                if (Sr(e)) {
                    const {
                        kernelName: t,
                        inputs: r,
                        attrs: a
                    } = e;
                    null == this.backendName && this.backend;
                    const u = $s(t, this.backendName);
                    R(null != u, (() => `Cannot find registered kernel '${t}' for backend '${this.backendName}'`)), i = () => {
                        const e = this.backend.numDataIds();
                        o = u.kernelFunc({
                            inputs: r,
                            attrs: a,
                            backend: this.backend
                        });
                        const i = Array.isArray(o) ? o : [o];
                        this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(t, e, i);
                        const l = i.map((e => null != e.rank ? e : this.makeTensorFromTensorInfo(e)));
                        if (s) {
                            const e = this.getTensorsForGradient(t, r, l);
                            n = this.saveTensorsForBackwardMode(e)
                        }
                        return l
                    }
                } else {
                    const {
                        forwardFunc: t
                    } = e, r = e => {
                        s && (n = e.map((e => this.keep(this.clone(e)))))
                    };
                    i = () => {
                        const e = this.backend.numDataIds();
                        o = this.tidy((() => t(this.backend, r)));
                        const n = Array.isArray(o) ? o : [o];
                        return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(u, e, n), n
                    }
                }
                const {
                    inputs: l,
                    attrs: c
                } = e, h = Sr(e) ? null : e.backwardsFunc;
                let p;
                return this.scopedRun((() => this.state.kernelDepth++), (() => this.state.kernelDepth--), (() => {
                    this.ENV.getBool("DEBUG") || this.state.profiling ? (p = this.profiler.profileKernel(u, l, (() => i())), this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(p), t = p.outputs) : t = i()
                })), s && this.addTapeNode(u, l, t, h, n, c), this.state.profiling && this.state.activeProfile.kernels.push({
                    name: u,
                    bytesAdded: this.state.numBytes - r,
                    totalBytesSnapshot: this.state.numBytes,
                    tensorsAdded: this.state.numTensors - a,
                    totalTensorsSnapshot: this.state.numTensors,
                    inputShapes: Object.keys(l).map((e => null != l[e] ? l[e].shape : null)),
                    outputShapes: t.map((e => e.shape)),
                    kernelTimeMs: p.timeMs,
                    extraInfo: p.extraInfo
                }), Array.isArray(o) ? t : t[0]
            }
            saveTensorsForBackwardMode(e) {
                const t = e.map((e => this.keep(this.clone(e))));
                return t
            }
            getTensorsForGradient(e, t, n) {
                const s = Cs(e);
                if (null != s) {
                    const e = s.inputsToSave || [],
                        r = s.outputsToSave || [];
                    let a;
                    s.saveAllInputs ? (R(Array.isArray(t), (() => "saveAllInputs is true, expected inputs to be an array.")), a = Object.keys(t).map((e => t[e]))) : a = e.map((e => t[e]));
                    const i = n.filter(((e, t) => r[t]));
                    return a.concat(i)
                }
                return []
            }
            makeTensor(e, t, n, s) {
                if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
                n = n || "float32", s = s || this.backend;
                let r = e;
                "string" === n && X(e[0]) && (r = e.map((e => Ys(e))));
                const a = s.write(r, t, n),
                    i = new cr(t, n, a, this.nextTensorId());
                if (this.trackTensor(i, s), "string" === n) {
                    const e = this.state.tensorInfo.get(a),
                        t = function(e) {
                            if (null == e) return 0;
                            let t = 0;
                            return e.forEach((e => t += e.length)), t
                        }(r);
                    this.state.numBytes += t - e.bytes, e.bytes = t
                }
                return i
            }
            makeTensorFromDataId(e, t, n, s) {
                const r = {
                    dataId: e,
                    shape: t,
                    dtype: n = n || "float32"
                };
                return this.makeTensorFromTensorInfo(r, s)
            }
            makeTensorFromTensorInfo(e, t) {
                const {
                    dataId: n,
                    shape: s,
                    dtype: r
                } = e, a = new cr(s, r, n, this.nextTensorId());
                return this.trackTensor(a, t), a
            }
            makeVariable(e, t = !0, n, s) {
                n = n || this.nextVariableId().toString(), null != s && s !== e.dtype && (e = e.cast(s));
                const r = new pr(e, t, n, this.nextTensorId());
                if (null != this.state.registeredVariables[r.name]) throw new Error(`Variable with name ${r.name} was already registered`);
                return this.state.registeredVariables[r.name] = r, this.incRef(r, this.backend), r
            }
            trackTensor(e, t) {
                this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
                let n = 0;
                "complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * K(e.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
                    backend: t || this.backend,
                    dtype: e.dtype,
                    shape: e.shape,
                    bytes: n
                })), e instanceof pr || this.track(e)
            }
            incRef(e, t) {
                this.trackTensor(e, t), this.backend.incRef(e.dataId)
            }
            removeDataId(e, t) {
                this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--)
            }
            disposeTensor(e) {
                if (!this.state.tensorInfo.has(e.dataId)) return;
                const t = this.state.tensorInfo.get(e.dataId);
                if (this.state.numTensors--, "string" === e.dtype && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), "complex64" !== e.dtype && "string" !== e.dtype) {
                    const t = e.size * K(e.dtype);
                    this.state.numBytes -= t
                }
                t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend)
            }
            disposeVariables() {
                for (const e in this.state.registeredVariables) {
                    const t = this.state.registeredVariables[e];
                    this.disposeVariable(t)
                }
            }
            disposeVariable(e) {
                this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name]
            }
            memory() {
                const e = this.backend.memory();
                return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e
            }
            async profile(e) {
                this.state.profiling = !0;
                const t = this.state.numBytes,
                    n = this.state.numTensors;
                this.state.activeProfile.kernels = [], this.state.activeProfile.result = await e(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((e => e.totalBytesSnapshot))), this.state.activeProfile.newBytes = this.state.numBytes - t, this.state.activeProfile.newTensors = this.state.numTensors - n;
                for (const e of this.state.activeProfile.kernels) e.kernelTimeMs = await e.kernelTimeMs, e.extraInfo = await e.extraInfo;
                return this.state.activeProfile
            }
            isTapeOn() {
                return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
            }
            addTapeNode(e, t, n, s, r, a) {
                const i = {
                        id: this.state.nextTapeNodeId++,
                        kernelName: e,
                        inputs: t,
                        outputs: n,
                        saved: r
                    },
                    o = Cs(e);
                null != o && (s = o.gradFunc), null != s && (i.gradient = e => (e = e.map(((e, t) => {
                    if (null == e) {
                        const e = n[t],
                            s = re(e.size, e.dtype);
                        return this.makeTensor(s, e.shape, e.dtype)
                    }
                    return e
                })), s(e.length > 1 ? e : e[0], r, a))), this.state.activeTape.push(i)
            }
            keep(e) {
                return e.kept = !0, e
            }
            startTape() {
                0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
            }
            endTape() {
                this.state.gradientDepth--
            }
            startScope(e) {
                const t = {
                    track: [],
                    name: "unnamed scope",
                    id: this.state.nextScopeId++
                };
                e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t
            }
            endScope(e) {
                const t = Ir(e),
                    n = new Set(t.map((e => e.id)));
                for (let e = 0; e < this.state.activeScope.track.length; e++) {
                    const t = this.state.activeScope.track[e];
                    t.kept || n.has(t.id) || t.dispose()
                }
                const s = this.state.scopeStack.pop();
                this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], t.forEach((e => {
                    e.kept || e.scopeId !== s.id || this.track(e)
                }))
            }
            gradients(e, t, n, s = !1) {
                if (R(t.length > 0, (() => "gradients() received an empty list of xs.")), null != n && "float32" !== n.dtype) throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);
                const r = this.scopedRun((() => this.startTape()), (() => this.endTape()), (() => this.tidy("forward", e)));
                R(r instanceof cr, (() => "The result y returned by f() must be a tensor."));
                const a = function(e, t, n) {
                    const s = {},
                        r = {};
                    for (let e = 0; e < t.length; e++) s[t[e].id] = !0;
                    for (let n = 0; n < e.length; n++) {
                        const a = e[n],
                            i = a.inputs;
                        for (const e in i) {
                            const n = i[e];
                            let o = !1;
                            for (let e = 0; e < t.length; e++)
                                if (s[n.id]) {
                                    a.outputs.forEach((e => s[e.id] = !0)), o = !0, r[a.id] = !0;
                                    break
                                } if (o) break
                        }
                    }
                    const a = {};
                    a[n.id] = !0;
                    const i = {};
                    for (let t = e.length - 1; t >= 0; t--) {
                        const n = e[t],
                            s = n.inputs;
                        for (let e = 0; e < n.outputs.length; e++)
                            if (a[n.outputs[e].id]) {
                                for (const e in s) a[s[e].id] = !0, i[n.id] = !0;
                                break
                            }
                    }
                    const o = [];
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        if (r[n.id] && i[n.id]) {
                            const e = {};
                            for (const t in n.inputs) {
                                const r = n.inputs[t];
                                s[r.id] && (e[t] = r)
                            }
                            const t = Object.assign({}, n);
                            t.inputs = e, t.outputs = n.outputs, o.push(t)
                        }
                    }
                    return o
                }(this.state.activeTape, t, r);
                if (!s && 0 === a.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
                return this.tidy("backward", (() => {
                    const e = {};
                    e[r.id] = null == n ? function(e) {
                            const t = se(O(e), "float32");
                            return Er.makeTensor(t, e, "float32")
                        }(r.shape) : n,
                        function(e, t, n, s) {
                            for (let r = t.length - 1; r >= 0; r--) {
                                const a = t[r],
                                    i = [];
                                if (a.outputs.forEach((t => {
                                        const n = e[t.id];
                                        null != n ? i.push(n) : i.push(null)
                                    })), null == a.gradient) throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);
                                const o = a.gradient(i);
                                for (const t in a.inputs) {
                                    if (!(t in o)) throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);
                                    const r = n((() => o[t]()));
                                    if ("float32" !== r.dtype) throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${r.dtype}'`);
                                    const i = a.inputs[t];
                                    if (!M(r.shape, i.shape)) throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${r.shape}', which does not match the shape of the input '${i.shape}'`);
                                    if (null == e[i.id]) e[i.id] = r;
                                    else {
                                        const t = e[i.id];
                                        e[i.id] = s(t, r), t.dispose()
                                    }
                                }
                            }
                        }(e, a, (e => this.tidy(e)), Ar);
                    const s = t.map((t => e[t.id]));
                    return 0 === this.state.gradientDepth && (this.state.activeTape.forEach((e => {
                        for (const t of e.saved) t.dispose()
                    })), this.state.activeTape = null), {
                        value: r,
                        grads: s
                    }
                }))
            }
            customGrad(e) {
                return R(Z(e), (() => "The f passed in customGrad(f) must be a function.")), (...t) => {
                    let n;
                    R(t.every((e => e instanceof cr)), (() => "The args passed in customGrad(f)(x1, x2,...) must all be tensors"));
                    const s = {};
                    t.forEach(((e, t) => {
                        s[t] = e
                    }));
                    return this.runKernelFunc({
                        forwardFunc: (s, r) => (n = e(...t, r), R(n.value instanceof cr, (() => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")), R(Z(n.gradFunc), (() => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")), n.value),
                        backwardsFunc: (e, s) => {
                            const r = n.gradFunc(e, s),
                                a = Array.isArray(r) ? r : [r];
                            R(a.length === t.length, (() => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")), R(a.every((e => e instanceof cr)), (() => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));
                            const i = {};
                            return a.forEach(((e, t) => {
                                i[t] = () => e
                            })), i
                        },
                        inputs: s
                    })
                }
            }
            readSync(e) {
                return this.state.tensorInfo.get(e).backend.readSync(e)
            }
            read(e) {
                return this.state.tensorInfo.get(e).backend.read(e)
            }
            readToGPU(e, t) {
                return this.state.tensorInfo.get(e).backend.readToGPU(e, t)
            }
            async time(e) {
                const t = Xs(),
                    n = await this.backend.time(e);
                return n.wallMs = Xs() - t, n
            }
            track(e) {
                return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e
            }
            get registeredVariables() {
                return this.state.registeredVariables
            }
            reset() {
                this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Tr;
                for (const e in this.registry) this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
                this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
            }
        }

        function Cr() {
            const e = ge();
            if (null == e._tfengine) {
                const t = new he(e);
                e._tfengine = new $r(t)
            }
            var t;
            return t = e._tfengine.ENV, me = t, or = () => e._tfengine, e._tfengine
        }
        $r.nextTensorId = 0, $r.nextVariableId = 0;
        const Er = Cr();

        function Ar(e, t) {
            const n = {
                a: e,
                b: t
            };
            return Er.runKernel(ke, n)
        }
        let Rr;

        function Fr(e) {
            if (void 0 !== Rr) return Rr;
            if (e || "undefined" != typeof navigator && null != navigator) {
                if (e || (e = navigator), "ReactNative" === e.product) return !0;
                const t = e.userAgent || e.vendor || ("undefined" != typeof window ? window.opera : "");
                if (!t) {
                    const t = e;
                    return t.userAgentData && t.userAgentData.mobile
                }
                return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))
            }
            return !1
        }

        function Dr() {
            return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
        }
        const _r = de();

        function Or(e, t) {
            let n = e;
            if (q(e)) return "string" === t ? [] : [e.length];
            if (!Array.isArray(e)) return [];
            const s = [];
            for (; Array.isArray(n) || q(n) && "string" !== t;) s.push(n.length), n = n[0];
            return Array.isArray(e) && de().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && Mr(e, s, []), s
        }

        function Mr(e, t, n) {
            if (n = n || [], !Array.isArray(e) && !q(e)) return void R(0 === t.length, (() => `Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));
            R(t.length > 0, (() => `Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)), R(e.length === t[0], (() => `Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));
            const s = t.slice(1);
            for (let t = 0; t < e.length; ++t) Mr(e[t], s, n.concat(t))
        }

        function Lr(e, t, n, s) {
            if ("string_or_numeric" !== e) {
                if (null == e) throw new Error("Expected dtype cannot be null.");
                if ("numeric" !== e && e !== t || "numeric" === e && "string" === t) throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)
            }
        }

        function zr(e, t, n, s = "numeric") {
            if (e instanceof cr) return Lr(s, e.dtype, t, n), e;
            let r = J(e);
            if ("string" !== r && ["bool", "int32", "float32"].indexOf(s) >= 0 && (r = s), Lr(s, r, t, n), null == e || !q(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) {
                const s = null == e ? "null" : e.constructor.name;
                throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${s}'`)
            }
            const a = Or(e, r);
            q(e) || Array.isArray(e) || (e = [e]);
            const i = "string" !== r ? Ks(e, r) : _(e, [], !0);
            return Er.makeTensor(i, a, r)
        }

        function Br(e, t, n, s = "numeric") {
            if (!Array.isArray(e)) throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);
            return e.map(((e, r) => zr(e, `${t}[${r}]`, n, s)))
        }
        _r.registerFlag("DEBUG", (() => !1), (e => {
            e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
        })), _r.registerFlag("IS_BROWSER", (() => Dr())), _r.registerFlag("IS_NODE", (() => "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node)), _r.registerFlag("IS_CHROME", (() => "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor))), _r.registerFlag("PROD", (() => !1)), _r.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", (() => _r.getBool("DEBUG"))), _r.registerFlag("DEPRECATION_WARNINGS_ENABLED", (() => !0)), _r.registerFlag("IS_TEST", (() => !1)), _r.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", (() => !0)), _r.registerFlag("WRAP_TO_IMAGEBITMAP", (() => !1)), _r.registerFlag("ENGINE_COMPILE_ONLY", (() => !1));

        function Pr(e) {
            const t = Object.keys(e);
            if (1 !== t.length) throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
            let n = t[0];
            const s = e[n];
            n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += "__op";
            const r = (...e) => {
                Er.startScope(n);
                try {
                    const t = s(...e);
                    return le(t) && console.error("Cannot return a Promise inside of tidy."), Er.endScope(t), t
                } catch (e) {
                    throw Er.endScope(null), e
                }
            };
            return Object.defineProperty(r, "name", {
                value: n,
                configurable: !0
            }), r
        }
        const Ur = Pr({
            complex_: function(e, t) {
                const n = zr(e, "real", "complex"),
                    s = zr(t, "imag", "complex");
                F(n.shape, s.shape, `real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);
                const r = {
                    real: n,
                    imag: s
                };
                return Er.runKernel(Ve, r)
            }
        });

        function Wr(e, t, n, s) {
            if (null == s && (s = J(e)), "complex64" === s) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
            if (!q(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
            if (null != t) {
                ie(t);
                const e = O(t),
                    s = O(n);
                R(e === s, (() => `Based on the provided shape, [${t}], the tensor should have ${e} values but has ${s}`));
                for (let e = 0; e < n.length; ++e) {
                    const s = n[e],
                        r = e !== n.length - 1 || s !== O(t.slice(e));
                    R(n[e] === t[e] || !r, (() => `Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))
                }
            }
            return q(e) || Array.isArray(e) || (e = [e]), t = t || n, e = "string" !== s ? Ks(e, s) : _(e, [], !0), Er.makeTensor(e, t, s)
        }

        function Vr(e, t, n) {
            return Wr(e, t, Or(e, n), n)
        }
        const Gr = {
            float32: 4,
            float16: 2,
            int32: 4,
            uint16: 2,
            uint8: 1,
            bool: 1,
            complex64: 8
        };
        async function Hr(e, t) {
            const n = [],
                s = [],
                r = Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e);
            for (let a = 0; a < r.length; ++a) {
                const i = r[a],
                    o = Array.isArray(e) ? e[a].tensor : e[i];
                if ("float32" !== o.dtype && "int32" !== o.dtype && "bool" !== o.dtype && "string" !== o.dtype && "complex64" !== o.dtype) throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);
                const u = {
                    name: i,
                    shape: o.shape,
                    dtype: o.dtype
                };
                if ("string" === o.dtype) {
                    const e = new Promise((async e => {
                        const t = await o.bytes(),
                            n = t.reduce(((e, t) => e + t.length), 0) + 4 * t.length,
                            s = new Uint8Array(n);
                        let r = 0;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e],
                                a = new Uint8Array(new Uint32Array([n.length]).buffer);
                            s.set(a, r), r += 4, s.set(n, r), r += n.length
                        }
                        e(s)
                    }));
                    s.push(e)
                } else s.push(o.data());
                null != t && (u.group = t), n.push(u)
            }
            return {
                data: qr(await Promise.all(s)),
                specs: n
            }
        }

        function jr(e, t) {
            const n = {};
            let s, r = 0;
            for (const a of t) {
                const t = a.name,
                    i = a.dtype,
                    o = a.shape,
                    u = O(o);
                let l;
                if ("quantization" in a) {
                    const n = a.quantization;
                    if ("uint8" === n.dtype || "uint16" === n.dtype) {
                        if (!("min" in n) || !("scale" in n)) throw new Error(`Weight ${a.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)
                    } else {
                        if ("float16" !== n.dtype) throw new Error(`Weight ${a.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
                        if ("float32" !== i) throw new Error(`Weight ${a.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)
                    }
                    const o = Gr[n.dtype],
                        c = e.slice(r, r + u * o),
                        h = "uint8" === n.dtype ? new Uint8Array(c) : new Uint16Array(c);
                    if ("float32" === i)
                        if ("uint8" === n.dtype || "uint16" === n.dtype) {
                            l = new Float32Array(h.length);
                            for (let e = 0; e < h.length; e++) {
                                const t = h[e];
                                l[e] = t * n.scale + n.min
                            }
                        } else {
                            if ("float16" !== n.dtype) throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);
                            void 0 === s && (s = ea()), l = s(h)
                        }
                    else {
                        if ("int32" !== i) throw new Error(`Unsupported dtype in weight '${t}': ${i}`);
                        if ("uint8" !== n.dtype && "uint16" !== n.dtype) throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);
                        l = new Int32Array(h.length);
                        for (let e = 0; e < h.length; e++) {
                            const t = h[e];
                            l[e] = Math.round(t * n.scale + n.min)
                        }
                    }
                    r += u * o
                } else if ("string" === i) {
                    const t = O(a.shape);
                    l = [];
                    for (let n = 0; n < t; n++) {
                        const t = new Uint32Array(e.slice(r, r + 4))[0];
                        r += 4;
                        const n = new Uint8Array(e.slice(r, r + t));
                        l.push(n), r += t
                    }
                } else {
                    const s = Gr[i],
                        a = e.slice(r, r + u * s);
                    if ("float32" === i) l = new Float32Array(a);
                    else if ("int32" === i) l = new Int32Array(a);
                    else if ("bool" === i) l = new Uint8Array(a);
                    else {
                        if ("complex64" !== i) throw new Error(`Unsupported dtype in weight '${t}': ${i}`);
                        {
                            l = new Float32Array(a);
                            const e = new Float32Array(l.length / 2),
                                s = new Float32Array(l.length / 2);
                            for (let t = 0; t < e.length; t++) e[t] = l[2 * t], s[t] = l[2 * t + 1];
                            const r = Vr(e, o, "float32"),
                                i = Vr(s, o, "float32");
                            n[t] = Ur(r, i), r.dispose(), i.dispose()
                        }
                    }
                    r += u * s
                }
                "complex64" !== i && (n[t] = Vr(l, o, i))
            }
            return n
        }

        function qr(e) {
            if (null === e) throw new Error(`Invalid input value: ${JSON.stringify(e)}`);
            let t = 0;
            const n = [];
            e.forEach((e => {
                if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)
            }));
            const s = new Uint8Array(t);
            let r = 0;
            return n.forEach((e => {
                s.set(new Uint8Array(e.buffer), r), r += e.byteLength
            })), s.buffer
        }
        const Kr = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

        function Xr(e) {
            return Kr ? Buffer.byteLength(e) : new Blob([e]).size
        }

        function Yr(e) {
            if (1 === e.length) return e[0];
            let t = 0;
            e.forEach((e => {
                t += e.byteLength
            }));
            const n = new Uint8Array(t);
            let s = 0;
            return e.forEach((e => {
                n.set(new Uint8Array(e), s), s += e.byteLength
            })), n.buffer
        }

        function Jr(e, t) {
            const n = {
                modelTopology: e.modelTopology,
                format: e.format,
                generatedBy: e.generatedBy,
                convertedBy: e.convertedBy,
                weightsManifest: t
            };
            return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), n
        }
        async function Zr(e, t) {
            const n = {
                modelTopology: e.modelTopology,
                format: e.format,
                generatedBy: e.generatedBy,
                convertedBy: e.convertedBy
            };
            if (null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), null != e.weightsManifest) {
                const [s, r] = await t(e.weightsManifest);
                n.weightSpecs = s, n.weightData = r
            }
            return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), n
        }

        function Qr(e) {
            if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
            return {
                dateSaved: new Date,
                modelTopologyType: "JSON",
                modelTopologyBytes: null == e.modelTopology ? 0 : Xr(JSON.stringify(e.modelTopology)),
                weightSpecsBytes: null == e.weightSpecs ? 0 : Xr(JSON.stringify(e.weightSpecs)),
                weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength
            }
        }

        function ea() {
            const e = function() {
                    const e = e => {
                            let t = e << 13,
                                n = 0;
                            for (; !(8388608 & t);) n -= 8388608, t <<= 1;
                            return t &= -8388609, n += 947912704, t | n
                        },
                        t = new Uint32Array(2048);
                    t[0] = 0;
                    for (let n = 1; n < 1024; n++) t[n] = e(n);
                    for (let e = 1024; e < 2048; e++) t[e] = 939524096 + (e - 1024 << 13);
                    return t
                }(),
                t = function() {
                    const e = new Uint32Array(64);
                    e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;
                    for (let t = 1; t < 31; t++) e[t] = t << 23;
                    for (let t = 33; t < 63; t++) e[t] = 2147483648 + (t - 32 << 23);
                    return e
                }(),
                n = function() {
                    const e = new Uint32Array(64);
                    for (let t = 0; t < 64; t++) e[t] = 1024;
                    return e[0] = e[32] = 0, e
                }();
            return s => {
                const r = new ArrayBuffer(4 * s.length),
                    a = new Uint32Array(r);
                for (let r = 0; r < s.length; r++) {
                    const i = s[r],
                        o = e[n[i >> 10] + (1023 & i)] + t[i >> 10];
                    a[r] = o
                }
                return new Float32Array(r)
            }
        }
        class ta {
            constructor() {
                this.saveRouters = [], this.loadRouters = []
            }
            static getInstance() {
                return null == ta.instance && (ta.instance = new ta), ta.instance
            }
            static registerSaveRouter(e) {
                ta.getInstance().saveRouters.push(e)
            }
            static registerLoadRouter(e) {
                ta.getInstance().loadRouters.push(e)
            }
            static getSaveHandlers(e) {
                return ta.getHandlers(e, "save")
            }
            static getLoadHandlers(e, t) {
                return ta.getHandlers(e, "load", t)
            }
            static getHandlers(e, t, n) {
                const s = [];
                return ("load" === t ? ta.getInstance().loadRouters : ta.getInstance().saveRouters).forEach((t => {
                    const r = t(e, n);
                    null !== r && s.push(r)
                })), s
            }
        }
        const na = e => ta.getSaveHandlers(e),
            sa = "tensorflowjs",
            ra = "models_store",
            aa = "model_info_store";

        function ia() {
            if (!de().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
            const e = "undefined" == typeof window ? self : window,
                t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
            if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
            return t
        }

        function oa(e) {
            const t = e.result;
            t.createObjectStore(ra, {
                keyPath: "modelPath"
            }), t.createObjectStore(aa, {
                keyPath: "modelPath"
            })
        }
        class ua {
            constructor(e) {
                if (this.indexedDB = ia(), null == e || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
                this.modelPath = e
            }
            async save(e) {
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                return this.databaseAction(this.modelPath, e)
            }
            async load() {
                return this.databaseAction(this.modelPath)
            }
            databaseAction(e, t) {
                return new Promise(((e, n) => {
                    const s = this.indexedDB.open(sa, 1);
                    s.onupgradeneeded = () => oa(s), s.onsuccess = () => {
                        const r = s.result;
                        if (null == t) {
                            const t = r.transaction(ra, "readonly"),
                                s = t.objectStore(ra).get(this.modelPath);
                            s.onsuccess = () => {
                                if (null == s.result) return r.close(), n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
                                e(s.result.modelArtifacts)
                            }, s.onerror = e => (r.close(), n(s.error)), t.oncomplete = () => r.close()
                        } else {
                            const s = Qr(t),
                                a = r.transaction(aa, "readwrite");
                            let i = a.objectStore(aa);
                            const o = i.put({
                                modelPath: this.modelPath,
                                modelArtifactsInfo: s
                            });
                            let u;
                            o.onsuccess = () => {
                                u = r.transaction(ra, "readwrite");
                                const o = u.objectStore(ra).put({
                                    modelPath: this.modelPath,
                                    modelArtifacts: t,
                                    modelArtifactsInfo: s
                                });
                                o.onsuccess = () => e({
                                    modelArtifactsInfo: s
                                }), o.onerror = e => {
                                    i = a.objectStore(aa);
                                    const t = i.delete(this.modelPath);
                                    t.onsuccess = () => (r.close(), n(o.error)), t.onerror = e => (r.close(), n(o.error))
                                }
                            }, o.onerror = e => (r.close(), n(o.error)), a.oncomplete = () => {
                                null == u ? r.close() : u.oncomplete = () => r.close()
                            }
                        }
                    }, s.onerror = e => n(s.error)
                }))
            }
        }
        ua.URL_SCHEME = "indexeddb://";
        const la = e => {
            return de().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(ua.URL_SCHEME) ? (t = e.slice(ua.URL_SCHEME.length), new ua(t)) : null;
            var t
        };
        ta.registerSaveRouter(la), ta.registerLoadRouter(la);
        class ca {
            constructor() {
                this.indexedDB = ia()
            }
            async listModels() {
                return new Promise(((e, t) => {
                    const n = this.indexedDB.open(sa, 1);
                    n.onupgradeneeded = () => oa(n), n.onsuccess = () => {
                        const s = n.result,
                            r = s.transaction(aa, "readonly"),
                            a = r.objectStore(aa).getAll();
                        a.onsuccess = () => {
                            const t = {};
                            for (const e of a.result) t[e.modelPath] = e.modelArtifactsInfo;
                            e(t)
                        }, a.onerror = e => (s.close(), t(a.error)), r.oncomplete = () => s.close()
                    }, n.onerror = e => t(n.error)
                }))
            }
            async removeModel(e) {
                var t;
                return e = (t = e).startsWith(ua.URL_SCHEME) ? t.slice(ua.URL_SCHEME.length) : t, new Promise(((t, n) => {
                    const s = this.indexedDB.open(sa, 1);
                    s.onupgradeneeded = () => oa(s), s.onsuccess = () => {
                        const r = s.result,
                            a = r.transaction(aa, "readwrite"),
                            i = a.objectStore(aa),
                            o = i.get(e);
                        let u;
                        o.onsuccess = () => {
                            if (null == o.result) return r.close(), n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));
                            {
                                const s = i.delete(e),
                                    a = () => {
                                        u = r.transaction(ra, "readwrite");
                                        const s = u.objectStore(ra).delete(e);
                                        s.onsuccess = () => t(o.result.modelArtifactsInfo), s.onerror = e => n(o.error)
                                    };
                                s.onsuccess = a, s.onerror = e => (a(), r.close(), n(o.error))
                            }
                        }, o.onerror = e => (r.close(), n(o.error)), a.oncomplete = () => {
                            null == u ? r.close() : u.oncomplete = () => r.close()
                        }
                    }, s.onerror = e => n(s.error)
                }))
            }
        }
        const ha = "/",
            pa = "tensorflowjs_models",
            da = "info",
            fa = "model_topology",
            ma = "weight_specs",
            ga = "weight_data",
            ya = "model_metadata";

        function ba(e) {
            return {
                info: [pa, e, da].join(ha),
                topology: [pa, e, fa].join(ha),
                weightSpecs: [pa, e, ma].join(ha),
                weightData: [pa, e, ga].join(ha),
                modelMetadata: [pa, e, ya].join(ha)
            }
        }

        function xa(e) {
            for (const t of Object.values(e)) window.localStorage.removeItem(t)
        }

        function wa(e) {
            const t = e.split(ha);
            if (t.length < 3) throw new Error(`Invalid key format: ${e}`);
            return t.slice(1, t.length - 1).join(ha)
        }
        class ka {
            constructor(e) {
                if (!de().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
                if (this.LS = window.localStorage, null == e || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
                this.modelPath = e, this.keys = ba(this.modelPath)
            }
            async save(e) {
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                {
                    const t = JSON.stringify(e.modelTopology),
                        n = JSON.stringify(e.weightSpecs),
                        s = Qr(e);
                    try {
                        this.LS.setItem(this.keys.info, JSON.stringify(s)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function(e) {
                            if (Kr) return Buffer.from(e).toString("base64");
                            const t = new Uint8Array(e);
                            let n = "";
                            for (let e = 0, s = t.length; e < s; e++) n += String.fromCharCode(t[e]);
                            return btoa(n)
                        }(e.weightData));
                        const r = {
                            format: e.format,
                            generatedBy: e.generatedBy,
                            convertedBy: e.convertedBy,
                            signature: null != e.signature ? e.signature : void 0,
                            userDefinedMetadata: null != e.userDefinedMetadata ? e.userDefinedMetadata : void 0,
                            modelInitializer: null != e.modelInitializer ? e.modelInitializer : void 0,
                            trainingConfig: null != e.trainingConfig ? e.trainingConfig : void 0
                        };
                        return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(r)), {
                            modelArtifactsInfo: s
                        }
                    } catch (e) {
                        throw xa(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)
                    }
                }
            }
            async load() {
                const e = JSON.parse(this.LS.getItem(this.keys.info));
                if (null == e) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
                if ("JSON" !== e.modelTopologyType) throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                const t = {},
                    n = JSON.parse(this.LS.getItem(this.keys.topology));
                if (null == n) throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
                t.modelTopology = n;
                const s = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
                if (null == s) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
                t.weightSpecs = s;
                const r = this.LS.getItem(this.keys.modelMetadata);
                if (null != r) {
                    const e = JSON.parse(r);
                    t.format = e.format, t.generatedBy = e.generatedBy, t.convertedBy = e.convertedBy, null != e.signature && (t.signature = e.signature), null != e.userDefinedMetadata && (t.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (t.modelInitializer = e.modelInitializer), null != e.trainingConfig && (t.trainingConfig = e.trainingConfig)
                }
                const a = this.LS.getItem(this.keys.weightData);
                if (null == a) throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
                return t.weightData = function(e) {
                    if (Kr) {
                        const t = Buffer.from(e, "base64");
                        return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
                    }
                    const t = atob(e),
                        n = new Uint8Array(t.length);
                    for (let e = 0; e < t.length; ++e) n.set([t.charCodeAt(e)], e);
                    return n.buffer
                }(a), t
            }
        }
        ka.URL_SCHEME = "localstorage://";
        const va = e => {
            return de().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(ka.URL_SCHEME) ? (t = e.slice(ka.URL_SCHEME.length), new ka(t)) : null;
            var t
        };
        ta.registerSaveRouter(va), ta.registerLoadRouter(va);
        class Ia {
            constructor() {
                R(de().getBool("IS_BROWSER"), (() => "Current environment is not a web browser")), R("undefined" == typeof window || void 0 !== window.localStorage, (() => "Current browser does not appear to support localStorage")), this.LS = window.localStorage
            }
            async listModels() {
                const e = {},
                    t = pa + ha,
                    n = ha + da;
                for (let s = 0; s < this.LS.length; ++s) {
                    const r = this.LS.key(s);
                    if (r.startsWith(t) && r.endsWith(n)) {
                        e[wa(r)] = JSON.parse(this.LS.getItem(r))
                    }
                }
                return e
            }
            async removeModel(e) {
                var t;
                const n = ba(e = (t = e).startsWith(ka.URL_SCHEME) ? t.slice(ka.URL_SCHEME.length) : t);
                if (null == this.LS.getItem(n.info)) throw new Error(`Cannot find model at path '${e}'`);
                const s = JSON.parse(this.LS.getItem(n.info));
                return xa(n), s
            }
        }
        const Na = "://";
        class Sa {
            constructor() {
                this.managers = {}
            }
            static getInstance() {
                return null == Sa.instance && (Sa.instance = new Sa), Sa.instance
            }
            static registerManager(e, t) {
                R(null != e, (() => "scheme must not be undefined or null.")), e.endsWith(Na) && (e = e.slice(0, e.indexOf(Na))), R(e.length > 0, (() => "scheme must not be an empty string."));
                const n = Sa.getInstance();
                R(null == n.managers[e], (() => `A model store manager is already registered for scheme '${e}'.`)), n.managers[e] = t
            }
            static getManager(e) {
                const t = this.getInstance().managers[e];
                if (null == t) throw new Error(`Cannot find model manager for scheme '${e}'`);
                return t
            }
            static getSchemes() {
                return Object.keys(this.getInstance().managers)
            }
        }
        class Ta {
            fetch(e, t) {
                return fetch(e, t)
            }
            now() {
                return performance.now()
            }
            encode(e, t) {
                if ("utf-8" !== t && "utf8" !== t) throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);
                return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(e)
            }
            decode(e, t) {
                return new TextDecoder(t).decode(e)
            }
        }
        if (de().get("IS_BROWSER")) {
            de().setPlatform("browser", new Ta);
            try {
                Sa.registerManager(ka.URL_SCHEME, new Ia)
            } catch (e) {}
            try {
                Sa.registerManager(ua.URL_SCHEME, new ca)
            } catch (e) {}
        }
        const $a = () => n(817);
        let Ca;
        class Ea {
            constructor() {
                this.util = n(590), this.textEncoder = new this.util.TextEncoder
            }
            fetch(e, t) {
                return null != de().global.fetch ? de().global.fetch(e, t) : (null == Ca && (Ca = $a()), Ca(e, t))
            }
            now() {
                const e = process.hrtime();
                return 1e3 * e[0] + e[1] / 1e6
            }
            encode(e, t) {
                if ("utf-8" !== t && "utf8" !== t) throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);
                return this.textEncoder.encode(e)
            }
            decode(e, t) {
                return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e)
            }
        }

        function Aa(e, t = "float32", n) {
            return t = t || "float32", ie(e), new ir(e, t, n)
        }
        de().get("IS_NODE") && !de().get("IS_BROWSER") && de().setPlatform("node", new Ea);
        const Ra = Pr({
            cast_: function(e, t) {
                const n = zr(e, "x", "cast");
                if (! function(e) {
                        return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e
                    }(t)) throw new Error(`Failed to cast to unknown dtype ${t}`);
                if ("string" === t && "string" !== n.dtype || "string" !== t && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
                const s = {
                        x: n
                    },
                    r = {
                        dtype: t
                    };
                return Er.runKernel(Pe, s, r)
            }
        });
        const Fa = Pr({
            clone_: function(e) {
                const t = {
                    x: zr(e, "x", "clone", "string_or_numeric")
                };
                return Er.runKernel(Rt, t)
            }
        });
        Cr();
        ur = {
            buffer: Aa,
            cast: Ra,
            clone: Fa,
            print: function(e, t = !1) {
                console.log(e.toString(t))
            }
        };

        function Da(e) {
            return new Promise((e => setTimeout(e))).then(e)
        }
        class _a {
            constructor(e) {
                if (!de().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
                e.startsWith(_a.URL_SCHEME) && (e = e.slice(_a.URL_SCHEME.length)), null != e && 0 !== e.length || (e = "model"), this.modelJsonFileName = e + ".json", this.weightDataFileName = e + ".weights.bin"
            }
            async save(e) {
                if ("undefined" == typeof document) throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                const t = window.URL.createObjectURL(new Blob([e.weightData], {
                    type: "application/octet-stream"
                }));
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
                {
                    const n = Jr(e, [{
                            paths: ["./" + this.weightDataFileName],
                            weights: e.weightSpecs
                        }]),
                        s = window.URL.createObjectURL(new Blob([JSON.stringify(n)], {
                            type: "application/json"
                        })),
                        r = null == this.modelJsonAnchor ? document.createElement("a") : this.modelJsonAnchor;
                    if (r.download = this.modelJsonFileName, r.href = s, await Da((() => r.dispatchEvent(new MouseEvent("click")))), null != e.weightData) {
                        const e = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor;
                        e.download = this.weightDataFileName, e.href = t, await Da((() => e.dispatchEvent(new MouseEvent("click"))))
                    }
                    return {
                        modelArtifactsInfo: Qr(e)
                    }
                }
            }
        }
        _a.URL_SCHEME = "downloads://";

        function Oa(e, t, n, s) {
            ! function(e) {
                R(null != e && Array.isArray(e) && e.length > 0, (() => "promises must be a none empty array"))
            }(e),
            function(e, t) {
                R(e >= 0 && e <= 1, (() => `Progress fraction must be in range [0, 1], but got startFraction ${e}`)), R(t >= 0 && t <= 1, (() => `Progress fraction must be in range [0, 1], but got endFraction ${t}`)), R(t >= e, (() => `startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))
            }(n = null == n ? 0 : n, s = null == s ? 1 : s);
            let r = 0;
            return Promise.all(e.map((a => (a.then((a => {
                const i = n + ++r / e.length * (s - n);
                return t(i), a
            })), a))))
        }
        async function Ma(e, t) {
            null == t && (t = {});
            const n = null == t.fetchFunc ? de().platform.fetch : t.fetchFunc,
                s = e.map((e => n(e, t.requestInit, {
                    isBinary: !0
                }))),
                r = (null == t.onProgress ? await Promise.all(s) : await Oa(s, t.onProgress, 0, .5)).map((e => e.arrayBuffer()));
            return null == t.onProgress ? await Promise.all(r) : await Oa(r, t.onProgress, .5, 1)
        }
        ta.registerSaveRouter((e => de().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(_a.URL_SCHEME) ? function(e = "model") {
            return new _a(e)
        }(e.slice(_a.URL_SCHEME.length)) : null));
        class La {
            constructor(e, t) {
                if (this.DEFAULT_METHOD = "POST", null == t && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, this.weightUrlConverter = t.weightUrlConverter, null != t.fetchFunc ? (R("function" == typeof t.fetchFunc, (() => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")), this.fetch = t.fetchFunc) : this.fetch = de().platform.fetch, R(null != e && e.length > 0, (() => "URL path for http must not be null, undefined or empty.")), Array.isArray(e) && R(2 === e.length, (() => `URL paths for http must have a length of 2, (actual length is ${e.length}).`)), this.path = e, null != t.requestInit && null != t.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
                this.requestInit = t.requestInit || {}
            }
            async save(e) {
                if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                const t = Object.assign({
                    method: this.DEFAULT_METHOD
                }, this.requestInit);
                t.body = new FormData;
                const n = Jr(e, [{
                    paths: ["./model.weights.bin"],
                    weights: e.weightSpecs
                }]);
                t.body.append("model.json", new Blob([JSON.stringify(n)], {
                    type: "application/json"
                }), "model.json"), null != e.weightData && t.body.append("model.weights.bin", new Blob([e.weightData], {
                    type: "application/octet-stream"
                }), "model.weights.bin");
                const s = await this.fetch(this.path, t);
                if (s.ok) return {
                    modelArtifactsInfo: Qr(e),
                    responses: [s]
                };
                throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)
            }
            async load() {
                const e = await this.fetch(this.path, this.requestInit);
                if (!e.ok) throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);
                let t;
                try {
                    t = await e.json()
                } catch (e) {
                    let t = `Failed to parse model JSON of response from ${this.path}.`;
                    throw this.path.endsWith(".pb") ? t += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : t += " Please make sure the server is serving valid JSON for this request.", new Error(t)
                }
                const n = t.modelTopology,
                    s = t.weightsManifest;
                if (null == n && null == s) throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
                return Zr(t, (e => this.loadWeights(e)))
            }
            async loadWeights(e) {
                const t = Array.isArray(this.path) ? this.path[1] : this.path,
                    [n, s] = function(e) {
                        const t = e.lastIndexOf("/"),
                            n = e.lastIndexOf("?"),
                            s = e.substring(0, t),
                            r = n > t ? e.substring(n) : "";
                        return [s + "/", r]
                    }(t),
                    r = this.weightPathPrefix || n,
                    a = [];
                for (const t of e) a.push(...t.weights);
                const i = [],
                    o = [];
                for (const t of e)
                    for (const e of t.paths) null != this.weightUrlConverter ? o.push(this.weightUrlConverter(e)) : i.push(r + e + s);
                this.weightUrlConverter && i.push(...await Promise.all(o));
                return [a, Yr(await Ma(i, {
                    requestInit: this.requestInit,
                    fetchFunc: this.fetch,
                    onProgress: this.onProgress
                }))]
            }
        }

        function za(e) {
            return null != e.match(La.URL_SCHEME_REGEX)
        }
        La.URL_SCHEME_REGEX = /^https?:\/\//;
        const Ba = (e, t) => {
            if ("undefined" == typeof fetch && (null == t || null == t.fetchFunc)) return null;
            {
                let n = !0;
                if (n = Array.isArray(e) ? e.every((e => za(e))) : za(e), n) return Pa(e, t)
            }
            return null
        };

        function Pa(e, t) {
            return new La(e, t)
        }

        function Ua(e, t) {
            return Pa(e, t)
        }
        ta.registerSaveRouter(Ba), ta.registerLoadRouter(Ba);

        function Wa(e, t) {
            const n = e.length,
                s = [];
            for (let r = 0; r < n; r++) {
                const a = n - 1 - r,
                    i = e[a] || 1;
                (t[t.length - 1 - r] || 1) > 1 && 1 === i && s.unshift(a)
            }
            return s
        }

        function Va(e, t) {
            const n = [];
            for (let s = 0; s < t.length; s++) {
                const r = e[e.length - s - 1],
                    a = t.length - s - 1,
                    i = t[a];
                (null == r || 1 === r && i > 1) && n.unshift(a)
            }
            return n
        }

        function Ga(e, t) {
            const n = [],
                s = Math.max(e.length, t.length);
            for (let r = 0; r < s; r++) {
                let s = e[e.length - r - 1];
                null == s && (s = 1);
                let a = t[t.length - r - 1];
                if (null == a && (a = 1), 1 === s) n.unshift(a);
                else if (1 === a) n.unshift(s);
                else {
                    if (s !== a) {
                        throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)
                    }
                    n.unshift(s)
                }
            }
            return n
        }
        let Ha;

        function ja(e, t = 3) {
            if (t > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
            if (null == e) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
            let n = !1,
                s = !1,
                r = !1,
                a = !1,
                i = !1,
                o = !1;
            if (e.data instanceof Uint8Array) n = !0;
            else if ("undefined" != typeof ImageData && e instanceof ImageData) s = !0;
            else if ("undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) r = !0;
            else if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement) a = !0;
            else if (null != e.getContext) i = !0;
            else {
                if (!("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)) throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);
                o = !0
            }
            if (r) {
                const t = 2;
                if (r && e.readyState < t) throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")
            }
            if (null != $s(bs, Er.backendName)) {
                const n = {
                        pixels: e
                    },
                    s = {
                        numChannels: t
                    };
                return Er.runKernel(bs, n, s)
            }
            const [u, l] = r ? [e.videoWidth, e.videoHeight] : [e.width, e.height];
            let c, h;
            if (i) c = e.getContext("2d").getImageData(0, 0, u, l).data;
            else if (s || n) c = e.data;
            else if (a || r || o) {
                if (null == Ha)
                    if ("undefined" == typeof document) {
                        if ("undefined" == typeof OffscreenCanvas || "undefined" == typeof OffscreenCanvasRenderingContext2D) throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
                        Ha = new OffscreenCanvas(1, 1).getContext("2d")
                    } else Ha = document.createElement("canvas").getContext("2d");
                Ha.canvas.width = u, Ha.canvas.height = l, Ha.drawImage(e, 0, 0, u, l), c = Ha.getImageData(0, 0, u, l).data
            }
            if (4 === t) h = new Int32Array(c);
            else {
                const e = u * l;
                h = new Int32Array(e * t);
                for (let n = 0; n < e; n++)
                    for (let e = 0; e < t; ++e) h[n * t + e] = c[4 * n + e]
            }
            return function(e, t, n) {
                if (D(e), null != t && 3 !== t.length) throw new Error("tensor3d() requires shape to have three numbers");
                const s = Or(e, n);
                if (3 !== s.length && 1 !== s.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
                if (1 === s.length && null == t) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
                return Wr(e, t, s, n)
            }(h, [l, u, t], "int32")
        }
        Pr({
            fromPixels_: ja
        });
        const qa = -2,
            Ka = -1;

        function Xa(e, t, n) {
            const s = e.shape.length;
            R(s === t.length, (() => `Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)), R(s === n.length, (() => `Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`));
            for (let r = 0; r < s; ++r) R(t[r] + n[r] <= e.shape[r], (() => `Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`))
        }

        function Ya(e) {
            const t = [];
            let n = 0;
            for (; e > 0;) 1 & e && t.push(n), e /= 2, n++;
            return t
        }

        function Ja(e, t, n) {
            const s = [];
            for (let r = 0; r < e.length; r++) s[r] = Math.ceil((t[r] - e[r]) / n[r]);
            return s
        }

        function Za(e, t, n, s) {
            const r = [...e];
            for (let e = r.length; e < s.length; e++) r.push(1);
            for (let e = 0; e < n; e++) 0 === e ? r[t] = 1 : (r.splice(t, 0, 1), r.pop());
            return r
        }

        function Qa(e, t, n) {
            return n <= e ? n : n - (t - 1)
        }

        function ei(e, t) {
            const n = [];
            for (let s = 0; s < e; s++) n.push(t + s);
            return n
        }

        function ti(e, t, n, s, r, a, i, o, u) {
            const l = e.length;
            let c = new Array(l),
                h = new Array(l),
                p = new Array(l);
            if (t.length && n > 0) {
                const u = t[0],
                    l = n + 1;
                c = ni(i, u, l, s, e), h = si(o, u, l, r, e), p = Za(a, u, l, e)
            } else
                for (let t = 0; t < l; t++) c[t] = ai(i, s, a, e, t, u), h[t] = ii(o, r, a, e, t, u), p[t] = ri(a, t, u);
            return {
                begin: c,
                end: h,
                strides: p
            }
        }

        function ni(e, t, n, s, r) {
            const a = [...r],
                i = ei(n, t);
            for (let r = 0; r < a.length; r++)
                if (i.indexOf(r) > -1) a[r] = 0;
                else {
                    const i = Qa(t, n, r);
                    let o = s[i];
                    e & 1 << i && (o = 0), a[r] = o
                } return a
        }

        function si(e, t, n, s, r) {
            const a = [...r],
                i = ei(n, t);
            for (let r = 0; r < a.length; r++)
                if (i.indexOf(r) > -1) a[r] = Number.MAX_SAFE_INTEGER;
                else {
                    const i = Qa(t, n, r);
                    let o = s[i];
                    e & 1 << i && (o = Number.MAX_SAFE_INTEGER), a[r] = o
                } for (let e = 0; e < a.length; e++) {
                const t = r[e];
                a[e] < 0 && (a[e] += t), a[e] = C(0, a[e], r[e])
            }
            return a
        }

        function ri(e, t, n) {
            let s = e[t];
            return (n & 1 << t || null == s) && (s = 1), s
        }

        function ai(e, t, n, s, r, a) {
            let i = t[r];
            const o = n[r] || 1;
            (e & 1 << r || a & 1 << r || null == i) && (i = o > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
            const u = s[r];
            return i < 0 && (i += u), i = C(0, i, u - 1), i
        }

        function ii(e, t, n, s, r, a) {
            let i = t[r];
            const o = n[r] || 1;
            (e & 1 << r || a & 1 << r || null == i) && (i = o > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
            const u = s[r];
            return i < 0 && (i += u), i = o > 0 ? C(0, i, u) : C(-1, i, u - 1), i
        }

        function oi(e, t, n) {
            let s = n.length;
            for (let e = 0; e < n.length; e++)
                if (n[e] > 1) {
                    s = e;
                    break
                } for (let r = s + 1; r < n.length; r++)
                if (t[r] > 0 || n[r] !== e[r]) return !1;
            return !0
        }

        function ui(e, t) {
            let n = e.length > 0 ? e[e.length - 1] : 1;
            for (let s = 0; s < e.length - 1; s++) n += e[s] * t[s];
            return n
        }

        function li(e, t, n) {
            let s;
            const r = e.shape.length;
            let a;
            return s = "number" == typeof t ? [t, ...new Array(r - 1).fill(0)] : t.length < r ? t.concat(new Array(r - t.length).fill(0)) : t.slice(), s.forEach((e => {
                R(-1 !== e, (() => "slice() does not support negative begin indexing."))
            })), a = null == n ? new Array(r).fill(-1) : "number" == typeof n ? [n, ...new Array(r - 1).fill(-1)] : n.length < r ? n.concat(new Array(r - n.length).fill(-1)) : n, a = a.map(((t, n) => t >= 0 ? t : (R(-1 === t, (() => `Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)), e.shape[n] - s[n]))), [s, a]
        }

        function ci(e, t, n, s, r, a, i, o, u) {
            let l;
            if (null == s ? (l = new Array(t.length), l.fill(1)) : l = s, null != i && i & i - 1) throw new Error("Multiple ellipses in slice is not allowed.");
            let c = !1;
            const h = {
                dims: l.length,
                numAddAxisAfterEllipsis: 0,
                begin: t.slice(),
                end: n.slice(),
                strides: l.slice(),
                beginMask: r,
                endMask: a,
                ellipsisMask: i,
                newAxisMask: o,
                shrinkAxisMask: u
            };
            for (let e = 0; e < h.dims; e++) c && 1 << e & o && h.numAddAxisAfterEllipsis++, 1 << e & i && (c = !0);
            c || (h.ellipsisMask |= 1 << h.dims, h.dims++);
            const p = {
                dims: e.length,
                beginMask: 0,
                endMask: 0,
                beginValid: !1,
                endValid: !1
            };
            ! function(e, t) {
                t.beginMask = 0, t.endMask = 0, t.shrinkAxisMask = 0;
                let n = 0;
                t.beginValid = null != e.begin, t.endValid = null != e.end, t.begin = new Array(t.dims), t.end = new Array(t.dims), t.strides = new Array(t.dims), t.finalShapeGatherIndices = [], t.finalShapeGatherIndicesSparse = [], t.inputShapeGatherIndicesSparse = new Array(t.dims);
                for (let s = 0; s < e.dims; s++)
                    if (1 << s & e.ellipsisMask) {
                        const r = Math.min(t.dims - (e.dims - s) + 1 + e.numAddAxisAfterEllipsis, t.dims);
                        for (; n < r; n++) t.begin[n] = 0, t.end[n] = 0, t.strides[n] = 1, t.beginMask |= 1 << n, t.endMask |= 1 << n, t.finalShapeGatherIndices.push(n), t.finalShapeGatherIndicesSparse.push(-1), t.inputShapeGatherIndicesSparse[n] = s
                    } else if (1 << s & e.newAxisMask) t.finalShapeGatherIndices.push(qa), t.finalShapeGatherIndicesSparse.push(-1);
                else {
                    if (n === t.begin.length) throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);
                    null != e.begin && (t.begin[n] = e.begin[s]), null != e.end && (t.end[n] = e.end[s]), t.strides[n] = e.strides[s], e.beginMask & 1 << s && (t.beginMask |= 1 << n), e.endMask & 1 << s && (t.endMask |= 1 << n), e.shrinkAxisMask & 1 << s ? (t.finalShapeGatherIndices.push(Ka), t.finalShapeGatherIndicesSparse.push(-1), t.shrinkAxisMask |= 1 << n) : (t.finalShapeGatherIndices.push(n), t.finalShapeGatherIndicesSparse.push(s)), t.inputShapeGatherIndicesSparse[n] = s, n++
                }
            }(h, p);
            let d = !0,
                f = !0,
                m = !0;
            const g = [],
                y = [];
            for (let t = 0; t < e.length; ++t) {
                if (0 === p.strides[t]) throw Error(`strides[${t}] must be non-zero`);
                const n = !!(p.shrinkAxisMask & 1 << t),
                    s = e[t];
                if (-1 === s) {
                    g.push(n ? 1 : -1);
                    continue
                }
                const r = [p.beginMask & 1 << t, p.endMask & 1 << t],
                    a = [p.strides[t] > 0 ? 0 : -1, p.strides[t] > 0 ? s : s - 1];
                if (n && p.strides[t] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
                m = m && 1 === p.strides[t];
                const i = !!(p.beginMask & 1 << t && p.endMask & 1 << t);
                if (p.beginValid && p.endValid) {
                    if (n) {
                        const e = p.begin[t] < 0 ? s + p.begin[t] : p.begin[t];
                        if (p.begin[t] = e, p.end[t] = p.begin[t] + 1, e < 0 || e >= s) throw Error(`slice index ${p.begin[t]} of dimension ${t} out of bounds.`)
                    } else p.begin[t] = hi(p.begin[t], 0, p.strides[t], s, r, a), p.end[t] = hi(p.end[t], 1, p.strides[t], s, r, a);
                    const e = 1 === p.strides[t] && 0 === p.begin[t] && p.end[t] === s;
                    d = d && e, f = f && (0 === t && 1 === p.strides[t] || e)
                } else d = d && 1 === p.strides[t] && i, f = f && (0 === t && 1 === p.strides[t] || i);
                let o, u = !1;
                if (p.beginValid && p.endValid ? (o = p.end[t] - p.begin[t], u = !0) : n ? (o = 1, u = !0) : i && s >= 0 && (o = p.strides[t] < 0 ? -s : s, u = !0), u) {
                    let e;
                    e = 0 === o || o < 0 != p.strides[t] < 0 ? 0 : Math.trunc(o / p.strides[t]) + (o % p.strides[t] != 0 ? 1 : 0), g.push(e)
                } else g.push(-1)
            }
            for (let e = 0; e < p.finalShapeGatherIndices.length; ++e) {
                const t = p.finalShapeGatherIndices[e];
                t >= 0 ? y.push(g[t]) : t === qa && y.push(1)
            }
            return {
                finalShapeSparse: y.filter(((e, t) => p.finalShapeGatherIndices[t] !== qa)),
                finalShape: y,
                isIdentity: d,
                sliceDim0: f,
                isSimpleSlice: m,
                begin: p.begin,
                end: p.end,
                strides: p.strides
            }
        }

        function hi(e, t, n, s, r, a) {
            if (r[t]) return n > 0 ? a[t] : a[t + 1 & 1];
            {
                const t = e < 0 ? s + e : e;
                return t < a[0] ? a[0] : t > a[1] ? a[1] : t
            }
        }
        class pi {
            getClassName() {
                return this.constructor.className
            }
            static fromConfig(e, t) {
                return new e(t)
            }
        }
        class di {
            constructor() {
                this.classNameMap = {}
            }
            static getMap() {
                return null == di.instance && (di.instance = new di), di.instance
            }
            static register(e) {
                di.getMap().classNameMap[e.className] = [e, e.fromConfig]
            }
        }

        function fi(e) {
            R(null != e.className, (() => "Class being registered does not have the static className property defined.")), R("string" == typeof e.className, (() => "className is required to be a string, but got type " + typeof e.className)), R(e.className.length > 0, (() => "Class being registered has an empty-string as its className, which is disallowed.")), di.register(e)
        }

        function mi() {
            return Er
        }

        function gi() {
            return Er.memory()
        }

        function yi(e, t) {
            return Er.tidy(e, t)
        }

        function bi(e) {
            Ir(e).forEach((e => e.dispose()))
        }

        function xi(e) {
            return Er.keep(e)
        }

        function wi(e, t, n = 1) {
            return Er.registerBackend(e, t, n)
        }

        function ki(e) {
            return Er.customGrad(e)
        }

        function vi(e, t) {
            if ((q(e) && "string" !== t || Array.isArray(e)) && "complex64" !== t) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
            if ("string" === t && q(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
            return Wr(e, [], [], t)
        }
        lr = function(e) {
            de().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
        };
        class Ii extends pi {
            minimize(e, t = !1, n) {
                const {
                    value: s,
                    grads: r
                } = this.computeGradients(e, n);
                if (null != n) {
                    const e = n.map((e => ({
                        name: e.name,
                        tensor: r[e.name]
                    })));
                    this.applyGradients(e)
                } else this.applyGradients(r);
                return bi(r), t ? s : (s.dispose(), null)
            }
            get iterations() {
                return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
            }
            incrementIterations() {
                this.iterations_ = this.iterations + 1
            }
            computeGradients(e, t) {
                return function(e, t) {
                    R(Z(e), (() => "The f passed in variableGrads(f) must be a function")), R(null == t || Array.isArray(t) && t.every((e => e instanceof pr)), (() => "The varList passed in variableGrads(f, varList) must be an array of variables"));
                    const n = null != t;
                    if (!n) {
                        t = [];
                        for (const e in Er.registeredVariables) t.push(Er.registeredVariables[e])
                    }
                    const s = n ? t.filter((e => !e.trainable)) : null,
                        r = t.length;
                    t = t.filter((e => e.trainable)), R(t.length > 0, (() => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`));
                    const {
                        value: a,
                        grads: i
                    } = Er.gradients(e, t, null, !0);
                    R(i.some((e => null != e)), (() => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")), R(0 === a.rank, (() => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));
                    const o = {};
                    return t.forEach(((e, t) => {
                        null != i[t] && (o[e.name] = i[t])
                    })), null != s && s.forEach((e => o[e.name] = null)), {
                        value: a,
                        grads: o
                    }
                }(e, t)
            }
            dispose() {
                null != this.iterations_ && bi(this.iterations_)
            }
            async saveIterations() {
                return null == this.iterations_ && (this.iterations_ = 0), {
                    name: "iter",
                    tensor: vi(this.iterations_, "int32")
                }
            }
            async getWeights() {
                throw new Error("getWeights() is not implemented for this optimizer yet.")
            }
            async setWeights(e) {
                throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)
            }
            async extractIterations(e) {
                return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1)
            }
        }
        Object.defineProperty(Ii, Symbol.hasInstance, {
            value: e => null != e.minimize && null != e.computeGradients && null != e.applyGradients
        });
        const Ni = Pr({
            abs_: function(e) {
                const t = zr(e, "x", "abs");
                if ("complex64" === t.dtype) {
                    const e = {
                        x: t
                    };
                    return Er.runKernel(Ge, e)
                } {
                    const e = {
                        x: t
                    };
                    return Er.runKernel(be, e)
                }
            }
        });
        const Si = Pr({
            add_: function(e, t) {
                let n = zr(e, "a", "add"),
                    s = zr(t, "b", "add");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(ke, r)
            }
        });
        const Ti = Pr({
            all_: function(e, t = null, n = !1) {
                const s = {
                        x: zr(e, "x", "all", "bool")
                    },
                    r = {
                        axis: t,
                        keepDims: n
                    };
                return Er.runKernel(Ie, s, r)
            }
        });
        const $i = Pr({
            any_: function(e, t = null, n = !1) {
                const s = {
                        x: zr(e, "x", "any", "bool")
                    },
                    r = {
                        axis: t,
                        keepDims: n
                    };
                return Er.runKernel(Ne, s, r)
            }
        });
        const Ci = Pr({
            argMax_: function(e, t = 0) {
                const n = {
                        x: zr(e, "x", "argMax")
                    },
                    s = {
                        axis: t
                    };
                return Er.runKernel(Se, n, s)
            }
        });

        function Ei(e, t, n, s, r = "NHWC", a) {
            return Fi(e, [...t, e[3]], n, a, s, null, null, Ui(r))
        }

        function Ai(e, t, n, s, r, a, i = "channelsLast") {
            const [o, u] = Oi(t);
            let l;
            if ("channelsLast" === i) l = [o, u, e[3], e[3]];
            else {
                if ("channelsFirst" !== i) throw new Error(`Unknown dataFormat ${i}`);
                l = [o, u, e[1], e[1]]
            }
            return Fi(e, l, n, s, r, a, !1, i)
        }

        function Ri(e, t, n, s, r, a, i = "NDHWC") {
            const [o, u, l] = Mi(t);
            let c, h;
            if ("NDHWC" === i) h = "channelsLast", c = [o, u, l, e[4], e[4]];
            else {
                if ("NCDHW" !== i) throw new Error(`Unknown dataFormat ${i}`);
                h = "channelsFirst", c = [o, u, l, e[1], e[1]]
            }
            return Di(e, c, n, s, r, !1, h, a)
        }

        function Fi(e, t, n, s, r, a, i = !1, o = "channelsLast") {
            let [u, l, c, h] = [-1, -1, -1, -1];
            if ("channelsLast" === o)[u, l, c, h] = e;
            else {
                if ("channelsFirst" !== o) throw new Error(`Unknown dataFormat ${o}`);
                [u, h, l, c] = e
            }
            const [p, d, , f] = t, [m, g] = Oi(n), [y, b] = Oi(s), x = Li(p, y), w = Li(d, b), {
                padInfo: k,
                outHeight: v,
                outWidth: I
            } = function(e, t, n, s, r, a, i, o, u) {
                let l, c, h;
                if ("number" == typeof e) {
                    l = {
                        top: e,
                        bottom: e,
                        left: e,
                        right: e,
                        type: 0 === e ? "VALID" : "NUMBER"
                    };
                    const r = function(e, t, n, s, r) {
                        null == s && (s = _i(e, t, n));
                        const a = e[0],
                            i = e[1],
                            o = zi((a - t + 2 * s) / n + 1, r),
                            u = zi((i - t + 2 * s) / n + 1, r);
                        return [o, u]
                    }([t, n], a, s, e, o);
                    c = r[0], h = r[1]
                } else if ("same" === e) {
                    c = Math.ceil(t / s), h = Math.ceil(n / r);
                    const e = Math.max(0, (c - 1) * s + a - t),
                        o = Math.max(0, (h - 1) * r + i - n),
                        u = Math.floor(e / 2),
                        p = e - u,
                        d = Math.floor(o / 2);
                    l = {
                        top: u,
                        bottom: p,
                        left: d,
                        right: o - d,
                        type: "SAME"
                    }
                } else if ("valid" === e) l = {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    type: "VALID"
                }, c = Math.ceil((t - a + 1) / s), h = Math.ceil((n - i + 1) / r);
                else {
                    if ("object" != typeof e) throw Error(`Unknown padding parameter: ${e}`);
                    {
                        const p = "channelsLast" === u ? e[1][0] : e[2][0],
                            d = "channelsLast" === u ? e[1][1] : e[2][1],
                            f = "channelsLast" === u ? e[2][0] : e[3][0],
                            m = "channelsLast" === u ? e[2][1] : e[3][1];
                        l = {
                            top: p,
                            bottom: d,
                            left: f,
                            right: m,
                            type: 0 === p && 0 === d && 0 === f && 0 === m ? "VALID" : "EXPLICIT"
                        }, c = zi((t - a + p + d) / s + 1, o), h = zi((n - i + f + m) / r + 1, o)
                    }
                }
                return {
                    padInfo: l,
                    outHeight: c,
                    outWidth: h
                }
            }(r, l, c, m, g, x, w, a, o), N = i ? f * h : f;
            let S;
            return "channelsFirst" === o ? S = [u, N, v, I] : "channelsLast" === o && (S = [u, v, I, N]), {
                batchSize: u,
                dataFormat: o,
                inHeight: l,
                inWidth: c,
                inChannels: h,
                outHeight: v,
                outWidth: I,
                outChannels: N,
                padInfo: k,
                strideHeight: m,
                strideWidth: g,
                filterHeight: p,
                filterWidth: d,
                effectiveFilterHeight: x,
                effectiveFilterWidth: w,
                dilationHeight: y,
                dilationWidth: b,
                inShape: e,
                outShape: S,
                filterShape: t
            }
        }

        function Di(e, t, n, s, r, a = !1, i = "channelsLast", o) {
            let [u, l, c, h, p] = [-1, -1, -1, -1, -1];
            if ("channelsLast" === i)[u, l, c, h, p] = e;
            else {
                if ("channelsFirst" !== i) throw new Error(`Unknown dataFormat ${i}`);
                [u, p, l, c, h] = e
            }
            const [d, f, m, , g] = t, [y, b, x] = Mi(n), [w, k, v] = Mi(s), I = Li(d, w), N = Li(f, k), S = Li(m, v), {
                padInfo: T,
                outDepth: $,
                outHeight: C,
                outWidth: E
            } = function(e, t, n, s, r, a, i, o, u, l, c) {
                let h, p, d, f;
                if ("number" == typeof e) {
                    h = {
                        top: e,
                        bottom: e,
                        left: e,
                        right: e,
                        front: e,
                        back: e,
                        type: 0 === e ? "VALID" : "NUMBER"
                    };
                    const a = function(e, t, n, s, r, a) {
                        null == r && (r = _i(e, t, s));
                        const i = e[0],
                            o = e[1],
                            u = e[2],
                            l = zi((i - t + 2 * r) / s + 1, a),
                            c = zi((o - t + 2 * r) / s + 1, a),
                            h = zi((u - t + 2 * r) / s + 1, a);
                        return [l, c, h, n]
                    }([t, n, s, 1], o, 1, r, e, c);
                    p = a[0], d = a[1], f = a[2]
                } else if ("same" === e) {
                    p = Math.ceil(t / r), d = Math.ceil(n / a), f = Math.ceil(s / i);
                    const e = (p - 1) * r + o - t,
                        c = (d - 1) * a + u - n,
                        m = (f - 1) * i + l - s,
                        g = Math.floor(e / 2),
                        y = e - g,
                        b = Math.floor(c / 2),
                        x = c - b,
                        w = Math.floor(m / 2);
                    h = {
                        top: b,
                        bottom: x,
                        left: w,
                        right: m - w,
                        front: g,
                        back: y,
                        type: "SAME"
                    }
                } else {
                    if ("valid" !== e) throw Error(`Unknown padding parameter: ${e}`);
                    h = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        front: 0,
                        back: 0,
                        type: "VALID"
                    }, p = Math.ceil((t - o + 1) / r), d = Math.ceil((n - u + 1) / a), f = Math.ceil((s - l + 1) / i)
                }
                return {
                    padInfo: h,
                    outDepth: p,
                    outHeight: d,
                    outWidth: f
                }
            }(r, l, c, h, y, b, x, I, N, S, o), A = a ? g * p : g;
            let R;
            return "channelsFirst" === i ? R = [u, A, $, C, E] : "channelsLast" === i && (R = [u, $, C, E, A]), {
                batchSize: u,
                dataFormat: i,
                inDepth: l,
                inHeight: c,
                inWidth: h,
                inChannels: p,
                outDepth: $,
                outHeight: C,
                outWidth: E,
                outChannels: A,
                padInfo: T,
                strideDepth: y,
                strideHeight: b,
                strideWidth: x,
                filterDepth: d,
                filterHeight: f,
                filterWidth: m,
                effectiveFilterDepth: I,
                effectiveFilterHeight: N,
                effectiveFilterWidth: S,
                dilationDepth: w,
                dilationHeight: k,
                dilationWidth: v,
                inShape: e,
                outShape: R,
                filterShape: t
            }
        }

        function _i(e, t, n, s = 1) {
            const r = Li(t, s);
            return Math.floor((e[0] * (n - 1) - n + r) / 2)
        }

        function Oi(e) {
            return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e
        }

        function Mi(e) {
            return "number" == typeof e ? [e, e, e] : e
        }

        function Li(e, t) {
            return t <= 1 ? e : e + (e - 1) * (t - 1)
        }

        function zi(e, t) {
            if (!t) return Math.trunc(e);
            switch (t) {
                case "round":
                    return Math.round(e);
                case "ceil":
                    return Math.ceil(e);
                case "floor":
                    return Math.floor(e);
                default:
                    throw new Error(`Unknown roundingMode ${t}`)
            }
        }

        function Bi(e) {
            const [t, n, s] = Oi(e);
            return 1 === t && 1 === n && 1 === s
        }

        function Pi(e, t) {
            return Bi(e) || Bi(t)
        }

        function Ui(e) {
            if ("NHWC" === e) return "channelsLast";
            if ("NCHW" === e) return "channelsFirst";
            throw new Error(`Unknown dataFormat ${e}`)
        }

        function Wi(e, t, n) {
            if (null != n) {
                if ("string" == typeof t) throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);
                if ("number" == typeof t) R(L(t), (() => `Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));
                else {
                    if ("object" != typeof t) throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);
                    t.forEach((t => {
                        t.forEach((t => {
                            R(L(t), (() => `Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))
                        }))
                    }))
                }
            }
        }
        const Vi = Pr({
            reshape_: function(e, t) {
                const n = {
                        x: zr(e, "x", "reshape", "string_or_numeric")
                    },
                    s = {
                        shape: t
                    };
                return Er.runKernel(Sn, n, s)
            }
        });
        const Gi = Pr({
            avgPool_: function(e, t, n, s, r) {
                const a = zr(e, "x", "avgPool", "float32");
                R(Pi(n, 1), (() => `Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));
                let i = a,
                    o = !1;
                3 === a.rank && (o = !0, i = Vi(a, [1, a.shape[0], a.shape[1], a.shape[2]])), R(4 === i.rank, (() => `Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)), Wi("avgPool", s, r);
                const u = {
                        x: i
                    },
                    l = {
                        filterSize: t,
                        strides: n,
                        pad: s,
                        dimRoundingMode: r
                    };
                let c = Er.runKernel(Fe, u, l);
                return c = Ra(c, a.dtype), o ? Vi(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
            }
        });
        const Hi = Pr({
            avgPool3d_: function(e, t, n, s, r, a = "NDHWC") {
                const i = zr(e, "x", "avgPool3d", "float32");
                let o = i,
                    u = !1;
                4 === i.rank && (u = !0, o = Vi(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), R(5 === o.rank, (() => `Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)), R("NDHWC" === a, (() => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)), Wi("avgPool3d", s, r);
                const l = {
                        x: o
                    },
                    c = {
                        filterSize: t,
                        strides: n,
                        pad: s,
                        dimRoundingMode: r,
                        dataFormat: a
                    };
                let h = Er.runKernel(_e, l, c);
                return h = Ra(h, o.dtype), u ? Vi(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
            }
        });
        const ji = Pr({
            batchNorm_: function(e, t, n, s, r, a) {
                null == a && (a = .001);
                const i = zr(e, "x", "batchNorm"),
                    o = zr(t, "mean", "batchNorm"),
                    u = zr(n, "variance", "batchNorm");
                let l, c;
                null != r && (l = zr(r, "scale", "batchNorm")), null != s && (c = zr(s, "offset", "batchNorm")), R(o.rank === u.rank, (() => "Batch normalization gradient requires mean and variance to have equal ranks.")), R(null == c || o.rank === c.rank, (() => "Batch normalization gradient requires mean and offset to have equal ranks.")), R(null == l || o.rank === l.rank, (() => "Batch normalization gradient requires mean and scale to have equal ranks."));
                const h = {
                        x: function(e) {
                            let t;
                            return t = 0 === e.rank || 1 === e.rank ? Vi(e, [1, 1, 1, e.size]) : 2 === e.rank ? Vi(e, [1, 1, e.shape[0], e.shape[1]]) : 3 === e.rank ? Vi(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : e, t
                        }(i),
                        scale: l,
                        offset: c,
                        mean: o,
                        variance: u
                    },
                    p = {
                        varianceEpsilon: a
                    },
                    d = Er.runKernel(Tt, h, p);
                return Vi(d, i.shape)
            }
        });
        const qi = Pr({
            batchNorm2d_: function(e, t, n, s, r, a) {
                const i = zr(e, "x", "batchNorm"),
                    o = zr(t, "mean", "batchNorm"),
                    u = zr(n, "variance", "batchNorm");
                let l, c;
                return null != r && (l = zr(r, "scale", "batchNorm")), null != s && (c = zr(s, "offset", "batchNorm")), R(2 === i.rank, (() => `Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)), R(2 === o.rank || 1 === o.rank, (() => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)), R(2 === u.rank || 1 === u.rank, (() => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`)), null != l && R(2 === l.rank || 1 === l.rank, (() => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)), null != c && R(2 === c.rank || 1 === c.rank, (() => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)), ji(i, o, u, c, l, a)
            }
        });
        const Ki = Pr({
            batchNorm3d_: function(e, t, n, s, r, a) {
                const i = zr(e, "x", "batchNorm"),
                    o = zr(t, "mean", "batchNorm"),
                    u = zr(n, "variance", "batchNorm");
                let l, c;
                return null != r && (l = zr(r, "scale", "batchNorm")), null != s && (c = zr(s, "offset", "batchNorm")), R(3 === i.rank, (() => `Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)), R(3 === o.rank || 1 === o.rank, (() => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)), R(3 === u.rank || 1 === u.rank, (() => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`)), null != l && R(3 === l.rank || 1 === l.rank, (() => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)), null != c && R(3 === c.rank || 1 === c.rank, (() => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)), ji(i, o, u, c, l, a)
            }
        });
        const Xi = Pr({
            batchNorm4d_: function(e, t, n, s, r, a) {
                const i = zr(e, "x", "batchNorm"),
                    o = zr(t, "mean", "batchNorm"),
                    u = zr(n, "variance", "batchNorm");
                let l, c;
                return null != r && (l = zr(r, "scale", "batchNorm")), null != s && (c = zr(s, "offset", "batchNorm")), R(4 === i.rank, (() => `Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)), R(4 === o.rank || 1 === o.rank, (() => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)), R(4 === u.rank || 1 === u.rank, (() => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`)), null != l && R(4 === l.rank || 1 === l.rank, (() => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)), null != c && R(4 === c.rank || 1 === c.rank, (() => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)), ji(i, o, u, c, l, a)
            }
        });
        const Yi = Pr({
            clipByValue_: function(e, t, n) {
                const s = zr(e, "x", "clipByValue");
                R(t <= n, (() => `Error in clip: min (${t}) must be less than or equal to max (${n}).`));
                const r = {
                        x: s
                    },
                    a = {
                        clipValueMin: t,
                        clipValueMax: n
                    };
                return Er.runKernel(We, r, a)
            }
        });
        const Ji = Pr({
            concat_: function(e, t = 0) {
                R(e.length >= 1, (() => "Pass at least one tensor to concat"));
                const n = Br(e, "tensors", "concat", "string_or_numeric");
                if ("complex64" === n[0].dtype && n.forEach((e => {
                        if ("complex64" !== e.dtype) throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)
                    })), 1 === n.length) return Fa(n[0]);
                const s = n,
                    r = {
                        axis: t
                    };
                return Er.runKernel(He, s, r)
            }
        });
        const Zi = Pr({
            concat1d_: function(e) {
                return Ji(e, 0)
            }
        });
        const Qi = Pr({
            concat2d_: function(e, t) {
                return Ji(e, t)
            }
        });
        const eo = Pr({
            concat3d_: function(e, t) {
                return Ji(e, t)
            }
        });
        const to = Pr({
            concat4d_: function(e, t) {
                return Ji(e, t)
            }
        });
        const no = Pr({
            conv2d_: function(e, t, n, s, r = "NHWC", a = [1, 1], i) {
                const o = zr(e, "x", "conv2d", "float32"),
                    u = zr(t, "filter", "conv2d", "float32");
                let l = o,
                    c = !1;
                3 === o.rank && (c = !0, l = Vi(o, [1, o.shape[0], o.shape[1], o.shape[2]])), R(4 === l.rank, (() => `Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)), R(4 === u.rank, (() => `Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)), Wi("conv2d", s, i);
                const h = "NHWC" === r ? l.shape[3] : l.shape[1];
                R(h === u.shape[2], (() => `Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`)), R(Pi(n, a), (() => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));
                const p = {
                        x: l,
                        filter: u
                    },
                    d = {
                        strides: n,
                        pad: s,
                        dataFormat: r,
                        dilations: a,
                        dimRoundingMode: i
                    },
                    f = Er.runKernel(je, p, d);
                return c ? Vi(f, [f.shape[1], f.shape[2], f.shape[3]]) : f
            }
        });
        const so = Pr({
            conv1d_: function(e, t, n, s, r = "NWC", a = 1, i) {
                const o = zr(e, "x", "conv1d"),
                    u = zr(t, "filter", "conv1d");
                let l = o,
                    c = !1;
                2 === o.rank && (c = !0, l = Vi(o, [1, o.shape[0], o.shape[1]])), R(3 === l.rank, (() => `Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)), R(3 === u.rank, (() => `Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)), Wi("conv1d", s, i), R(l.shape[2] === u.shape[1], (() => `Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`)), R(Pi(n, a), (() => `Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)), R("NWC" === r, (() => `Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`));
                const h = Vi(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
                    p = Vi(l, [l.shape[0], 1, l.shape[1], l.shape[2]]),
                    d = no(p, h, [1, n], s, "NHWC", [1, a], i);
                return Vi(d, c ? [d.shape[2], d.shape[3]] : [d.shape[0], d.shape[2], d.shape[3]])
            }
        });
        const ro = Pr({
            conv2DBackpropInput_: function(e, t, n, s, r, a = "NHWC", i) {
                R(e.length === t.rank, (() => `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));
                let o = e,
                    u = t,
                    l = !1;
                3 === t.rank && (l = !0, u = Vi(t, [1, t.shape[0], t.shape[1], t.shape[2]]), o = [1, e[0], e[1], e[2]]), R(4 === o.length, (() => `Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)), R(4 === u.rank, (() => `Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)), R(4 === n.rank, (() => `Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));
                const c = "NHWC" === a ? o[3] : o[1],
                    h = "NHWC" === a ? u.shape[3] : u.shape[1];
                R(c === n.shape[2], (() => `Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)), R(h === n.shape[3], (() => `Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)), Wi("conv2dDerInput", r, i);
                const p = {
                        dy: u,
                        filter: n
                    },
                    d = {
                        strides: s,
                        pad: r,
                        dataFormat: a,
                        dimRoundingMode: i,
                        inputShape: o
                    },
                    f = Er.runKernel(Ke, p, d);
                return l ? Vi(f, [f.shape[1], f.shape[2], f.shape[3]]) : f
            }
        });
        const ao = Pr({
            conv2dTranspose_: function(e, t, n, s, r, a) {
                const i = zr(e, "x", "conv2dTranspose"),
                    o = zr(t, "filter", "conv2dTranspose");
                return ro(n, i, o, s, r, "NHWC", a)
            }
        });
        const io = Pr({
            conv3d_: function(e, t, n, s, r = "NDHWC", a = [1, 1, 1]) {
                const i = zr(e, "x", "conv3d"),
                    o = zr(t, "filter", "conv3d");
                let u = i,
                    l = !1;
                4 === i.rank && (l = !0, u = Vi(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), R(5 === u.rank, (() => `Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)), R(5 === o.rank, (() => `Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)), R(u.shape[4] === o.shape[3], (() => `Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`)), R(Pi(n, a), (() => `Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)), R("NDHWC" === r, (() => `Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`));
                const c = {
                        x: u,
                        filter: o
                    },
                    h = {
                        strides: n,
                        pad: s,
                        dataFormat: r,
                        dilations: a
                    },
                    p = Er.runKernel(Xe, c, h);
                return l ? Vi(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
            }
        });
        const oo = Pr({
            conv3DBackpropInput_: function(e, t, n, s, r) {
                R(e.length === t.rank, (() => `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));
                let a = e,
                    i = t,
                    o = !1;
                4 === t.rank && (o = !0, i = Vi(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), a = [1, e[0], e[1], e[2], e[3]]);
                const u = a[4],
                    l = i.shape[4];
                R(5 === a.length, (() => `Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)), R(5 === i.rank, (() => `Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)), R(5 === n.rank, (() => `Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)), R(u === n.shape[3], (() => `Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)), R(l === n.shape[4], (() => `Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));
                const c = {
                        dy: i,
                        filter: n
                    },
                    h = {
                        pad: r,
                        strides: s,
                        inputShape: a
                    },
                    p = Er.runKernel(Je, c, h);
                return o ? Vi(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
            }
        });
        const uo = Pr({
            conv3dTranspose_: function(e, t, n, s, r) {
                const a = zr(e, "x", "conv3dTranspose"),
                    i = zr(t, "filter", "conv3dTranspose");
                return oo(n, a, i, s, r)
            }
        });
        const lo = Pr({
            depthwiseConv2d_: function(e, t, n, s, r = "NHWC", a = [1, 1], i) {
                const o = zr(e, "x", "depthwiseConv2d", "float32"),
                    u = zr(t, "filter", "depthwiseConv2d", "float32");
                let l = o,
                    c = !1;
                3 === o.rank && (c = !0, l = Vi(o, [1, o.shape[0], o.shape[1], o.shape[2]])), R(4 === l.rank, (() => `Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)), R(4 === u.rank, (() => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`)), R(l.shape[3] === u.shape[2], (() => `Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)), Wi("depthwiseConv2d", s, i);
                const h = {
                        x: l,
                        filter: u
                    },
                    p = {
                        strides: n,
                        pad: s,
                        dataFormat: r,
                        dilations: a,
                        dimRoundingMode: i
                    },
                    d = Er.runKernel(at, h, p);
                return c ? Vi(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
            }
        });
        const co = Pr({
            floorDiv_: function(e, t) {
                let n = zr(e, "a", "floorDiv"),
                    s = zr(t, "b", "floorDiv");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(St, r)
            }
        });
        const ho = Pr({
            div_: function(e, t) {
                let n = zr(e, "a", "div"),
                    s = zr(t, "b", "div");
                if ([n, s] = kr(n, s), "int32" === n.dtype && "int32" === s.dtype) return co(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(pt, r, {})
            }
        });
        const po = Pr({
            elu_: function(e) {
                const t = {
                    x: zr(e, "x", "elu", "float32")
                };
                return Er.runKernel(ft, t)
            }
        });
        const fo = Pr({
            equal_: function(e, t) {
                let n = zr(e, "a", "equal", "string_or_numeric"),
                    s = zr(t, "b", "equal", "string_or_numeric");
                [n, s] = kr(n, s), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(yt, r)
            }
        });
        const mo = Pr({
            exp_: function(e) {
                const t = {
                    x: zr(e, "x", "exp")
                };
                return Er.runKernel(bt, t)
            }
        });
        const go = Pr({
            expandDims_: function(e, t = 0) {
                const n = zr(e, "x", "expandDims", "string_or_numeric");
                R(t <= n.rank, (() => "Axis must be <= rank of the tensor"));
                const s = {
                        input: n
                    },
                    r = {
                        dim: t
                    };
                return Er.runKernel(xt, s, r)
            }
        });
        const yo = Pr({
            tile_: function(e, t) {
                const n = zr(e, "x", "tile", "string_or_numeric");
                R(n.rank === t.length, (() => `Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));
                const s = {
                        x: n
                    },
                    r = {
                        reps: t
                    };
                return Er.runKernel(ls, s, r)
            }
        });
        const bo = Pr({
            eye_: function(e, t, n, s = "float32") {
                null == t && (t = e);
                const r = Aa([e, t], s),
                    a = e <= t ? e : t;
                for (let e = 0; e < a; ++e) r.set(1, e, e);
                const i = Vi(r.toTensor(), [e, t]);
                if (null == n) return i;
                if (1 === n.length) return yo(go(i, 0), [n[0], 1, 1]);
                if (2 === n.length) return yo(go(go(i, 0), 0), [n[0], n[1], 1, 1]);
                if (3 === n.length) return yo(go(go(go(i, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
                throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)
            }
        });

        function xo(e, t, n) {
            const s = {
                shape: e,
                value: t,
                dtype: n
            };
            return Er.runKernel(vt, {}, s)
        }
        const wo = Pr({
            floor_: function(e) {
                const t = {
                    x: zr(e, "x", "floor", "float32")
                };
                return Er.runKernel(Nt, t)
            }
        });
        const ko = Pr({
            gather_: function(e, t, n = 0, s = 0) {
                const r = {
                        x: zr(e, "x", "gather"),
                        indices: zr(t, "indices", "gather", "int32")
                    },
                    a = {
                        axis: n,
                        batchDims: s
                    };
                return Er.runKernel($t, r, a)
            }
        });
        const vo = Pr({
            greater_: function(e, t) {
                let n = zr(e, "a", "greater", "string_or_numeric"),
                    s = zr(t, "b", "greater", "string_or_numeric");
                [n, s] = kr(n, s), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(Et, r)
            }
        });
        const Io = Pr({
            greaterEqual_: function(e, t) {
                let n = zr(e, "a", "greaterEqual", "string_or_numeric"),
                    s = zr(t, "b", "greaterEqual", "string_or_numeric");
                [n, s] = kr(n, s), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(At, r)
            }
        });
        const No = Pr({
            leakyRelu_: function(e, t = .2) {
                const n = {
                        x: zr(e, "x", "leakyRelu")
                    },
                    s = {
                        alpha: t
                    };
                return Er.runKernel(Lt, n, s)
            }
        });
        const So = Pr({
            log_: function(e) {
                const t = {
                    x: zr(e, "x", "log", "float32")
                };
                return Er.runKernel(Ut, t)
            }
        });
        const To = Pr({
            log1p_: function(e) {
                const t = {
                    x: zr(e, "x", "log1p")
                };
                return Er.runKernel(Wt, t)
            }
        });
        const $o = Pr({
            max_: function(e, t = null, n = !1) {
                const s = {
                        x: zr(e, "x", "max")
                    },
                    r = {
                        reductionIndices: t,
                        keepDims: n
                    };
                return Er.runKernel(Kt, s, r)
            }
        });
        const Co = Pr({
            mul_: function(e, t) {
                let n = zr(e, "a", "mul"),
                    s = zr(t, "b", "mul");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(un, r)
            }
        });
        const Eo = Pr({
            sub_: function(e, t) {
                let n = zr(e, "a", "sub"),
                    s = zr(t, "b", "sub");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(is, r)
            }
        });
        const Ao = Pr({
            sum_: function(e, t = null, n = !1) {
                let s = zr(e, "x", "sum");
                "bool" === s.dtype && (s = Ra(s, "int32"));
                const r = {
                        x: s
                    },
                    a = {
                        axis: t,
                        keepDims: n
                    };
                return Er.runKernel(Hn, r, a)
            }
        });
        const Ro = Pr({
            logSoftmax_: function(e, t = -1) {
                const n = zr(e, "logits", "logSoftmax");
                if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);
                const s = ki(((e, n) => {
                    const s = $o(e, t, !0),
                        r = Eo(e, s),
                        a = Eo(Ra(r, "float32"), So(Ao(mo(r), t, !0)));
                    n([a]);
                    return {
                        value: a,
                        gradFunc: (e, n) => {
                            const [s] = n, r = mo(s);
                            return Eo(e, Co(Ao(e, t, !0), r))
                        }
                    }
                }));
                return s(n)
            }
        });
        const Fo = Pr({
            logicalAnd_: function(e, t) {
                const n = zr(e, "a", "logicalAnd", "bool"),
                    s = zr(t, "b", "logicalAnd", "bool");
                Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(Vt, r)
            }
        });
        const Do = Pr({
            matMul_: function(e, t, n = !1, s = !1) {
                let r = zr(e, "a", "matMul"),
                    a = zr(t, "b", "matMul");
                [r, a] = kr(r, a);
                const i = {
                        a: r,
                        b: a
                    },
                    o = {
                        transposeA: n,
                        transposeB: s
                    };
                return Er.runKernel(Me, i, o)
            }
        });
        const _o = Pr({
            maxPool_: function(e, t, n, s, r) {
                const a = zr(e, "x", "maxPool");
                let i = a,
                    o = !1;
                3 === a.rank && (o = !0, i = Vi(a, [1, a.shape[0], a.shape[1], a.shape[2]])), R(4 === i.rank, (() => `Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)), R(Pi(n, 1), (() => `Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)), Wi("maxPool", s, r);
                const u = {
                        x: i
                    },
                    l = {
                        filterSize: t,
                        strides: n,
                        pad: s,
                        dimRoundingMode: r
                    },
                    c = Er.runKernel(Yt, u, l);
                return o ? Vi(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
            }
        });
        const Oo = Pr({
            maxPool3d_: function(e, t = [1, 1, 1], n, s, r, a = "NDHWC") {
                const i = zr(e, "x", "maxPool3d");
                let o = i,
                    u = !1;
                4 === i.rank && (u = !0, o = Vi(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]])), R(5 === o.rank, (() => `Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)), R("NDHWC" === a, (() => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)), Wi("maxPool3d", s, r);
                const l = {
                        x: o
                    },
                    c = {
                        filterSize: t,
                        strides: n,
                        pad: s,
                        dimRoundingMode: r,
                        dataFormat: a
                    },
                    h = Er.runKernel(Zt, l, c);
                return u ? Vi(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
            }
        });
        const Mo = Pr({
            maximum_: function(e, t) {
                let n = zr(e, "a", "maximum"),
                    s = zr(t, "b", "maximum");
                [n, s] = kr(n, s), "bool" === n.dtype && (n = Ra(n, "int32"), s = Ra(s, "int32")), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(Xt, r)
            }
        });
        const Lo = Pr({
            mean_: function(e, t = null, n = !1) {
                const s = {
                        x: zr(e, "x", "mean")
                    },
                    r = {
                        axis: t,
                        keepDims: n
                    };
                return Er.runKernel(tn, s, r)
            }
        });
        const zo = Pr({
            minimum_: function(e, t) {
                let n = zr(e, "a", "minimum"),
                    s = zr(t, "b", "minimum");
                [n, s] = kr(n, s), "bool" === n.dtype && (n = Ra(n, "int32"), s = Ra(s, "int32")), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(sn, r)
            }
        });

        function Bo(e, t) {
            for (let n = 0; n < e.length; ++n)
                if (e[e.length - n - 1] !== t - 1 - n) return !1;
            return !0
        }

        function Po(e, t, n) {
            const s = e.length + t.length,
                r = [];
            let a = 0,
                i = 0;
            for (let o = 0; o < s; o++) - 1 === n.indexOf(o) ? r.push(e[a++]) : r.push(t[i++]);
            return r
        }

        function Uo(e, t) {
            const n = [],
                s = e.length;
            for (let r = 0; r < s; r++) - 1 === t.indexOf(r) && n.push(e[r]);
            return [n, t.map((t => e[t]))]
        }

        function Wo(e, t) {
            return Po(e, t.map((e => 1)), t)
        }

        function Vo(e, t, n) {
            R(Bo(t, n), (() => `${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))
        }

        function Go(e, t) {
            if (Bo(e, t)) return null;
            const n = [];
            for (let s = 0; s < t; ++s) - 1 === e.indexOf(s) && n.push(s);
            return e.forEach((e => n.push(e))), n
        }

        function Ho(e) {
            return e.map(((e, t) => [t, e])).sort(((e, t) => e[1] - t[1])).map((e => e[0]))
        }

        function jo(e, t) {
            const n = [];
            for (let s = t - e; s < t; ++s) n.push(s);
            return n
        }
        const qo = Pr({
            square_: function(e) {
                const t = zr(e, "x", "square");
                return Er.runKernel("Square", {
                    x: t
                }, {})
            }
        });
        const Ko = Pr({
            moments_: function(e, t = null, n = !1) {
                const s = W(t, (e = zr(e, "x", "moments")).shape),
                    r = Lo(e, s, n);
                let a = r.shape;
                n || (a = Wo(r.shape, s));
                const i = qo(Eo(Ra(e, "float32"), Vi(r, a)));
                return {
                    mean: r,
                    variance: Lo(i, s, n)
                }
            }
        });
        const Xo = Pr({
            neg_: function(e) {
                const t = {
                    x: zr(e, "x", "neg")
                };
                return Er.runKernel(ln, t)
            }
        });
        const Yo = Pr({
            notEqual_: function(e, t) {
                let n = zr(e, "a", "notEqual", "string_or_numeric"),
                    s = zr(t, "b", "notEqual", "string_or_numeric");
                [n, s] = kr(n, s), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(cn, r)
            }
        });
        const Jo = Pr({
            oneHot_: function(e, t, n = 1, s = 0) {
                if (t < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
                const r = {
                        indices: zr(e, "indices", "oneHot", "int32")
                    },
                    a = {
                        depth: t,
                        onValue: n,
                        offValue: s
                    };
                return Er.runKernel(mn, r, a)
            }
        });

        function Zo(e, t = "float32") {
            if ("complex64" === t) {
                const t = Zo(e, "float32"),
                    n = Zo(e, "float32");
                return Ur(t, n)
            }
            const n = re(O(e), t);
            return Er.makeTensor(n, e, t)
        }

        function Qo(e, t = "float32") {
            if ("complex64" === t) {
                const t = Qo(e, "float32"),
                    n = Zo(e, "float32");
                return Ur(t, n)
            }
            const n = se(O(e), t);
            return Er.makeTensor(n, e, t)
        }
        const eu = Pr({
            onesLike_: function(e) {
                const t = {
                    x: zr(e, "x", "onesLike")
                };
                return Er.runKernel(fn, t)
            }
        });
        const tu = Pr({
            pad_: function(e, t, n = 0) {
                const s = zr(e, "x", "pad");
                if (0 === s.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
                const r = {
                        paddings: t,
                        constantValue: n
                    },
                    a = {
                        x: s
                    };
                return Er.runKernel(yn, a, r)
            }
        });
        const nu = Pr({
            prelu_: function(e, t) {
                const n = {
                    x: zr(e, "x", "prelu"),
                    alpha: zr(t, "alpha", "prelu")
                };
                return Er.runKernel(xn, n)
            }
        });
        var su = n(264);
        class ru {
            constructor(e, t, n, s, r) {
                this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = s, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
                const a = r || Math.random();
                this.random = su.alea(a.toString())
            }
            nextValue() {
                if (!isNaN(this.nextVal)) {
                    const e = this.nextVal;
                    return this.nextVal = NaN, e
                }
                let e, t, n = !1;
                for (; !n;) {
                    let s, r, a;
                    do {
                        s = 2 * this.random() - 1, r = 2 * this.random() - 1, a = s * s + r * r
                    } while (a >= 1 || 0 === a);
                    const i = Math.sqrt(-2 * Math.log(a) / a);
                    e = this.mean + this.stdDev * s * i, t = this.mean + this.stdDev * r * i, this.truncated && !this.isValidTruncated(e) || (n = !0)
                }
                return this.truncated && !this.isValidTruncated(t) || (this.nextVal = this.convertValue(t)), this.convertValue(e)
            }
            convertValue(e) {
                return null == this.dtype || "float32" === this.dtype ? e : Math.round(e)
            }
            isValidTruncated(e) {
                return e <= this.upper && e >= this.lower
            }
        }
        class au {
            constructor(e = 0, t = 1, n, s) {
                if (this.canReturnFloat = () => null == this.dtype || "float32" === this.dtype, this.min = e, this.range = t - e, this.dtype = n, null == s && (s = Math.random()), "number" == typeof s && (s = s.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);
                this.random = su.alea(s)
            }
            convertValue(e) {
                return this.canReturnFloat() ? e : Math.round(e)
            }
            nextValue() {
                return this.convertValue(this.min + this.range * this.random())
            }
        }
        const iu = Pr({
            randomNormal_: function(e, t = 0, n = 1, s, r) {
                if (null != s && "bool" === s) throw new Error(`Unsupported data type ${s}`);
                const a = new ru(t, n, s, !1, r),
                    i = Aa(e, s);
                for (let e = 0; e < i.values.length; e++) i.values[e] = a.nextValue();
                return i.toTensor()
            }
        });
        const ou = Pr({
            randomUniform_: function(e, t = 0, n = 1, s = "float32", r) {
                const a = Aa(e, s),
                    i = new au(t, n, null, r);
                for (let e = 0; e < a.values.length; e++) a.values[e] = i.nextValue();
                return a.toTensor()
            }
        });
        const uu = Pr({
            relu_: function(e) {
                const t = {
                    x: zr(e, "x", "relu")
                };
                return Er.runKernel(Nn, t)
            }
        });
        const lu = Pr({
            reverse_: function(e, t) {
                const n = {
                        x: zr(e, "x", "reverse")
                    },
                    s = {
                        dims: t
                    };
                return Er.runKernel(Rn, n, s)
            }
        });
        const cu = Pr({
            selu_: function(e) {
                const t = {
                    x: zr(e, "x", "selu")
                };
                return Er.runKernel(Ln, t)
            }
        });
        const hu = Pr({
            separableConv2d_: function(e, t, n, s, r, a = [1, 1], i = "NHWC") {
                const o = zr(e, "x", "separableConv2d"),
                    u = zr(t, "depthwiseFilter", "separableConv2d"),
                    l = zr(n, "pointwiseFilter", "separableConv2d");
                let c = o,
                    h = !1;
                if (3 === o.rank && (h = !0, c = Vi(o, [1, o.shape[0], o.shape[1], o.shape[2]])), "NCHW" === i) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
                R(4 === c.rank, (() => `Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)), R(4 === u.rank, (() => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)), R(4 === l.rank, (() => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)), R(1 === l.shape[0], (() => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)), R(1 === l.shape[1], (() => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));
                const p = u.shape[2],
                    d = u.shape[3];
                R(l.shape[2] === p * d, (() => `Error in separableConv2d: the third dimension of pointwise filter must be ${p*d}, but got ${l.shape[2]}.`));
                const f = lo(c, u, s, r, i, a),
                    m = no(f, l, 1, "valid", i);
                return h ? Vi(m, [m.shape[1], m.shape[2], m.shape[3]]) : m
            }
        });
        const pu = Pr({
            sigmoid_: function(e) {
                const t = {
                    x: zr(e, "x", "sigmoid", "float32")
                };
                return Er.runKernel(Wn, t)
            }
        });
        const du = Pr({
            slice_: function(e, t, n) {
                const s = zr(e, "x", "slice", "string_or_numeric");
                if (0 === s.rank) throw new Error("Slicing scalar is not possible");
                const r = {
                        x: s
                    },
                    a = {
                        begin: t,
                        size: n
                    };
                return Er.runKernel(zn, r, a)
            }
        });
        const fu = Pr({
            slice1d_: function(e, t, n) {
                const s = zr(e, "x", "slice1d");
                return R(1 === s.rank, (() => `slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`)), du(s, [t], [n])
            }
        });
        const mu = Pr({
            slice2d_: function(e, t, n) {
                const s = zr(e, "x", "slice2d");
                return R(2 === s.rank, (() => `slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`)), du(s, t, n)
            }
        });
        const gu = Pr({
            slice3d_: function(e, t, n) {
                const s = zr(e, "x", "slice3d");
                return R(3 === s.rank, (() => `slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`)), du(s, t, n)
            }
        });
        const yu = Pr({
            slice4d_: function(e, t, n) {
                const s = zr(e, "x", "slice4d");
                return R(4 === s.rank, (() => `slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`)), du(s, t, n)
            }
        });
        const bu = Pr({
            softmax_: function(e, t = -1) {
                const n = zr(e, "logits", "softmax", "float32");
                if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);
                const s = {
                        logits: n
                    },
                    r = {
                        dim: t
                    };
                return Er.runKernel(Kn, s, r)
            }
        });
        const xu = Pr({
            softplus_: function(e) {
                const t = {
                    x: zr(e, "x", "softplus")
                };
                return Er.runKernel(Vn, t)
            }
        });
        const wu = Pr({
            split_: function(e, t, n = 0) {
                const s = {
                        x: zr(e, "x", "split")
                    },
                    r = {
                        numOrSizeSplits: t,
                        axis: n
                    };
                return Er.runKernel(qn, s, r)
            }
        });
        const ku = Pr({
            sqrt_: function(e) {
                const t = {
                    x: zr(e, "x", "sqrt", "float32")
                };
                return Er.runKernel(Gn, t)
            }
        });
        const vu = Pr({
            squeeze_: function(e, t) {
                const n = zr(e, "x", "squeeze");
                return Vi(n, V(n.shape, t).newShape)
            }
        });
        const Iu = Pr({
            stack_: function(e, t = 0) {
                const n = Br(e, "tensors", "stack", "string_or_numeric");
                R(n.length >= 1, (() => "Pass at least one tensor to tf.stack")), n.length > 0 && R(t <= n[0].rank, (() => "Axis must be <= rank of the tensor"));
                const s = n,
                    r = {
                        axis: t
                    };
                return Er.runKernel(gn, s, r)
            }
        });
        const Nu = Pr({
            tanh_: function(e) {
                const t = {
                    x: zr(e, "x", "tanh", "float32")
                };
                return Er.runKernel(us, t)
            }
        });

        function Su(e, t) {
            D(e);
            const n = Or(e, t);
            if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
            return Wr(e, null, n, t)
        }

        function Tu(e, t, n) {
            if (D(e), null != t && 2 !== t.length) throw new Error("tensor2d() requires shape to have two numbers");
            const s = Or(e, n);
            if (2 !== s.length && 1 !== s.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
            if (1 === s.length && null == t) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
            return Wr(e, t, s, n)
        }
        const $u = Pr({
            truncatedNormal_: function(e, t = 0, n = 1, s, r) {
                if (null != s && "bool" === s) throw new Error("Unsupported data type $ { dtype }");
                const a = new ru(t, n, s, !0, r),
                    i = Aa(e, s);
                for (let e = 0; e < i.values.length; e++) i.values[e] = a.nextValue();
                return i.toTensor()
            }
        });
        const Cu = Pr({
            unstack_: function(e, t = 0) {
                const n = zr(e, "x", "unstack", "string_or_numeric");
                R(t >= -n.shape.length && t < n.shape.length, (() => `Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));
                const s = {
                        value: n
                    },
                    r = {
                        axis: t
                    };
                return Er.runKernel(fs, s, r)
            }
        });
        const Eu = Pr({
            broadcastTo_: function(e, t) {
                let n = zr(e, "broadcastTo", "x");
                const s = n.shape;
                if (t.some((e => !(e > 0) || e % 1 != 0))) throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);
                if (t.length < n.rank) throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);
                if (t.length > n.rank) {
                    const e = n.shape.slice();
                    for (; e.length < t.length;) e.unshift(1);
                    n = Vi(n, e)
                }
                const r = n.shape,
                    a = Array.from(t);
                for (let e = t.length - 1; e >= 0; e--)
                    if (r[e] === t[e]) a[e] = 1;
                    else if (1 !== n.shape[e]) throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);
                if (0 === a.map(((e, t) => e > 1 ? t : -1)).filter((e => e >= 0)).length) return Fa(n);
                const i = {
                        x: n
                    },
                    o = {
                        reps: a
                    };
                return Er.runKernel(ls, i, o)
            }
        });
        const Au = Pr({
            where_: function(e, t, n) {
                const s = zr(t, "a", "where"),
                    r = zr(n, "b", "where"),
                    a = zr(e, "condition", "where", "bool"),
                    i = Ga(Ga(a.shape, s.shape), r.shape),
                    o = {
                        condition: Eu(a, i),
                        t: Eu(s, i),
                        e: Eu(r, i)
                    };
                return Er.runKernel(Mn, o)
            }
        });
        const Ru = Pr({
            zerosLike_: function(e) {
                const t = {
                    x: zr(e, "x", "zerosLike")
                };
                return Er.runKernel(gs, t)
            }
        });
        const Fu = Pr({
            imag_: function(e) {
                const t = {
                    input: zr(e, "input", "imag")
                };
                return Er.runKernel(Dt, t)
            }
        });
        const Du = Pr({
            real_: function(e) {
                const t = {
                    input: zr(e, "input", "real")
                };
                return Er.runKernel(vn, t)
            }
        });
        const _u = Pr({
            transpose_: function(e, t, n) {
                const s = zr(e, "x", "transpose");
                if (null == t && (t = s.shape.map(((e, t) => t)).reverse()), R(s.rank === t.length, (() => `Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`)), t.forEach((e => {
                        R(e >= 0 && e < s.rank, (() => "All entries in 'perm' must be between 0 and " + (s.rank - 1) + ` but got ${t}`))
                    })), s.rank <= 1) return s.clone();
                const r = {
                        x: s
                    },
                    a = {
                        perm: t
                    };
                return "complex64" === s.dtype ? yi((() => {
                    let e = Du(s),
                        t = Fu(s);
                    return e = Er.runKernel(ps, {
                        x: e
                    }, a), t = Er.runKernel(ps, {
                        x: t
                    }, a), n && (t = Xo(t)), Ur(e, t)
                })) : Er.runKernel(ps, r, a)
            }
        });
        const Ou = Pr({
            dropout_: function(e, t, n, s) {
                const r = zr(e, "x", "dropout");
                if (R("float32" === r.dtype, (() => `x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`)), R(t >= 0 && t < 1, (() => `rate must be a float in the range [0, 1), but got ${t}.`)), 0 === t) return e instanceof cr ? r.clone() : r;
                const a = function(e, t) {
                        if (null == t) return e.shape.slice();
                        if (M(e.shape, t)) return t;
                        if (e.shape.length === t.length) {
                            const n = [];
                            for (let s = 0; s < e.shape.length; s++) null == t[s] && null != e.shape[s] ? n.push(e.shape[s]) : n.push(t[s]);
                            return n
                        }
                        return t
                    }(r, n),
                    i = 1 - t,
                    o = ho(wo(Si(ou(a, 0, 1, "float32", s), i)), i);
                return Co(r, o)
            }
        });
        const Mu = Pr({
            fft_: function(e) {
                R("complex64" === e.dtype, (() => `The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));
                const t = {
                    input: e
                };
                return Er.runKernel(kt, t)
            }
        });
        const Lu = Pr({
            rfft_: function(e, t) {
                R("float32" === e.dtype, (() => `The dtype for rfft() must be real value but got ${e.dtype}`));
                let n = e.shape[e.shape.length - 1];
                const s = e.size / n;
                let r;
                if (null != t && t < n) {
                    const s = e.shape.map((e => 0)),
                        a = e.shape.map((e => e));
                    a[e.shape.length - 1] = t, r = du(e, s, a), n = t
                } else if (null != t && t > n) {
                    const s = e.shape.map((e => e));
                    s[e.shape.length - 1] = t - n, r = Ji([e, Zo(s)], e.shape.length - 1), n = t
                } else r = e;
                const a = Ru(r),
                    i = Vi(Ur(r, a), [s, n]),
                    o = Mu(i),
                    u = Math.floor(n / 2) + 1,
                    l = Du(o),
                    c = Fu(o),
                    h = wu(l, [u, n - u], l.shape.length - 1),
                    p = wu(c, [u, n - u], c.shape.length - 1),
                    d = r.shape.slice();
                return d[r.shape.length - 1] = u, Vi(Ur(h[0], p[0]), d)
            }
        });
        const zu = Pr({
            ifft_: function(e) {
                R("complex64" === e.dtype, (() => `The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));
                const t = {
                    input: e
                };
                return Er.runKernel(Ft, t)
            }
        });
        const Bu = Pr({
            irfft_: function(e) {
                const t = e.shape[e.shape.length - 1],
                    n = e.size / t;
                let s;
                if (t <= 2) {
                    const r = Vi(e, [n, t]);
                    s = zu(r)
                } else {
                    const r = [n, 2 * (t - 1)],
                        a = Vi(Du(e), [n, t]),
                        i = Vi(Fu(e), [n, t]),
                        o = lu(du(a, [0, 1], [n, t - 2]), 1),
                        u = Co(lu(du(i, [0, 1], [n, t - 2]), 1), vi(-1)),
                        l = Ji([a, o], 1),
                        c = Ji([i, u], 1),
                        h = Vi(Ur(l, c), [r[0], r[1]]);
                    s = zu(h)
                }
                if (s = Du(s), 3 === e.rank && 0 !== e.shape[0]) {
                    const t = s,
                        n = e.shape[0];
                    s = Vi(s, [n, s.shape[0] / n, s.shape[1]]), t.dispose()
                }
                return s
            }
        });
        const Pu = Pr({
            conv2DBackpropFilter_: function(e, t, n, s, r, a = "NHWC", i) {
                let o = e;
                3 === e.rank && (o = Vi(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
                let u = t;
                3 === u.rank && (u = Vi(t, [1, t.shape[0], t.shape[1], t.shape[2]])), R(4 === o.rank, (() => `Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)), R(4 === u.rank, (() => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)), R(4 === n.length, (() => `Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));
                const l = "NHWC" === a ? o.shape[3] : o.shape[1],
                    c = "NHWC" === a ? u.shape[3] : u.shape[1];
                R(l === n[2], (() => `Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)), R(c === n[3], (() => `Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)), Wi("conv2dDerFilter", r, i);
                const h = {
                        x: o,
                        dy: u
                    },
                    p = {
                        strides: s,
                        pad: r,
                        dataFormat: a,
                        dimRoundingMode: i,
                        filterShape: n
                    };
                return Er.runKernel(qe, h, p)
            }
        });
        const Uu = Pr({
            relu6_: function(e) {
                const t = {
                    x: zr(e, "x", "relu6")
                };
                return Er.runKernel(An, t)
            }
        });
        const Wu = Pr({
            step_: function(e, t = 0) {
                const n = {
                        x: zr(e, "x", "step")
                    },
                    s = {
                        alpha: t
                    };
                return Er.runKernel(ys, n, s)
            }
        });

        function Vu(e, t, n) {
            if (null == n || "linear" === n) return e;
            if ("relu" === n) return Co(e, Wu(t));
            throw new Error(`Cannot compute gradient for fused activation ${n}.`)
        }

        function Gu(e, t) {
            let n = t;
            const s = Va(e.shape, t.shape);
            return s.length > 0 && (n = Ao(n, s)), Vi(n, e.shape)
        }

        function Hu(e, t, n, s) {
            if ("linear" === t) return e;
            if ("relu" === t) return uu(e);
            if ("elu" === t) return po(e);
            if ("relu6" === t) return Uu(e);
            if ("prelu" === t) return nu(e, n);
            if ("leakyrelu" === t) return No(e, s);
            if ("sigmoid" === t) return pu(e);
            throw new Error(`Unknown fused activation ${t}.`)
        }
        const ju = (e, t) => !(e > 0) || "linear" === t;
        const qu = Pr({
            fusedConv2d_: function({
                x: e,
                filter: t,
                strides: n,
                pad: s,
                dataFormat: r = "NHWC",
                dilations: a = [1, 1],
                dimRoundingMode: i,
                bias: o,
                activation: u = "linear",
                preluActivationWeights: l,
                leakyreluAlpha: c
            }) {
                if (u = u || "linear", !1 === ju(Er.state.gradientDepth, u)) {
                    R("NHWC" === r, (() => `Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));
                    let h = no(e, t, n, s, r, a, i);
                    return null != o && (h = Si(h, o)), Hu(h, u, l, c)
                }
                const h = zr(e, "x", "conv2d", "float32"),
                    p = zr(t, "filter", "conv2d", "float32");
                let d = h,
                    f = !1;
                3 === h.rank && (f = !0, d = Vi(h, [1, h.shape[0], h.shape[1], h.shape[2]])), R(4 === d.rank, (() => `Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`)), R(4 === p.rank, (() => `Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)), Wi("fused conv2d", s, i);
                const m = "NHWC" === r ? d.shape[3] : d.shape[1];
                R(p.shape[2] === m, (() => `Error in conv2d: depth of input (${m}) must match input depth for filter ${p.shape[2]}.`)), R(Pi(n, a), (() => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));
                const g = Fi(d.shape, p.shape, n, a, s, i);
                let y, b;
                if (null != o && (y = zr(o, "bias", "fused conv2d"), [y] = kr(y, h), "NHWC" === r ? Ga(g.outShape, y.shape) : (R(y.shape.length <= 1, (() => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)), R(0 === y.shape.length || y.shape[0] === g.outChannels || 1 === y.shape[0], (() => `Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)))), null != l) {
                    const e = l.shape;
                    if (R(e.length <= 1 || 3 === e.length, (() => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)), 1 === e.length) R(1 === e[0] || e[0] === g.outChannels, (() => `Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${g.outChannels}).`));
                    else if (3 === e.length) try {
                        Ga(e, g.outShape)
                    } catch (t) {
                        const n = `Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${g.outShape}).`;
                        throw Error(n)
                    }
                    b = zr(l, "prelu weights", "fused conv2d")
                }
                const x = (e, t) => {
                        R("NHWC" === r, (() => `Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`));
                        const [i, o, l, c] = t, h = Vu(e, l, u);
                        R(Bi(a), (() => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));
                        const p = [ro(o.shape, h, i, n, s), Pu(o, h, i.shape, n, s)];
                        if (null != c) {
                            const e = Gu(c, h);
                            p.push(e)
                        }
                        return p
                    },
                    w = {
                        x: d,
                        filter: p,
                        bias: y,
                        preluActivationWeights: b
                    },
                    k = {
                        strides: n,
                        pad: s,
                        dataFormat: r,
                        dilations: a,
                        dimRoundingMode: i,
                        activation: u,
                        leakyreluAlpha: c
                    };
                if (null == o) {
                    const e = ki(((e, t, n) => {
                        let s = Er.runKernel(ks, w, k);
                        return n([t, e, s]), f && (s = Vi(s, [s.shape[1], s.shape[2], s.shape[3]])), {
                            value: s,
                            gradFunc: x
                        }
                    }));
                    return e(d, p)
                } {
                    const e = ki(((e, t, n, s) => {
                        let r = Er.runKernel(ks, w, k);
                        return s([t, e, r, n]), f && (r = Vi(r, [r.shape[1], r.shape[2], r.shape[3]])), {
                            value: r,
                            gradFunc: x
                        }
                    }));
                    return e(d, p, y)
                }
            }
        });
        const Ku = Pr({
            depthwiseConv2dNativeBackpropFilter_: function(e, t, n, s, r, a = [1, 1], i) {
                let o = e;
                3 === e.rank && (o = Vi(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
                let u = t;
                3 === u.rank && (u = Vi(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
                const l = {
                        x: o,
                        dy: u
                    },
                    c = {
                        strides: s,
                        pad: r,
                        dimRoundingMode: i,
                        dilations: a,
                        filterShape: n
                    };
                return Er.runKernel(it, l, c)
            }
        });
        const Xu = Pr({
            depthwiseConv2dNativeBackpropInput_: function(e, t, n, s, r, a = [1, 1], i) {
                let o = t,
                    u = !1;
                3 === t.rank && (u = !0, o = Vi(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
                const l = {
                        dy: o,
                        filter: n
                    },
                    c = {
                        strides: s,
                        pad: r,
                        dimRoundingMode: i,
                        dilations: a,
                        inputShape: e
                    },
                    h = Er.runKernel(ot, l, c);
                return u ? Vi(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
            }
        });
        const Yu = Pr({
            fusedDepthwiseConv2d_: function({
                x: e,
                filter: t,
                strides: n,
                pad: s,
                dataFormat: r = "NHWC",
                dilations: a = [1, 1],
                dimRoundingMode: i,
                bias: o,
                activation: u = "linear",
                preluActivationWeights: l,
                leakyreluAlpha: c
            }) {
                if (!1 === ju(Er.state.gradientDepth, u)) {
                    let h = lo(e, t, n, s, r, a, i);
                    return null != o && (h = Si(h, o)), Hu(h, u, l, c)
                }
                const h = zr(e, "x", "depthwiseConv2d", "float32"),
                    p = zr(t, "filter", "depthwiseConv2d", "float32");
                let d = h,
                    f = !1;
                3 === h.rank && (f = !0, d = Vi(h, [1, h.shape[0], h.shape[1], h.shape[2]])), R(4 === d.rank, (() => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`)), R(4 === p.rank, (() => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)), R(d.shape[3] === p.shape[2], (() => `Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)), null == a && (a = [1, 1]), R(Pi(n, a), (() => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)), Wi("fused depthwiseConv2d", s, i);
                const m = Fi(d.shape, p.shape, n, a, s, i, !0);
                let g, y;
                null != o && (g = zr(o, "bias", "fused conv2d"), [g] = kr(g, h), Ga(m.outShape, g.shape)), null != l && (y = zr(l, "prelu weights", "fused depthwiseConv2d"));
                const b = (e, t) => {
                        R(Bi(a), (() => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));
                        const [r, o, l, c] = t, h = Vu(e, l, u), p = Xu(o.shape, h, r, n, s, a, i), d = Ku(o, h, r.shape, n, s, a, i);
                        if (null != c) {
                            return [p, d, Gu(g, h)]
                        }
                        return [p, d]
                    },
                    x = {
                        x: d,
                        filter: p,
                        bias: g,
                        preluActivationWeights: y
                    },
                    w = {
                        strides: n,
                        pad: s,
                        dataFormat: r,
                        dilations: a,
                        dimRoundingMode: i,
                        activation: u,
                        leakyreluAlpha: c
                    };
                if (null == o) {
                    const e = ki(((e, t, n) => {
                        let s = Er.runKernel(vs, x, w);
                        return n([t, e, s]), f && (s = Vi(s, [s.shape[1], s.shape[2], s.shape[3]])), {
                            value: s,
                            gradFunc: b
                        }
                    }));
                    return e(d, p)
                } {
                    const e = ki(((e, t, n, s) => {
                        let r = Er.runKernel(vs, x, w);
                        return s([t, e, r, n]), f && (r = Vi(r, [r.shape[1], r.shape[2], r.shape[3]])), {
                            value: r,
                            gradFunc: b
                        }
                    }));
                    return e(d, p, g)
                }
            }
        });
        const Ju = Pr({
            fusedMatMul_: function({
                a: e,
                b: t,
                transposeA: n = !1,
                transposeB: s = !1,
                bias: r,
                activation: a = "linear",
                preluActivationWeights: i,
                leakyreluAlpha: o
            }) {
                if (!1 === ju(Er.state.gradientDepth, a)) {
                    let u = Do(e, t, n, s);
                    return null != r && (u = Si(u, r)), Hu(u, a, i, o)
                }
                let u = zr(e, "a", "fused matMul"),
                    l = zr(t, "b", "fused matMul");
                [u, l] = kr(u, l);
                const c = n ? u.shape[u.rank - 2] : u.shape[u.rank - 1],
                    h = s ? l.shape[l.rank - 1] : l.shape[l.rank - 2],
                    p = n ? u.shape[u.rank - 1] : u.shape[u.rank - 2],
                    d = s ? l.shape[l.rank - 2] : l.shape[l.rank - 1],
                    f = u.shape.slice(0, -2),
                    m = l.shape.slice(0, -2),
                    g = O(f),
                    y = O(m);
                R(c === h, (() => `Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${s} must match.`));
                const b = Ga(u.shape.slice(0, -2), l.shape.slice(0, -2)).concat([p, d]),
                    x = Vi(u, n ? [g, c, p] : [g, p, c]),
                    w = Vi(l, s ? [y, d, h] : [y, h, d]);
                let k, v;
                null != r && (k = zr(r, "bias", "fused matMul"), [k] = kr(k, u), Ga(b, k.shape)), null != i && (v = zr(i, "prelu weights", "fused matMul"));
                const I = (e, t) => {
                        const [i, o, u, l] = t, c = Vu(Vi(e, u.shape), u, a);
                        let h, p;
                        if (n || s ? !n && s ? (h = Do(c, o, !1, !1), p = Do(c, i, !0, !1)) : n && !s ? (h = Do(o, c, !1, !0), p = Do(i, c, !1, !1)) : (h = Do(o, c, !0, !0), p = Do(c, i, !0, !0)) : (h = Do(c, o, !1, !0), p = Do(i, c, !0, !1)), null != r) {
                            return [h, p, Gu(l, c)]
                        }
                        return [h, p]
                    },
                    N = {
                        a: x,
                        b: w,
                        bias: k,
                        preluActivationWeights: v
                    },
                    S = {
                        transposeA: n,
                        transposeB: s,
                        activation: a,
                        leakyreluAlpha: o
                    };
                if (null == r) {
                    const e = ki(((e, t, n) => {
                        const s = Er.runKernel(ws, N, S);
                        return n([e, t, s]), {
                            value: Vi(s, b),
                            gradFunc: I
                        }
                    }));
                    return e(x, w)
                } {
                    const e = ki(((e, t, n, s) => {
                        const r = Er.runKernel(ws, N, S);
                        return s([e, t, r, n]), {
                            value: Vi(r, b),
                            gradFunc: I
                        }
                    }));
                    return e(x, w, k)
                }
            }
        });

        function Zu(e, t, n) {
            const s = 1 - e % 2,
                r = new Float32Array(e);
            for (let a = 0; a < e; ++a) {
                const i = 2 * Math.PI * a / (e + s - 1);
                r[a] = t - n * Math.cos(i)
            }
            return Su(r, "float32")
        }
        const Qu = Pr({
            hammingWindow_: function(e) {
                return Zu(e, .54, .46)
            }
        });
        const el = Pr({
            hannWindow_: function(e) {
                return Zu(e, .5, .5)
            }
        });
        const tl = Pr({
            frame_: function(e, t, n, s = !1, r = 0) {
                let a = 0;
                const i = [];
                for (; a + t <= e.size;) i.push(du(e, a, t)), a += n;
                if (s)
                    for (; a < e.size;) {
                        const s = a + t - e.size,
                            o = Ji([du(e, a, t - s), xo([s], r)]);
                        i.push(o), a += n
                    }
                return 0 === i.length ? Tu([], [0, t]) : Vi(Ji(i), [i.length, t])
            }
        });
        const nl = Pr({
            stft_: function(e, t, n, s, r = el) {
                var a;
                null == s && (a = t, s = Math.floor(Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))));
                const i = tl(e, t, n),
                    o = Co(i, r(t));
                return Lu(o, s)
            }
        });
        const sl = Pr({
            cropAndResize_: function(e, t, n, s, r = "bilinear", a = 0) {
                const i = zr(e, "image", "cropAndResize"),
                    o = zr(t, "boxes", "cropAndResize", "float32"),
                    u = zr(n, "boxInd", "cropAndResize", "int32"),
                    l = o.shape[0];
                R(4 === i.rank, (() => `Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)), R(2 === o.rank && 4 === o.shape[1], (() => `Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`)), R(1 === u.rank && u.shape[0] === l, (() => `Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`)), R(2 === s.length, (() => `Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`)), R(s[0] >= 1 && s[1] >= 1, (() => `cropSize must be atleast [1,1], but was ${s}`)), R("bilinear" === r || "nearest" === r, (() => `method must be bilinear or nearest, but was ${r}`));
                const c = {
                        image: i,
                        boxes: o,
                        boxInd: u
                    },
                    h = {
                        method: r,
                        extrapolationValue: a,
                        cropSize: s
                    };
                return Er.runKernel(nt, c, h)
            }
        });
        const rl = Pr({
            flipLeftRight_: function(e) {
                const t = zr(e, "image", "flipLeftRight", "float32");
                R(4 === t.rank, (() => `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));
                const n = {
                    image: t
                };
                return Er.runKernel(It, n, {})
            }
        });
        const al = Pr({
            grayscaleToRGB_: function(e) {
                const t = zr(e, "image", "grayscaleToRGB"),
                    n = t.rank - 1,
                    s = t.shape[n];
                R(t.rank >= 2, (() => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)), R(1 === s, (() => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`));
                const r = new Array(t.rank);
                return r.fill(1, 0, n), r[n] = 3, yo(t, r)
            }
        });
        const il = Pr({
            rotateWithOffset_: function(e, t, n = 0, s = .5) {
                const r = zr(e, "image", "rotateWithOffset", "float32");
                R(4 === r.rank, (() => `Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));
                const a = {
                        image: r
                    },
                    i = {
                        radians: t,
                        fillValue: n,
                        center: s
                    };
                return Er.runKernel(xs, a, i)
            }
        });

        function ol(e, t, n, s, r, a) {
            null == s && (s = .5), null == r && (r = Number.NEGATIVE_INFINITY), null == a && (a = 0);
            const i = e.shape[0];
            return n = Math.min(n, i), R(0 <= s && s <= 1, (() => `iouThreshold must be in [0, 1], but was '${s}'`)), R(2 === e.rank, (() => `boxes must be a 2D tensor, but was of rank '${e.rank}'`)), R(4 === e.shape[1], (() => `boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)), R(1 === t.rank, (() => "scores must be a 1D tensor")), R(t.shape[0] === i, (() => `scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)), R(0 <= a && a <= 1, (() => `softNmsSigma must be in [0, 1], but was '${a}'`)), {
                maxOutputSize: n,
                iouThreshold: s,
                scoreThreshold: r,
                softNmsSigma: a
            }
        }
        const ul = Pr({
            nonMaxSuppression_: function(e, t, n, s = .5, r = Number.NEGATIVE_INFINITY) {
                const a = zr(e, "boxes", "nonMaxSuppression", "float32"),
                    i = zr(t, "scores", "nonMaxSuppression", "float32"),
                    o = ol(a, i, n, s, r),
                    u = {
                        maxOutputSize: n = o.maxOutputSize,
                        iouThreshold: s = o.iouThreshold,
                        scoreThreshold: r = o.scoreThreshold
                    };
                return Er.runKernel(hn, {
                    boxes: a,
                    scores: i
                }, u)
            }
        });

        function ll(e, t, n) {
            const s = function(e, t, n) {
                    return function(e, t, n) {
                        let s = 0,
                            r = e.length,
                            a = 0,
                            i = !1;
                        for (; s < r;) {
                            a = s + (r - s >>> 1);
                            const o = n(t, e[a]);
                            o > 0 ? s = a + 1 : (r = a, i = !o)
                        }
                        return i ? s : -s - 1
                    }(e, t, n || cl)
                }(e, t, n),
                r = s < 0 ? -(s + 1) : s;
            e.splice(r, 0, t)
        }

        function cl(e, t) {
            return e > t ? 1 : e < t ? -1 : 0
        }

        function hl(e, t, n, s, r) {
            return fl(e, t, n, s, r, 0)
        }

        function pl(e, t, n, s, r, a) {
            return fl(e, t, n, s, r, 0, !1, a, !0)
        }

        function dl(e, t, n, s, r, a) {
            return fl(e, t, n, s, r, a, !0)
        }

        function fl(e, t, n, s, r, a, i = !1, o = !1, u = !1) {
            const l = [];
            for (let e = 0; e < t.length; e++) t[e] > r && l.push({
                score: t[e],
                boxIndex: e,
                suppressBeginIndex: 0
            });
            l.sort(yl);
            const c = a > 0 ? -.5 / a : 0,
                h = [],
                p = [];
            for (; h.length < n && l.length > 0;) {
                const t = l.pop(),
                    {
                        score: n,
                        boxIndex: a,
                        suppressBeginIndex: i
                    } = t;
                if (n < r) break;
                let o = !1;
                for (let n = h.length - 1; n >= i; --n) {
                    const i = ml(e, a, h[n]);
                    if (i >= s) {
                        o = !0;
                        break
                    }
                    if (t.score = t.score * gl(s, c, i), t.score <= r) break
                }
                t.suppressBeginIndex = h.length, o || (t.score === n ? (h.push(a), p.push(t.score)) : t.score > r && ll(l, t, yl))
            }
            const d = h.length,
                f = n - d;
            o && f > 0 && (h.push(...new Array(f).fill(0)), p.push(...new Array(f).fill(0)));
            const m = {
                selectedIndices: h
            };
            return i && (m.selectedScores = p), u && (m.validOutputs = d), m
        }

        function ml(e, t, n) {
            const s = e.subarray(4 * t, 4 * t + 4),
                r = e.subarray(4 * n, 4 * n + 4),
                a = Math.min(s[0], s[2]),
                i = Math.min(s[1], s[3]),
                o = Math.max(s[0], s[2]),
                u = Math.max(s[1], s[3]),
                l = Math.min(r[0], r[2]),
                c = Math.min(r[1], r[3]),
                h = Math.max(r[0], r[2]),
                p = Math.max(r[1], r[3]),
                d = (o - a) * (u - i),
                f = (h - l) * (p - c);
            if (d <= 0 || f <= 0) return 0;
            const m = Math.max(a, l),
                g = Math.max(i, c),
                y = Math.min(o, h),
                b = Math.min(u, p),
                x = Math.max(y - m, 0) * Math.max(b - g, 0);
            return x / (d + f - x)
        }

        function gl(e, t, n) {
            const s = Math.exp(t * n * n);
            return n <= e ? s : 0
        }

        function yl(e, t) {
            return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex
        }
        const bl = async function(e, t, n, s = .5, r = Number.NEGATIVE_INFINITY) {
            const a = zr(e, "boxes", "nonMaxSuppressionAsync"),
                i = zr(t, "scores", "nonMaxSuppressionAsync"),
                o = ol(a, i, n, s, r);
            n = o.maxOutputSize, s = o.iouThreshold, r = o.scoreThreshold;
            const u = await Promise.all([a.data(), i.data()]),
                l = u[0],
                c = u[1],
                {
                    selectedIndices: h
                } = hl(l, c, n, s, r);
            return a !== e && a.dispose(), i !== t && i.dispose(), Su(h, "int32")
        };
        const xl = Pr({
            nonMaxSuppressionWithScore_: function(e, t, n, s = .5, r = Number.NEGATIVE_INFINITY, a = 0) {
                const i = zr(e, "boxes", "nonMaxSuppression"),
                    o = zr(t, "scores", "nonMaxSuppression"),
                    u = ol(i, o, n, s, r, a),
                    l = {
                        boxes: i,
                        scores: o
                    },
                    c = {
                        maxOutputSize: n = u.maxOutputSize,
                        iouThreshold: s = u.iouThreshold,
                        scoreThreshold: r = u.scoreThreshold,
                        softNmsSigma: a = u.softNmsSigma
                    },
                    h = Er.runKernel(dn, l, c);
                return {
                    selectedIndices: h[0],
                    selectedScores: h[1]
                }
            }
        });
        const wl = async function(e, t, n, s = .5, r = Number.NEGATIVE_INFINITY, a = 0) {
            const i = zr(e, "boxes", "nonMaxSuppressionAsync"),
                o = zr(t, "scores", "nonMaxSuppressionAsync"),
                u = ol(i, o, n, s, r, a);
            n = u.maxOutputSize, s = u.iouThreshold, r = u.scoreThreshold, a = u.softNmsSigma;
            const l = await Promise.all([i.data(), o.data()]),
                c = l[0],
                h = l[1],
                {
                    selectedIndices: p,
                    selectedScores: d
                } = dl(c, h, n, s, r, a);
            return i !== e && i.dispose(), o !== t && o.dispose(), {
                selectedIndices: Su(p, "int32"),
                selectedScores: Su(d)
            }
        };
        const kl = Pr({
            nonMaxSuppressionPadded_: function(e, t, n, s = .5, r = Number.NEGATIVE_INFINITY, a = !1) {
                const i = zr(e, "boxes", "nonMaxSuppression"),
                    o = zr(t, "scores", "nonMaxSuppression"),
                    u = ol(i, o, n, s, r, null),
                    l = {
                        boxes: i,
                        scores: o
                    },
                    c = {
                        maxOutputSize: u.maxOutputSize,
                        iouThreshold: u.iouThreshold,
                        scoreThreshold: u.scoreThreshold,
                        padToMaxOutputSize: a
                    },
                    h = Er.runKernel(pn, l, c);
                return {
                    selectedIndices: h[0],
                    validOutputs: h[1]
                }
            }
        });
        const vl = async function(e, t, n, s = .5, r = Number.NEGATIVE_INFINITY, a = !1) {
            const i = zr(e, "boxes", "nonMaxSuppressionAsync"),
                o = zr(t, "scores", "nonMaxSuppressionAsync"),
                u = ol(i, o, n, s, r, null),
                l = u.maxOutputSize,
                c = u.iouThreshold,
                h = u.scoreThreshold,
                [p, d] = await Promise.all([i.data(), o.data()]),
                {
                    selectedIndices: f,
                    validOutputs: m
                } = pl(p, d, l, c, h, a);
            return i !== e && i.dispose(), o !== t && o.dispose(), {
                selectedIndices: Su(f, "int32"),
                validOutputs: vi(m, "int32")
            }
        };
        const Il = Pr({
            resizeBilinear_: function(e, t, n = !1, s = !1) {
                const r = zr(e, "images", "resizeBilinear");
                R(3 === r.rank || 4 === r.rank, (() => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`)), R(2 === t.length, (() => `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)), R(!1 === s || !1 === n, (() => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));
                let a = r,
                    i = !1;
                3 === r.rank && (i = !0, a = Vi(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
                const [] = t, o = {
                    images: a
                }, u = {
                    alignCorners: n,
                    halfPixelCenters: s,
                    size: t
                }, l = Er.runKernel(Cn, o, u);
                return i ? Vi(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
            }
        });
        const Nl = Pr({
            resizeNearestNeighbor_: function(e, t, n = !1, s = !1) {
                const r = zr(e, "images", "resizeNearestNeighbor");
                R(3 === r.rank || 4 === r.rank, (() => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`)), R(2 === t.length, (() => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)), R("float32" === r.dtype || "int32" === r.dtype, (() => "`images` must have `int32` or `float32` as dtype")), R(!1 === s || !1 === n, (() => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));
                let a = r,
                    i = !1;
                3 === r.rank && (i = !0, a = Vi(r, [1, r.shape[0], r.shape[1], r.shape[2]]));
                const [] = t, o = {
                    images: a
                }, u = {
                    alignCorners: n,
                    halfPixelCenters: s,
                    size: t
                }, l = Er.runKernel(Tn, o, u);
                return i ? Vi(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
            }
        });
        const Sl = Pr({
            bincount_: function(e, t, n) {
                const s = zr(e, "x", "bincount"),
                    r = zr(t, "weights", "bincount");
                R("int32" === s.dtype, (() => `Error in bincount: input dtype must be int32, but got ${s.dtype}`)), R(n >= 0, (() => `size must be non-negative, but got ${n}.`)), R(r.size === s.size || 0 === r.size, (() => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`));
                const a = {
                        x: s,
                        weights: r
                    },
                    i = {
                        size: n
                    };
                return Er.runKernel(ze, a, i)
            }
        });
        const Tl = Pr({
            lessEqual_: function(e, t) {
                let n = zr(e, "a", "lessEqual", "string_or_numeric"),
                    s = zr(t, "b", "lessEqual", "string_or_numeric");
                [n, s] = kr(n, s), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(Bt, r)
            }
        });
        const $l = Pr({
            round_: function(e) {
                const t = {
                    x: zr(e, "x", "round")
                };
                return Er.runKernel(Fn, t)
            }
        });

        function Cl(e, t, n = 1, s = "float32") {
            if (0 === n) throw new Error("Cannot have a step of zero");
            const r = {
                start: e,
                stop: t,
                step: n,
                dtype: s
            };
            return Er.runKernel(kn, {}, r)
        }
        const El = Pr({
            threshold_: function(e, t = "binary", n = !1, s = .5) {
                const r = zr(e, "image", "threshold"),
                    a = r.shape[0] * r.shape[1];
                let i, o, u, l, c = Co(Su([s]), 255);
                if (R(3 === r.rank, (() => `Error in threshold: image must be rank 3,but got rank ${r.rank}.`)), R(3 === r.shape[2] || 1 === r.shape[2], (() => `Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`)), R("int32" === r.dtype || "float32" === r.dtype, (() => `Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`)), R("otsu" === t || "binary" === t, (() => `Method must be binary or otsu, but was ${t}`)), 3 === r.shape[2]) {
                    [i, o, u] = wu(r, [1, 1, 1], -1);
                    const e = Co(i, .2989),
                        t = Co(o, .587),
                        n = Co(u, .114);
                    l = Si(Si(e, t), n)
                } else l = e;
                if ("otsu" === t) {
                    c = function(e, t) {
                        let n, s, r, a, i, o, u = Su([-1]),
                            l = Su([0]),
                            c = Su([0]);
                        for (let h = 0; h < e.size - 1; h++) {
                            n = du(e, 0, h + 1), s = du(e, h + 1), i = ho(Ao(n), t), o = ho(Ao(s), t);
                            const p = Ao(Co(n, Cl(0, n.size)));
                            r = ho(p, Ao(n));
                            const d = xo(s.shape, n.size),
                                f = Si(Cl(0, s.size), d),
                                m = Co(s, f);
                            a = ho(Ao(m), Ao(s));
                            const g = Eo(r, a),
                                y = Eo(r, a),
                                b = Co(i, o);
                            c = Co(Co(b, g), y);
                            const x = vo(c, l);
                            l = Au(x, c, l), u = Au(x, Su([h]), u)
                        }
                        return u
                    }(Sl(Ra($l(l), "int32"), Vr([]), 256), a)
                }
                const h = n ? Tl(l, c) : vo(l, c);
                return Ra(Co(h, 255), "int32")
            }
        });
        const Al = Pr({
            transform_: function(e, t, n = "nearest", s = "constant", r = 0, a) {
                const i = zr(e, "image", "transform", "float32"),
                    o = zr(t, "transforms", "transform", "float32");
                R(4 === i.rank, (() => `Error in transform: image must be rank 4,but got rank ${i.rank}.`)), R(2 === o.rank && (o.shape[0] === i.shape[0] || 1 === o.shape[0]) && 8 === o.shape[1], (() => "Error in transform: Input transform should be batch x 8 or 1 x 8")), R(null == a || 2 === a.length, (() => `Error in transform: outputShape must be [height, width] or null, but got ${a}.`));
                const u = {
                        image: i,
                        transforms: o
                    },
                    l = {
                        interpolation: n,
                        fillMode: s,
                        fillValue: r,
                        outputShape: a
                    };
                return Er.runKernel(hs, u, l)
            }
        });
        const Rl = Pr({
            bandPart_: function(e, t, n) {
                R(t % 1 == 0, (() => `bandPart(): numLower must be an integer, got ${t}.`)), R(n % 1 == 0, (() => `bandPart(): numUpper must be an integer, got ${n}.`));
                const s = zr(e, "a", "bandPart");
                R(s.rank >= 2, (() => `bandPart(): Rank must be at least 2, got ${s.rank}.`));
                const r = s.shape,
                    [a, i] = s.shape.slice(-2);
                if (!(t <= a)) throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`);
                if (!(n <= i)) throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);
                t < 0 && (t = a), n < 0 && (n = i);
                const o = Vi(Cl(0, a, 1, "int32"), [-1, 1]),
                    u = Cl(0, i, 1, "int32"),
                    l = Eo(o, u),
                    c = Fo(Tl(l, vi(+t, "int32")), Io(l, vi(-n, "int32"))),
                    h = Zo([a, i], s.dtype);
                return Vi(Iu(Cu(Vi(s, [-1, a, i])).map((e => Au(c, e, h)))), r)
            }
        });
        const Fl = Pr({
            min_: function(e, t = null, n = !1) {
                const s = {
                        x: zr(e, "x", "min")
                    },
                    r = {
                        axis: t,
                        keepDims: n
                    };
                return Er.runKernel(nn, s, r)
            }
        });
        const Dl = Pr({
            pow_: function(e, t) {
                let n = zr(e, "base", "pow"),
                    s = zr(t, "exp", "pow");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(bn, r)
            }
        });

        function _l(e, t, n = null) {
            if (0 === e.rank) return Ni(e);
            if (1 !== e.rank && null === n) return _l(Vi(e, [-1]), t, n);
            if (1 === e.rank || "number" == typeof n || Array.isArray(n) && 1 === n.length) {
                if (1 === t) return Ao(Ni(e), n);
                if (t === 1 / 0) return $o(Ni(e), n);
                if (t === -1 / 0) return Fl(Ni(e), n);
                if ("euclidean" === t || 2 === t) return ku(Ao(Dl(Ni(e), vi(2, "int32")), n));
                throw new Error(`Error in norm: invalid ord value: ${t}`)
            }
            if (Array.isArray(n) && 2 === n.length) {
                if (1 === t) return $o(Ao(Ni(e), n[0]), n[1] - 1);
                if (t === 1 / 0) return $o(Ao(Ni(e), n[1]), n[0]);
                if (t === -1 / 0) return Fl(Ao(Ni(e), n[1]), n[0]);
                if ("fro" === t || "euclidean" === t) return ku(Ao(qo(e), n));
                throw new Error(`Error in norm: invalid ord value: ${t}`)
            }
            throw new Error(`Error in norm: invalid axis: ${n}`)
        }
        const Ol = Pr({
            norm_: function(e, t = "euclidean", n = null, s = !1) {
                const r = _l(e = zr(e, "x", "norm"), t, n);
                let a = r.shape;
                if (s) {
                    const t = W(n, e.shape);
                    a = Wo(r.shape, t)
                }
                return Vi(r, a)
            }
        });
        const Ml = Pr({
            gramSchmidt_: function(e) {
                let t;
                if (Array.isArray(e)) {
                    t = !1, R(null != e && e.length > 0, (() => "Gram-Schmidt process: input must not be null, undefined, or empty"));
                    const n = e[0].shape[0];
                    for (let t = 1; t < e.length; ++t) R(e[t].shape[0] === n, (() => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))
                } else t = !0, e = wu(e, e.shape[0], 0).map((e => vu(e, [0])));
                R(e.length <= e[0].shape[0], (() => `Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));
                const n = [],
                    s = e;
                for (let t = 0; t < e.length; ++t) n.push(Er.tidy((() => {
                    let e = s[t];
                    if (t > 0)
                        for (let s = 0; s < t; ++s) {
                            const t = Co(Ao(Co(n[s], e)), n[s]);
                            e = Eo(e, t)
                        }
                    return ho(e, Ol(e, "euclidean"))
                })));
                return t ? Iu(n, 0) : n
            }
        });

        function Ll(e, t = !1) {
            return Er.tidy((() => {
                R(2 === e.shape.length, (() => `qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));
                const n = e.shape[0],
                    s = e.shape[1];
                let r = bo(n),
                    a = Fa(e);
                const i = Tu([
                    [1]
                ], [1, 1]);
                let o = Fa(i);
                const u = n >= s ? s : n;
                for (let e = 0; e < u; ++e) {
                    const t = a,
                        u = o,
                        l = r;
                    [o, a, r] = Er.tidy((() => {
                        const t = du(a, [e, e], [n - e, 1]),
                            u = Ol(t),
                            l = du(a, [e, e], [1, 1]),
                            c = Au(vo(l, 0), Tu([
                                [-1]
                            ]), Tu([
                                [1]
                            ])),
                            h = Eo(l, Co(c, u)),
                            p = ho(t, h);
                        o = 1 === p.shape[0] ? Fa(i) : Ji([i, du(p, [1, 0], [p.shape[0] - 1, p.shape[1]])], 0);
                        const d = Xo(ho(Do(c, h), u)),
                            f = du(a, [e, 0], [n - e, s]),
                            m = Co(d, o),
                            g = _u(o);
                        if (0 === e) a = Eo(f, Do(m, Do(g, f)));
                        else {
                            const t = Eo(f, Do(m, Do(g, f)));
                            a = Ji([du(a, [0, 0], [e, s]), t], 0)
                        }
                        const y = _u(m),
                            b = du(r, [0, e], [n, r.shape[1] - e]);
                        if (0 === e) r = Eo(b, Do(Do(b, o), y));
                        else {
                            const t = Eo(b, Do(Do(b, o), y));
                            r = Ji([du(r, [0, 0], [n, e]), t], 1)
                        }
                        return [o, a, r]
                    })), bi([t, u, l])
                }
                return !t && n > s && (r = du(r, [0, 0], [n, s]), a = du(a, [0, 0], [s, s])), [r, a]
            }))
        }
        const zl = Pr({
            qr_: function(e, t = !1) {
                if (R(e.rank >= 2, (() => `qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)), 2 === e.rank) return Ll(e, t);
                {
                    const n = e.shape.slice(0, e.shape.length - 2).reduce(((e, t) => e * t)),
                        s = Cu(Vi(e, [n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
                        r = [],
                        a = [];
                    s.forEach((e => {
                        const [n, s] = Ll(e, t);
                        r.push(n), a.push(s)
                    }));
                    return [Vi(Iu(r, 0), e.shape), Vi(Iu(a, 0), e.shape)]
                }
            }
        });
        var Bl;
        ! function(e) {
            e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS"
        }(Bl || (Bl = {}));
        const Pl = Pr({
            computeWeightedLoss_: function(e, t, n = Bl.SUM_BY_NONZERO_WEIGHTS) {
                const s = zr(e, "losses", "computeWeightedLoss");
                let r = null;
                null != t && (r = zr(t, "weights", "computeWeightedLoss"));
                const a = null == r ? s : Co(s, r);
                if (n === Bl.NONE) return a;
                if (n === Bl.SUM) return Ao(a);
                if (n === Bl.MEAN) {
                    if (null == r) return Lo(a);
                    {
                        const e = s.size / r.size,
                            t = ho(Ao(a), Ao(r));
                        return e > 1 ? ho(t, vi(e)) : t
                    }
                }
                if (n === Bl.SUM_BY_NONZERO_WEIGHTS) {
                    if (null == r) return ho(Ao(a), vi(s.size));
                    {
                        const e = Co(r, Qo(s.shape)),
                            t = Ra(Ao(Yo(e, vi(0))), "float32");
                        return ho(Ao(a), t)
                    }
                }
                throw Error(`Unknown reduction: ${n}`)
            }
        });
        Pr({
            absoluteDifference_: function(e, t, n, s = Bl.SUM_BY_NONZERO_WEIGHTS) {
                const r = zr(e, "labels", "absoluteDifference"),
                    a = zr(t, "predictions", "absoluteDifference");
                let i = null;
                null != n && (i = zr(n, "weights", "absoluteDifference")), F(r.shape, a.shape, "Error in absoluteDifference: ");
                const o = Ni(Eo(r, a));
                return Pl(o, i, s)
            }
        });
        Pr({
            cosineDistance_: function(e, t, n, s, r = Bl.SUM_BY_NONZERO_WEIGHTS) {
                const a = zr(e, "labels", "cosineDistance"),
                    i = zr(t, "predictions", "cosineDistance");
                let o = null;
                null != s && (o = zr(s, "weights", "cosineDistance")), F(a.shape, i.shape, "Error in cosineDistance: ");
                const u = vi(1),
                    l = Eo(u, Ao(Co(a, i), n, !0));
                return Pl(l, o, r)
            }
        });
        Pr({
            hingeLoss_: function(e, t, n, s = Bl.SUM_BY_NONZERO_WEIGHTS) {
                let r = zr(e, "labels", "hingeLoss");
                const a = zr(t, "predictions", "hingeLoss");
                let i = null;
                null != n && (i = zr(n, "weights", "hingeLoss")), F(r.shape, a.shape, "Error in hingeLoss: ");
                const o = vi(1);
                r = Eo(Co(vi(2), r), o);
                const u = uu(Eo(o, Co(r, a)));
                return Pl(u, i, s)
            }
        });
        Pr({
            huberLoss_: function(e, t, n, s = 1, r = Bl.SUM_BY_NONZERO_WEIGHTS) {
                const a = zr(e, "labels", "huberLoss"),
                    i = zr(t, "predictions", "huberLoss");
                let o = null;
                null != n && (o = zr(n, "weights", "huberLoss")), F(a.shape, i.shape, "Error in huberLoss: ");
                const u = vi(s),
                    l = Ni(Eo(i, a)),
                    c = zo(l, u),
                    h = Eo(l, c),
                    p = Si(Co(vi(.5), qo(c)), Co(u, h));
                return Pl(p, o, r)
            }
        });
        Pr({
            logLoss_: function(e, t, n, s = 1e-7, r = Bl.SUM_BY_NONZERO_WEIGHTS) {
                const a = zr(e, "labels", "logLoss"),
                    i = zr(t, "predictions", "logLoss");
                let o = null;
                null != n && (o = zr(n, "weights", "logLoss")), F(a.shape, i.shape, "Error in logLoss: ");
                const u = vi(1),
                    l = vi(s),
                    c = Xo(Co(a, So(Si(i, l)))),
                    h = Co(Eo(u, a), So(Si(Eo(u, i), l))),
                    p = Eo(c, h);
                return Pl(p, o, r)
            }
        });
        const Ul = Pr({
            squaredDifference_: function(e, t) {
                let n = zr(e, "a", "squaredDifference"),
                    s = zr(t, "b", "squaredDifference");
                [n, s] = kr(n, s), Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(es, r, {})
            }
        });
        Pr({
            meanSquaredError_: function(e, t, n, s = Bl.SUM_BY_NONZERO_WEIGHTS) {
                const r = zr(e, "labels", "meanSquaredError"),
                    a = zr(t, "predictions", "meanSquaredError");
                let i = null;
                null != n && (i = zr(n, "weights", "meanSquaredError")), F(r.shape, a.shape, "Error in meanSquaredError: ");
                const o = Ul(r, a);
                return Pl(o, i, s)
            }
        });
        Pr({
            sigmoidCrossEntropy_: function(e, t, n, s = 0, r = Bl.SUM_BY_NONZERO_WEIGHTS) {
                let a = zr(e, "multiClassLabels", "sigmoidCrossEntropy");
                const i = zr(t, "logits", "sigmoidCrossEntropy");
                let o = null;
                if (null != n && (o = zr(n, "weights", "sigmoidCrossEntropy")), F(a.shape, i.shape, "Error in sigmoidCrossEntropy: "), s > 0) {
                    const e = vi(s),
                        t = vi(1),
                        n = vi(.5);
                    a = Si(Co(a, Eo(t, e)), Co(n, e))
                }
                const u = function(e, t) {
                    const n = zr(e, "labels", "sigmoidCrossEntropyWithLogits"),
                        s = zr(t, "logits", "sigmoidCrossEntropyWithLogits");
                    F(n.shape, s.shape, "Error in sigmoidCrossEntropyWithLogits: ");
                    const r = uu(s),
                        a = Co(s, n),
                        i = To(mo(Xo(Ni(s))));
                    return Si(Eo(r, a), i)
                }(a, i);
                return Pl(u, o, r)
            }
        });
        const Wl = Pr({
            logSumExp_: function(e, t = null, n = !1) {
                const s = zr(e, "x", "logSumExp"),
                    r = W(t, s.shape),
                    a = $o(s, r, !0),
                    i = Eo(s, a),
                    o = mo(i),
                    u = Ao(o, r),
                    l = So(u),
                    c = Si(Vi(a, l.shape), l);
                if (n) {
                    const e = Wo(c.shape, r);
                    return Vi(c, e)
                }
                return c
            }
        });
        Pr({
            softmaxCrossEntropy_: function(e, t, n, s = 0, r = Bl.SUM_BY_NONZERO_WEIGHTS) {
                let a = zr(e, "onehotLabels", "softmaxCrossEntropy");
                const i = zr(t, "logits", "softmaxCrossEntropy");
                let o = null;
                if (null != n && (o = zr(n, "weights", "softmaxCrossEntropy")), F(a.shape, i.shape, "Error in softmaxCrossEntropy: "), s > 0) {
                    const e = vi(s),
                        t = vi(1),
                        n = vi(a.shape[1]);
                    a = Si(Co(a, Eo(t, e)), ho(e, n))
                }
                const u = function(e, t, n = -1) {
                    if (-1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);
                    const s = ki(((e, t, s) => {
                        const r = Wl(t, [n], !0),
                            a = Eo(Ra(t, "float32"), r);
                        s([e, a]);
                        const i = Xo(Co(a, e));
                        return {
                            value: Ao(i, [n]),
                            gradFunc: (e, t) => {
                                const [s, r] = t, a = Wo(e.shape, [n]);
                                return [Co(Vi(e, a), Eo(Ra(s, "float32"), mo(r))), Co(Vi(e, a), Eo(mo(r), Ra(s, "float32")))]
                            }
                        }
                    }));
                    return s(e, t)
                }(a, i);
                return Pl(u, o, r)
            }
        });
        const Vl = Pr({
            sparseFillEmptyRows_: function(e, t, n, s) {
                const r = zr(e, "indices", "sparseFillEmptyRows", "int32"),
                    a = zr(t, "values", "sparseFillEmptyRows"),
                    i = zr(n, "denseShape", "sparseFillEmptyRows", "int32"),
                    o = zr(s, "defaultValue", "sparseFillEmptyRows", a.dtype);
                if (2 !== r.rank) throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);
                if (1 !== a.rank) throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);
                if (1 !== i.rank) throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);
                if (0 !== o.rank) throw new Error(`Default value should be a scalar but received shape ${o.shape}`);
                const u = {
                        indices: r,
                        values: a,
                        denseShape: i,
                        defaultValue: o
                    },
                    l = Er.runKernel(Xn, u);
                return {
                    outputIndices: l[0],
                    outputValues: l[1],
                    emptyRowIndicator: l[2],
                    reverseIndexMap: l[3]
                }
            }
        });
        const Gl = Pr({
            sparseReshape_: function(e, t, n) {
                const s = zr(e, "inputIndices", "sparseReshape", "int32"),
                    r = zr(t, "inputShape", "sparseReshape", "int32"),
                    a = zr(n, "newShape", "sparseReshape", "int32");
                if (2 !== s.rank) throw new Error(`Input indices should be Tensor2D but received shape\n        ${s.shape}`);
                if (1 !== r.rank) throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);
                if (1 !== a.rank) throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);
                const i = {
                        inputIndices: s,
                        inputShape: r,
                        newShape: a
                    },
                    o = Er.runKernel(Yn, i);
                return {
                    outputIndices: o[0],
                    outputShape: o[1]
                }
            }
        });
        const Hl = Pr({
            sparseSegmentMean_: function(e, t, n) {
                const s = zr(e, "data", "sparseSegmentMean"),
                    r = zr(t, "indices", "sparseSegmentMean", "int32"),
                    a = zr(n, "segmentIds", "sparseSegmentMean", "int32");
                if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
                if (1 !== r.rank) throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);
                if (1 !== a.rank) throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);
                const i = {
                    data: s,
                    indices: r,
                    segmentIds: a
                };
                return Er.runKernel(Jn, i)
            }
        });
        const jl = Pr({
            sparseSegmentSum_: function(e, t, n) {
                const s = zr(e, "data", "sparseSegmentSum"),
                    r = zr(t, "indices", "sparseSegmentSum", "int32"),
                    a = zr(n, "segmentIds", "sparseSegmentSum", "int32");
                if (s.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
                if (1 !== r.rank) throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);
                if (1 !== a.rank) throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);
                const i = {
                    data: s,
                    indices: r,
                    segmentIds: a
                };
                return Er.runKernel(Zn, i)
            }
        });
        const ql = Pr({
            stringNGrams_: function(e, t, n, s, r, a, i, o) {
                const u = zr(e, "data", "stringNGrams", "string");
                if ("string" !== u.dtype) throw new Error("Data must be of datatype string");
                if (1 !== u.shape.length) throw new Error(`Data must be a vector, saw: ${u.shape}`);
                const l = zr(t, "dataSplits", "stringNGrams");
                if ("int32" !== l.dtype) throw new Error("Data splits must be of datatype int32");
                const c = {
                        separator: n,
                        nGramWidths: s,
                        leftPad: r,
                        rightPad: a,
                        padWidth: i,
                        preserveShortSequences: o
                    },
                    h = {
                        data: u,
                        dataSplits: l
                    },
                    p = Er.runKernel(ss, h, c);
                return {
                    nGrams: p[0],
                    nGramsSplits: p[1]
                }
            }
        });
        const Kl = Pr({
            stringSplit_: function(e, t, n = !0) {
                const s = zr(e, "input", "stringSplit", "string"),
                    r = zr(t, "delimiter", "stringSplit", "string");
                if (1 !== s.rank) throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);
                if (0 !== r.rank) throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);
                const a = {
                        skipEmpty: n
                    },
                    i = {
                        input: s,
                        delimiter: r
                    },
                    o = Er.runKernel(rs, i, a);
                return {
                    indices: o[0],
                    values: o[1],
                    shape: o[2]
                }
            }
        });
        const Xl = Pr({
                stringToHashBucketFast_: function(e, t) {
                    const n = zr(e, "input", "stringToHashBucketFast", "string"),
                        s = {
                            numBuckets: t
                        };
                    if (t <= 0) throw new Error("Number of buckets must be at least 1");
                    const r = {
                        input: n
                    };
                    return Er.runKernel(as, r, s)
                }
            }),
            Yl = {
                hammingWindow: Qu,
                hannWindow: el,
                frame: tl,
                stft: nl
            },
            Jl = {
                flipLeftRight: rl,
                grayscaleToRGB: al,
                resizeNearestNeighbor: Nl,
                resizeBilinear: Il,
                rotateWithOffset: il,
                cropAndResize: sl,
                nonMaxSuppression: ul,
                nonMaxSuppressionAsync: bl,
                nonMaxSuppressionWithScore: xl,
                nonMaxSuppressionWithScoreAsync: wl,
                nonMaxSuppressionPadded: kl,
                nonMaxSuppressionPaddedAsync: vl,
                threshold: El,
                transform: Al
            },
            Zl = {
                bandPart: Rl,
                gramSchmidt: Ml,
                qr: zl
            },
            Ql = {
                sparseFillEmptyRows: Vl,
                sparseReshape: Gl,
                sparseSegmentMean: Hl,
                sparseSegmentSum: jl
            },
            ec = {
                stringNGrams: ql,
                stringSplit: Kl,
                stringToHashBucketFast: Xl
            };
        class tc extends Ii {
            constructor(e, t, n = null) {
                super(), this.learningRate = e, this.rho = t, this.epsilon = n, this.accumulatedGrads = [], this.accumulatedUpdates = [], null == n && (this.epsilon = Er.backend.epsilon())
            }
            applyGradients(e) {
                (Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e)).forEach(((t, n) => {
                    const s = Er.registeredVariables[t],
                        r = !1;
                    null == this.accumulatedGrads[n] && (this.accumulatedGrads[n] = {
                        originalName: `${t}/accum_grad`,
                        variable: yi((() => Ru(s).variable(r)))
                    }), null == this.accumulatedUpdates[n] && (this.accumulatedUpdates[n] = {
                        originalName: `${t}/accum_var`,
                        variable: yi((() => Ru(s).variable(r)))
                    });
                    const a = Array.isArray(e) ? e[n].tensor : e[t];
                    if (null == a) return;
                    const i = this.accumulatedGrads[n].variable,
                        o = this.accumulatedUpdates[n].variable;
                    yi((() => {
                        const e = Si(Co(i, this.rho), Co(qo(a), 1 - this.rho)),
                            t = Co(ho(ku(Si(o, this.epsilon)), ku(Si(i, this.epsilon))), a),
                            n = Si(Co(o, this.rho), Co(qo(t), 1 - this.rho));
                        i.assign(e), o.assign(n);
                        const r = Si(Co(t, -this.learningRate), s);
                        s.assign(r)
                    }))
                })), this.incrementIterations()
            }
            dispose() {
                null != this.accumulatedUpdates && (bi(this.accumulatedGrads.map((e => e.variable))), bi(this.accumulatedUpdates.map((e => e.variable))))
            }
            async getWeights() {
                const e = [...this.accumulatedGrads, ...this.accumulatedUpdates];
                return [await this.saveIterations()].concat(e.map((e => ({
                    name: e.originalName,
                    tensor: e.variable
                }))))
            }
            async setWeights(e) {
                const t = (e = await this.extractIterations(e)).length / 2,
                    n = !1;
                this.accumulatedGrads = e.slice(0, t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                }))), this.accumulatedUpdates = e.slice(t, 2 * t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                })))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    rho: this.rho,
                    epsilon: this.epsilon
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.rho, t.epsilon)
            }
        }
        tc.className = "Adadelta", fi(tc);
        class nc extends Ii {
            constructor(e, t = .1) {
                super(), this.learningRate = e, this.initialAccumulatorValue = t, this.accumulatedGrads = []
            }
            applyGradients(e) {
                (Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e)).forEach(((t, n) => {
                    const s = Er.registeredVariables[t];
                    if (null == this.accumulatedGrads[n]) {
                        const e = !1;
                        this.accumulatedGrads[n] = {
                            originalName: `${t}/accumulator`,
                            variable: yi((() => xo(s.shape, this.initialAccumulatorValue).variable(e)))
                        }
                    }
                    const r = Array.isArray(e) ? e[n].tensor : e[t];
                    if (null == r) return;
                    const a = this.accumulatedGrads[n].variable;
                    yi((() => {
                        const e = Si(a, qo(r));
                        a.assign(e);
                        const t = Si(Co(ho(r, ku(Si(e, Er.backend.epsilon()))), -this.learningRate), s);
                        s.assign(t)
                    }))
                })), this.incrementIterations()
            }
            dispose() {
                null != this.accumulatedGrads && bi(this.accumulatedGrads.map((e => e.variable)))
            }
            async getWeights() {
                return [await this.saveIterations()].concat(this.accumulatedGrads.map((e => ({
                    name: e.originalName,
                    tensor: e.variable
                }))))
            }
            async setWeights(e) {
                e = await this.extractIterations(e);
                this.accumulatedGrads = e.map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                })))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    initialAccumulatorValue: this.initialAccumulatorValue
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.initialAccumulatorValue)
            }
        }
        nc.className = "Adagrad", fi(nc);
        class sc extends Ii {
            constructor(e, t, n, s = null) {
                super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = s, this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], yi((() => {
                    this.accBeta1 = vi(t).variable(), this.accBeta2 = vi(n).variable()
                })), null == s && (this.epsilon = Er.backend.epsilon())
            }
            applyGradients(e) {
                const t = Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e);
                yi((() => {
                    const n = Eo(1, this.accBeta1),
                        s = Eo(1, this.accBeta2);
                    t.forEach(((t, r) => {
                        const a = Er.registeredVariables[t],
                            i = !1;
                        null == this.accumulatedFirstMoment[r] && (this.accumulatedFirstMoment[r] = {
                            originalName: `${t}/m`,
                            variable: yi((() => Ru(a).variable(i)))
                        }), null == this.accumulatedSecondMoment[r] && (this.accumulatedSecondMoment[r] = {
                            originalName: `${t}/v`,
                            variable: yi((() => Ru(a).variable(i)))
                        });
                        const o = Array.isArray(e) ? e[r].tensor : e[t];
                        if (null == o) return;
                        const u = this.accumulatedFirstMoment[r].variable,
                            l = this.accumulatedSecondMoment[r].variable,
                            c = Si(Co(u, this.beta1), Co(o, 1 - this.beta1)),
                            h = Si(Co(l, this.beta2), Co(qo(o), 1 - this.beta2)),
                            p = ho(c, n),
                            d = ho(h, s);
                        u.assign(c), l.assign(h);
                        const f = Si(Co(ho(p, Si(ku(d), this.epsilon)), -this.learningRate), a);
                        a.assign(f)
                    })), this.accBeta1.assign(Co(this.accBeta1, this.beta1)), this.accBeta2.assign(Co(this.accBeta2, this.beta2))
                })), this.incrementIterations()
            }
            dispose() {
                this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && bi(this.accumulatedFirstMoment.map((e => e.variable))), null != this.accumulatedSecondMoment && bi(this.accumulatedSecondMoment.map((e => e.variable)))
            }
            async getWeights() {
                const e = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
                return [await this.saveIterations()].concat(e.map((e => ({
                    name: e.originalName,
                    tensor: e.variable
                }))))
            }
            async setWeights(e) {
                e = await this.extractIterations(e), yi((() => {
                    this.accBeta1.assign(Dl(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(Dl(this.beta2, this.iterations_ + 1))
                }));
                const t = e.length / 2,
                    n = !1;
                this.accumulatedFirstMoment = e.slice(0, t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                }))), this.accumulatedSecondMoment = e.slice(t, 2 * t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                })))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    beta1: this.beta1,
                    beta2: this.beta2,
                    epsilon: this.epsilon
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.beta1, t.beta2, t.epsilon)
            }
        }
        sc.className = "Adam", fi(sc);
        class rc extends Ii {
            constructor(e, t, n, s = null, r = 0) {
                super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = s, this.decay = r, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], yi((() => {
                    this.iteration = vi(0).variable(), this.accBeta1 = vi(t).variable()
                })), null == s && (this.epsilon = Er.backend.epsilon())
            }
            applyGradients(e) {
                const t = Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e);
                yi((() => {
                    const n = Eo(1, this.accBeta1),
                        s = ho(-this.learningRate, Si(Co(this.iteration, this.decay), 1));
                    t.forEach(((t, r) => {
                        const a = Er.registeredVariables[t],
                            i = !1;
                        null == this.accumulatedFirstMoment[r] && (this.accumulatedFirstMoment[r] = {
                            originalName: `${t}/m`,
                            variable: Ru(a).variable(i)
                        }), null == this.accumulatedWeightedInfNorm[r] && (this.accumulatedWeightedInfNorm[r] = {
                            originalName: `${t}/v`,
                            variable: Ru(a).variable(i)
                        });
                        const o = Array.isArray(e) ? e[r].tensor : e[t];
                        if (null == o) return;
                        const u = this.accumulatedFirstMoment[r].variable,
                            l = this.accumulatedWeightedInfNorm[r].variable,
                            c = Si(Co(u, this.beta1), Co(o, 1 - this.beta1)),
                            h = Co(l, this.beta2),
                            p = Ni(o),
                            d = Mo(h, p);
                        u.assign(c), l.assign(d);
                        const f = Si(Co(ho(s, n), ho(c, Si(d, this.epsilon))), a);
                        a.assign(f)
                    })), this.iteration.assign(Si(this.iteration, 1)), this.accBeta1.assign(Co(this.accBeta1, this.beta1))
                })), this.incrementIterations()
            }
            dispose() {
                this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && bi(this.accumulatedFirstMoment.map((e => e.variable))), null != this.accumulatedWeightedInfNorm && bi(this.accumulatedWeightedInfNorm.map((e => e.variable)))
            }
            async getWeights() {
                throw new Error("getWeights() is not implemented for Adamax yet.")
            }
            async setWeights(e) {
                throw new Error("setWeights() is not implemented for Adamax yet.")
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    beta1: this.beta1,
                    beta2: this.beta2,
                    epsilon: this.epsilon,
                    decay: this.decay
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay)
            }
        }
        rc.className = "Adamax", fi(rc);
        class ac extends Ii {
            constructor(e) {
                super(), this.learningRate = e, this.setLearningRate(e)
            }
            applyGradients(e) {
                (Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e)).forEach(((t, n) => {
                    const s = Array.isArray(e) ? e[n].tensor : e[t];
                    if (null == s) return;
                    const r = Er.registeredVariables[t];
                    yi((() => {
                        const e = Si(Co(this.c, s), r);
                        r.assign(e)
                    }))
                })), this.incrementIterations()
            }
            setLearningRate(e) {
                this.learningRate = e, null != this.c && this.c.dispose(), this.c = xi(vi(-e))
            }
            dispose() {
                this.c.dispose()
            }
            async getWeights() {
                return [await this.saveIterations()]
            }
            async setWeights(e) {
                if (0 !== (e = await this.extractIterations(e)).length) throw new Error("SGD optimizer does not have settable weights.")
            }
            getConfig() {
                return {
                    learningRate: this.learningRate
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate)
            }
        }
        ac.className = "SGD", fi(ac);
        class ic extends ac {
            constructor(e, t, n = !1) {
                super(e), this.learningRate = e, this.momentum = t, this.useNesterov = n, this.accumulations = [], this.m = vi(this.momentum)
            }
            applyGradients(e) {
                (Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e)).forEach(((t, n) => {
                    const s = Er.registeredVariables[t];
                    if (null == this.accumulations[n]) {
                        const e = !1;
                        this.accumulations[n] = {
                            originalName: `${t}/momentum`,
                            variable: yi((() => Ru(s).variable(e)))
                        }
                    }
                    const r = this.accumulations[n].variable,
                        a = Array.isArray(e) ? e[n].tensor : e[t];
                    null != a && yi((() => {
                        let e;
                        const t = Si(Co(this.m, r), a);
                        e = this.useNesterov ? Si(Co(this.c, Si(a, Co(t, this.m))), s) : Si(Co(this.c, t), s), r.assign(t), s.assign(e)
                    }))
                })), this.incrementIterations()
            }
            dispose() {
                this.m.dispose(), null != this.accumulations && bi(this.accumulations.map((e => e.variable)))
            }
            setMomentum(e) {
                this.momentum = e
            }
            async getWeights() {
                return [await this.saveIterations()].concat(this.accumulations.map((e => ({
                    name: e.originalName,
                    tensor: e.variable
                }))))
            }
            async setWeights(e) {
                e = await this.extractIterations(e);
                this.accumulations = e.map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(false)
                })))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    momentum: this.momentum,
                    useNesterov: this.useNesterov
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.momentum, t.useNesterov)
            }
        }
        ic.className = "Momentum", fi(ic);
        class oc extends Ii {
            constructor(e, t = .9, n = 0, s = null, r = !1) {
                if (super(), this.learningRate = e, this.decay = t, this.momentum = n, this.epsilon = s, this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], this.centered = r, null == s && (this.epsilon = Er.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.")
            }
            applyGradients(e) {
                (Array.isArray(e) ? e.map((e => e.name)) : Object.keys(e)).forEach(((t, n) => {
                    const s = Er.registeredVariables[t],
                        r = !1;
                    null == this.accumulatedMeanSquares[n] && (this.accumulatedMeanSquares[n] = {
                        originalName: `${t}/rms`,
                        variable: yi((() => Ru(s).variable(r)))
                    }), null == this.accumulatedMoments[n] && (this.accumulatedMoments[n] = {
                        originalName: `${t}/momentum`,
                        variable: yi((() => Ru(s).variable(r)))
                    }), null == this.accumulatedMeanGrads[n] && this.centered && (this.accumulatedMeanGrads[n] = {
                        originalName: `${t}/mg`,
                        variable: yi((() => Ru(s).variable(r)))
                    });
                    const a = Array.isArray(e) ? e[n].tensor : e[t];
                    if (null == a) return;
                    const i = this.accumulatedMeanSquares[n].variable,
                        o = this.accumulatedMoments[n].variable;
                    yi((() => {
                        const e = Si(Co(i, this.decay), Co(qo(a), 1 - this.decay));
                        if (this.centered) {
                            const t = this.accumulatedMeanGrads[n].variable,
                                r = Si(Co(t, this.decay), Co(a, 1 - this.decay)),
                                u = ho(Co(a, this.learningRate), ku(Eo(e, Si(qo(r), this.epsilon)))),
                                l = Si(Co(o, this.momentum), u);
                            i.assign(e), t.assign(r), o.assign(l);
                            const c = Eo(s, l);
                            s.assign(c)
                        } else {
                            const e = Si(Co(i, this.decay), Co(qo(a), 1 - this.decay)),
                                t = Si(Co(o, this.momentum), ho(Co(a, this.learningRate), ku(Si(e, this.epsilon))));
                            i.assign(e), o.assign(t);
                            const n = Eo(s, t);
                            s.assign(n)
                        }
                    }))
                })), this.incrementIterations()
            }
            dispose() {
                null != this.accumulatedMeanSquares && bi(this.accumulatedMeanSquares.map((e => e.variable))), null != this.accumulatedMeanGrads && this.centered && bi(this.accumulatedMeanGrads.map((e => e.variable))), null != this.accumulatedMoments && bi(this.accumulatedMoments.map((e => e.variable)))
            }
            async getWeights() {
                const e = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
                return this.centered && e.push(...this.accumulatedMeanGrads), [await this.saveIterations()].concat(e.map((e => ({
                    name: e.originalName,
                    tensor: e.variable
                }))))
            }
            async setWeights(e) {
                e = await this.extractIterations(e);
                const t = this.centered ? e.length / 3 : e.length / 2,
                    n = !1;
                this.accumulatedMeanSquares = e.slice(0, t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                }))), this.accumulatedMoments = e.slice(t, 2 * t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                }))), this.centered && (this.accumulatedMeanGrads = e.slice(2 * t, 3 * t).map((e => ({
                    originalName: e.name,
                    variable: e.tensor.variable(n)
                }))))
            }
            getConfig() {
                return {
                    learningRate: this.learningRate,
                    decay: this.decay,
                    momentum: this.momentum,
                    epsilon: this.epsilon,
                    centered: this.centered
                }
            }
            static fromConfig(e, t) {
                return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered)
            }
        }
        oc.className = "RMSProp", fi(oc);
        class uc {
            static sgd(e) {
                return new ac(e)
            }
            static momentum(e, t, n = !1) {
                return new ic(e, t, n)
            }
            static rmsprop(e, t = .9, n = 0, s = null, r = !1) {
                return new oc(e, t, n, s, r)
            }
            static adam(e = .001, t = .9, n = .999, s = null) {
                return new sc(e, t, n, s)
            }
            static adadelta(e = .001, t = .95, n = null) {
                return new tc(e, t, n)
            }
            static adamax(e = .002, t = .9, n = .999, s = null, r = 0) {
                return new rc(e, t, n, s, r)
            }
            static adagrad(e, t = .1) {
                return new nc(e, t)
            }
        }
        const lc = {
                sgd: uc.sgd,
                momentum: uc.momentum,
                adadelta: uc.adadelta,
                adagrad: uc.adagrad,
                rmsprop: uc.rmsprop,
                adamax: uc.adamax,
                adam: uc.adam
            },
            cc = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : e => e();

        function hc() {
            return new Promise((e => cc((() => e()))))
        }

        function pc(e, t) {
            const n = e[0].length;
            e.forEach(((e, t) => {
                R(e.length === n, (() => `Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))
            })), R(t >= 0 && t < n, (() => `Error in concat${n}D: axis must be between 0 and ${n-1}.`));
            const s = e[0];
            e.forEach(((e, r) => {
                for (let a = 0; a < n; a++) R(a === t || e[a] === s[a], (() => `Error in concat${n}D: Shape of tensors[${r}] (${e}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`))
            }))
        }

        function dc(e, t) {
            const n = e[0].slice();
            for (let s = 1; s < e.length; s++) n[t] += e[s][t];
            return n
        }
        const fc = 30;

        function mc(e) {
            return e <= fc ? e : Q(e, Math.floor(Math.sqrt(e)))
        }

        function gc(e, t, n) {
            return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])]
        }

        function yc(e, t, n, s = !0) {
            let r = [];
            if (s) r = r.concat(t.slice(0)), r.push(e[0] / n), r = r.concat(e.slice(1));
            else {
                r = r.concat(e[0]);
                const n = t.length;
                for (let s = 0; s < n; ++s) r = r.concat([e[s + 1] / t[s], t[s]]);
                r = r.concat(e.slice(n + 1))
            }
            return r
        }

        function bc(e, t, n = !0) {
            const s = [];
            if (n) {
                s.push(t);
                for (let n = t + 1; n < e; ++n) n <= 2 * t ? (s.push(n), s.push(n - (t + 1))) : s.push(n)
            } else {
                const n = [],
                    r = [];
                for (let s = 1; s < e; ++s) s >= 2 * t + 1 || s % 2 == 1 ? r.push(s) : n.push(s);
                s.push(...n), s.push(0), s.push(...r)
            }
            return s
        }

        function xc(e, t, n, s = !0) {
            const r = [];
            s ? r.push(e[0] / n) : r.push(e[0] * n);
            for (let n = 1; n < e.length; ++n) n <= t.length ? s ? r.push(t[n - 1] * e[n]) : r.push(e[n] / t[n - 1]) : r.push(e[n]);
            return r
        }

        function wc(e, t) {
            const n = [0];
            for (let s = 0; s < t; ++s) n.push(e[s][0]);
            return n
        }

        function kc(e, t, n) {
            const s = e.slice(0, 1);
            for (let r = 0; r < n; ++r) s.push(e[r + 1] - t[r][0] - t[r][1]);
            return s
        }

        function vc(e, t) {
            const n = e.shape.length,
                s = t.shape.length;
            if (n < 1) throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);
            if (s < 1) throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);
            if ("int32" !== t.dtype) throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
            if (t.shape[s - 1] > n) throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);
            if (0 === O(e.shape)) throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);
            const r = t.shape,
                a = r[r.length - 1];
            let i = 1;
            for (let e = 0; e < r.length - 1; ++e) i *= r[e];
            const o = e.shape,
                u = r.slice();
            u.pop();
            let l = 1;
            for (let e = a; e < n; ++e) l *= o[e], u.push(o[e]);
            const c = [...ee(e.shape).map((e => e / l)), 1].slice(0, a);
            return [u, i, l, c]
        }

        function Ic(e, t, n) {
            const s = t.rank > 1 ? t.shape[t.rank - 1] : 1,
                r = t.rank > 1 ? t.rank - 1 : 1,
                a = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;
            if (n.rank < r) throw new Error(a + ` update.rank < ${r}. `);
            if (e.length < s + (n.rank - r)) throw new Error(a + ` Output shape length < ${s+(n.rank-r)}`);
            if (n.rank !== r + e.length - s) throw new Error(a + " update.rank != " + (r + e.length - s));
            for (let e = 0; e < r; ++e)
                if (n.shape[e] !== t.shape[e]) throw new Error(a + ` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);
            for (let t = 0; t < n.rank - r; ++t)
                if (n.shape[t + r] !== e[t + s]) throw new Error(a + ` updates.shape[${t+r}] (${n.shape[t+r]}) != shape[${t+r}] (${e[t+r]})`)
        }

        function Nc(e, t, n) {
            if (t.rank < 1) throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
            if (e.rank < 1) throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);
            if ("int32" !== t.dtype) throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
            if (n.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);
            if (0 === n.length) {
                if (0 === t.size) throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
                if (0 === e.size) throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)
            }
            Ic(n, t, e)
        }

        function Sc(e, t, n) {
            const s = t.shape.length,
                r = s > 1 ? t.shape[s - 1] : 1,
                a = n.length;
            let i = 1;
            for (let e = r; e < a; ++e) i *= n[e];
            const o = r < 1 ? 1 : r;
            return {
                sliceRank: r,
                numUpdates: O(t.shape) / o,
                sliceSize: i,
                strides: [...ee(n.slice(0, r)), 1],
                outputSize: O(n)
            }
        }
        const Tc = 1.7580993408473768,
            $c = 1.0507009873554805,
            Cc = .3275911,
            Ec = .254829592,
            Ac = -.284496736,
            Rc = 1.421413741,
            Fc = -1.453152027,
            Dc = 1.061405429;

        function _c(e, t) {
            if (e.length !== t.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);
            const n = new Float32Array(2 * e.length);
            for (let s = 0; s < n.length; s += 2) n[s] = e[s / 2], n[s + 1] = t[s / 2];
            return n
        }

        function Oc(e) {
            const t = new Float32Array(e.length / 2),
                n = new Float32Array(e.length / 2);
            for (let s = 0; s < e.length; s += 2) t[s / 2] = e[s], n[s / 2] = e[s + 1];
            return {
                real: t,
                imag: n
            }
        }

        function Mc(e) {
            const t = Math.ceil(e.length / 4),
                n = new Float32Array(t),
                s = new Float32Array(t);
            for (let t = 0; t < e.length; t += 4) n[Math.floor(t / 4)] = e[t], s[Math.floor(t / 4)] = e[t + 1];
            return {
                real: n,
                imag: s
            }
        }

        function Lc(e) {
            const t = Math.floor(e.length / 4),
                n = new Float32Array(t),
                s = new Float32Array(t);
            for (let t = 2; t < e.length; t += 4) n[Math.floor(t / 4)] = e[t], s[Math.floor(t / 4)] = e[t + 1];
            return {
                real: n,
                imag: s
            }
        }

        function zc(e, t) {
            return {
                real: e[2 * t],
                imag: e[2 * t + 1]
            }
        }

        function Bc(e, t, n, s) {
            e[2 * s] = t, e[2 * s + 1] = n
        }

        function Pc(e, t) {
            const n = new Float32Array(e / 2),
                s = new Float32Array(e / 2);
            for (let r = 0; r < Math.ceil(e / 2); r++) {
                const a = (t ? 2 : -2) * Math.PI * (r / e);
                n[r] = Math.cos(a), s[r] = Math.sin(a)
            }
            return {
                real: n,
                imag: s
            }
        }

        function Uc(e, t, n) {
            const s = (n ? 2 : -2) * Math.PI * (e / t);
            return {
                real: Math.cos(s),
                imag: Math.sin(s)
            }
        }
        const Wc = "->",
            Vc = /->/g,
            Gc = ",",
            Hc = "...";

        function jc(e, t) {
            const n = ((e = e.replace(/\s/g, "")).length - e.replace(Vc, "").length) / Wc.length;
            if (n < 1) throw new Error("Equations without an arrow are not supported.");
            if (n > 1) throw new Error(`Equation must contain exactly one arrow ("${Wc}").`);
            const [s, r] = e.split(Wc);
            R(-1 === s.indexOf(Hc), (() => `The ellipsis notation ("${Hc}") is not supported yet.`));
            const a = s.split(Gc),
                i = a.length;
            if (t !== i) throw new Error(`Expected ${i} input tensors, received ${t}`);
            if (i > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
            const o = [];
            for (let e = 0; e < r.length; ++e) {
                const t = r[e];
                if (!a.some((e => -1 !== e.indexOf(t)))) throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`); - 1 === o.indexOf(t) && o.push(t)
            }
            for (let e = 0; e < s.length; ++e) {
                const t = s[e]; - 1 === o.indexOf(t) && t !== Gc && o.push(t)
            }
            const u = new Array(a.length);
            for (let e = 0; e < i; ++e) {
                if (new Set(a[e].split("")).size !== a[e].length) throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);
                u[e] = [];
                for (let t = 0; t < a[e].length; ++t) u[e].push(o.indexOf(a[e][t]))
            }
            const l = o.length,
                c = [];
            for (let e = r.length; e < l; ++e) c.push(e);
            return {
                allDims: o,
                summedDims: c,
                idDims: u
            }
        }

        function qc(e, t) {
            let n = new Array(e);
            n.fill(-1);
            for (let e = 0; e < t.length; ++e) n[t[e]] = e;
            const s = [];
            for (let t = 0; t < e; ++t) - 1 === n[t] && s.push(t);
            return n = n.filter((e => -1 !== e)), {
                permutationIndices: n,
                expandDims: s
            }
        }

        function Kc(e, t, n) {
            const s = new Array(e);
            for (let e = 0; e < n.length; ++e) {
                const r = n[e].shape;
                for (let n = 0; n < t[e].length; ++n) void 0 === s[t[e][n]] ? s[t[e][n]] = r[n] : R(s[t[e][n]] === r[n], (() => `Expected dimension ${s[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(r)}, but got dimension ${r[n]}`))
            }
        }

        function Xc(e, t) {
            const n = e,
                s = [];
            let r = 0;
            0 === e.length && n.push(-1), r = e.length + 1;
            for (let e = 0; e < r; ++e) s.push([]);
            const a = [];
            for (let e = 0; e < n.length; ++e) {
                const r = Jc(t, n[e]);
                for (const t of r) - 1 === a.indexOf(t) && (s[e].push(t), a.push(t))
            }
            return {
                path: n,
                steps: s
            }
        }

        function Yc(e) {
            return e.every(((e, t) => e === t))
        }

        function Jc(e, t) {
            const n = [];
            for (let s = 0; s < e.length; ++s) 0 !== e[s].length && -1 === e[s].indexOf(t) && -1 !== t || n.push(s);
            return n
        }

        function Zc(e, t, n = 0) {
            let s = [];
            if ("number" == typeof t) R(e.shape[n] % t == 0, (() => "Number of splits must evenly divide the axis.")), s = new Array(t).fill(e.shape[n] / t);
            else {
                const r = t.reduce(((e, t) => (-1 === t && (e += 1), e)), 0);
                R(r <= 1, (() => "There should be only one negative value in split array."));
                const a = t.indexOf(-1);
                if (-1 !== a) {
                    const s = t.reduce(((e, t) => t > 0 ? e + t : e));
                    t[a] = e.shape[n] - s
                }
                R(e.shape[n] === t.reduce(((e, t) => e + t)), (() => "The sum of sizes must match the size of the axis dimension.")), s = t
            }
            return s
        }

        function Qc(e) {
            return `Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`
        }

        function eh(e, t) {
            return `indices(${e}, 0) is invalid: ${t} < 0`
        }

        function th(e, t, n) {
            return `indices(${e}, 0) is invalid: ${t} >= ${n}`
        }

        function nh(e, t) {
            return `only one output dimension may be -1, not both ${e} and ${t}`
        }

        function sh(e, t) {
            return `size ${e} must be non-negative, not ${t}`
        }

        function rh() {
            return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"
        }

        function ah(e, t) {
            return `Input to reshape is a SparseTensor with ${O(e)}\n  dense values, but the requested shape requires a multiple of ${O(t)}. inputShape=${e} outputShape= ${t}`
        }

        function ih(e, t) {
            return `Input to reshape is a tensor with ${O(e)} dense values, but the requested shape has ${O(t)}. inputShape=${e} outputShape=${t}`
        }

        function oh() {
            return "segment ids must be >= 0"
        }

        function uh() {
            return "segment ids are not increasing"
        }

        function lh(e, t) {
            return `Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`
        }

        function ch(e, t, n) {
            return `Bad: indices[${e}] == ${t} out of range [0, ${n})`
        }

        function hh(e, t) {
            let n, s = !1;
            for (e <= fc ? (n = e, s = !0) : n = Q(e, Math.floor(Math.sqrt(e))); !s;) n > t || n === e ? s = !0 : n = Q(e, n + 1);
            return n
        }

        function ph(e, t, n) {
            const s = [],
                r = e.length;
            for (let a = 0; a < r; a++) a !== t ? s.push(e[a]) : s.push(n);
            return s
        }

        function dh(e, t, n, s) {
            const r = t.shape.length,
                a = e.shape.length;
            if (0 !== s && (s < -r || s > r)) throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);
            if (s < 0 && (s += r), s > a) throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${a}).`);
            if (n < s) throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);
            for (let n = 0; n < s; ++n)
                if (e.shape[n] !== t.shape[n]) throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);
            const i = e.shape[n],
                o = [];
            let u = 1,
                l = 1,
                c = 1;
            for (let t = 0; t < s; ++t) o.push(e.shape[t]), u *= e.shape[t];
            for (let t = s; t < n; t++) o.push(e.shape[t]), l *= e.shape[t];
            for (let e = s; e < r; e++) o.push(t.shape[e]);
            for (let t = n + 1; t < a; t++) o.push(e.shape[t]), c *= e.shape[t];
            return {
                batchSize: u,
                sliceSize: c,
                outerSize: l,
                dimSize: i,
                outputShape: o
            }
        }

        function fh(e) {
            try {
                return e.map((e => Js(e)))
            } catch (e) {
                throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)
            }
        }

        function mh(e) {
            return e.map((e => Ys(e)))
        }

        function gh(e, t) {
            const n = [];
            for (let e = 0; e < t.length; e++) t[e] && n.push(e);
            const s = Aa(e, "int32"),
                r = Aa([n.length, e.length], "int32");
            for (let t = 0; t < n.length; t++) {
                const a = s.indexToLoc(n[t]),
                    i = t * e.length;
                r.values.set(a, i)
            }
            return r.toTensor()
        }
        const yh = {
                kernelName: be,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(e, Wu(Ra(n, "float32"), -1))
                    }
                }
            },
            bh = {
                kernelName: xe,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => {
                            const t = qo(Ra(n, "float32")),
                                s = ku(Eo(vi(1), t));
                            return Xo(ho(e, s))
                        }
                    }
                }
            },
            xh = {
                kernelName: we,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => {
                            const t = ku(Eo(qo(Ra(n, "float32")), 1));
                            return ho(e, t)
                        }
                    }
                }
            },
            wh = {
                kernelName: ke,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = Ga(n.shape, s.shape);
                    return {
                        a: () => {
                            let t = e;
                            const s = Va(n.shape, r);
                            return s.length > 0 && (t = Ao(t, s)), Vi(t, n.shape)
                        },
                        b: () => {
                            let t = e;
                            const n = Va(s.shape, r);
                            return n.length > 0 && (t = Ao(t, n)), Vi(t, s.shape)
                        }
                    }
                }
            },
            kh = {
                kernelName: ve,
                saveAllInputs: !0,
                gradFunc: (e, t) => {
                    const n = {};
                    return t.forEach(((t, s) => {
                        n[s] = () => e.clone()
                    })), n
                }
            },
            vh = {
                kernelName: Se,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Ru(n)
                    }
                }
            },
            Ih = {
                kernelName: Te,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Ru(n)
                    }
                }
            },
            Nh = {
                kernelName: $e,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => ho(e, ku(Eo(vi(1), qo(Ra(n, "float32")))))
                    }
                }
            },
            Sh = {
                kernelName: Ce,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => {
                            const t = ku(Si(vi(1), qo(Ra(n, "float32"))));
                            return ho(e, t)
                        }
                    }
                }
            },
            Th = {
                kernelName: Re,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = Ga(n.shape, s.shape);
                    return {
                        a: () => {
                            const t = Si(qo(n), qo(s));
                            let a = Co(e, ho(s, t));
                            const i = Va(n.shape, r);
                            return i.length > 0 && (a = Ao(a, i)), Vi(a, n.shape)
                        },
                        b: () => {
                            const t = Si(qo(n), qo(s));
                            let a = Xo(Co(e, ho(n, t)));
                            const i = Va(s.shape, r);
                            return i.length > 0 && (a = Ao(a, i)), Vi(a, s.shape)
                        }
                    }
                }
            },
            $h = {
                kernelName: Ee,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => ho(e, Si(qo(Ra(n, "float32")), 1))
                    }
                }
            },
            Ch = {
                kernelName: Ae,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => ho(e, Eo(vi(1), qo(Ra(n, "float32"))))
                    }
                }
            };
        const Eh = Pr({
                avgPool3dGrad_: function(e, t, n, s, r, a) {
                    const i = zr(e, "dy", "avgPool3dGrad"),
                        o = zr(t, "input", "avgPool3dGrad");
                    let u = i,
                        l = o,
                        c = !1;
                    4 === o.rank && (c = !0, u = Vi(i, [1, i.shape[0], i.shape[1], i.shape[2], i.shape[3]]), l = Vi(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), R(5 === u.rank, (() => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`)), R(5 === l.rank, (() => `Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`)), Wi("avgPool3dGrad", r, a);
                    const h = {
                            dy: u,
                            input: l
                        },
                        p = {
                            filterSize: n,
                            strides: s,
                            pad: r,
                            dimRoundingMode: a
                        },
                        d = Er.runKernel(Oe, h, p);
                    return c ? Vi(d, [d.shape[1], d.shape[2], d.shape[3], d.shape[4]]) : d
                }
            }),
            Ah = {
                kernelName: _e,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        filterSize: r,
                        strides: a,
                        pad: i,
                        dimRoundingMode: o
                    } = n;
                    return {
                        x: () => Eh(e, s, r, a, i, o)
                    }
                }
            };
        const Rh = Pr({
                avgPoolGrad_: function(e, t, n, s, r) {
                    const a = zr(e, "dy", "avgPoolGrad"),
                        i = zr(t, "input", "avgPoolGrad");
                    R(i.rank === a.rank, (() => `Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));
                    let o = i,
                        u = a,
                        l = !1;
                    3 === i.rank && (l = !0, o = Vi(i, [1, i.shape[0], i.shape[1], i.shape[2]]), u = Vi(a, [1, a.shape[0], a.shape[1], a.shape[2]])), R(4 === u.rank, (() => `Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`)), R(4 === o.rank, (() => `Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));
                    const c = {
                            dy: u,
                            input: o
                        },
                        h = {
                            filterSize: n,
                            strides: s,
                            pad: r
                        },
                        p = Er.runKernel(De, c, h);
                    return l ? Vi(p, [p.shape[1], p.shape[2], p.shape[3]]) : p
                }
            }),
            Fh = {
                kernelName: Fe,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        filterSize: r,
                        strides: a,
                        pad: i
                    } = n;
                    return {
                        x: () => Rh(e, s, r, a, i)
                    }
                }
            },
            Dh = {
                kernelName: Me,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        transposeA: a,
                        transposeB: i
                    } = n;
                    return a || i ? !a && i ? {
                        a: () => Do(e, r, !1, !1),
                        b: () => Do(e, s, !0, !1)
                    } : a && !i ? {
                        a: () => Do(r, e, !1, !0),
                        b: () => Do(s, e, !1, !1)
                    } : {
                        a: () => Do(r, e, !0, !0),
                        b: () => Do(e, s, !0, !0)
                    } : {
                        a: () => Do(e, r, !1, !0),
                        b: () => Do(s, e, !0, !1)
                    }
                }
            };
        const _h = Pr({
                spaceToBatchND_: function(e, t, n) {
                    const s = zr(e, "x", "spaceToBatchND");
                    R(s.rank >= 1 + t.length, (() => `input rank ${s.rank} should be > than [blockShape] ${t.length}`)), R(n.length === t.length, (() => `paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)), R(s.shape.reduce(((e, s, r) => r > 0 && r <= t.length ? e && (s + n[r - 1][0] + n[r - 1][1]) % t[r - 1] == 0 : e), !0), (() => `input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));
                    const r = {
                            x: s
                        },
                        a = {
                            blockShape: t,
                            paddings: n
                        };
                    return Er.runKernel(jn, r, a)
                }
            }),
            Oh = {
                kernelName: Le,
                gradFunc: (e, t, n) => {
                    const {
                        blockShape: s,
                        crops: r
                    } = n;
                    return {
                        x: () => _h(e, s, r)
                    }
                }
            },
            Mh = {
                kernelName: "BroadcastTo",
                gradFunc: (e, t, n) => {
                    const s = n,
                        r = s.inputShape,
                        a = s.shape,
                        i = Array.from(a);
                    for (let e = r.length - 1; e >= 0; e--)
                        if (r[e] === a[e]) i[e] = 1;
                        else if (1 !== r[e]) throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);
                    const o = [];
                    for (let e = 0; e < i.length; e++) i[e] > 1 && o.push(e);
                    return {
                        x: () => Ao(e, o, !0)
                    }
                }
            },
            Lh = {
                kernelName: Pe,
                gradFunc: e => ({
                    x: () => e.clone()
                })
            },
            zh = {
                kernelName: Ue,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            Bh = {
                kernelName: We,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        clipValueMin: r,
                        clipValueMax: a
                    } = n;
                    return {
                        x: () => Au(Fo(Io(s, r), Tl(s, a)), e, Ru(e))
                    }
                }
            },
            Ph = {
                kernelName: Ge,
                inputsToSave: ["x"],
                gradFunc: yh.gradFunc
            },
            Uh = {
                kernelName: He,
                saveAllInputs: !0,
                gradFunc: (e, t, n) => {
                    const s = t.map((e => e.shape)),
                        {
                            axis: r
                        } = n,
                        a = W(r, t[0].shape)[0],
                        i = s.map((e => e[a]));
                    return wu(e, i, a).map((e => () => e))
                }
            },
            Wh = {
                kernelName: je,
                inputsToSave: ["x", "filter"],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        dilations: a,
                        strides: i,
                        pad: o,
                        dataFormat: u
                    } = n;
                    return R(Bi(a), (() => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)), {
                        x: () => ro(s.shape, e, r, i, o, u),
                        filter: () => Pu(s, e, r.shape, i, o, u)
                    }
                }
            },
            Vh = {
                kernelName: Ke,
                inputsToSave: ["dy", "filter"],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        strides: a,
                        pad: i,
                        dataFormat: o,
                        dimRoundingMode: u
                    } = n;
                    return {
                        dy: () => no(e, r, a, i, o, 1, u),
                        filter: () => Pu(e, s, r.shape, a, i, o, u)
                    }
                }
            };
        const Gh = Pr({
                conv3DBackpropFilter_: function(e, t, n, s, r) {
                    let a = e;
                    4 === e.rank && (a = Vi(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
                    let i = t;
                    4 === i.rank && (i = Vi(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), R(5 === a.rank, (() => `Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)), R(5 === i.rank, (() => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)), R(5 === n.length, (() => `Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)), R(a.shape[4] === n[3], (() => `Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)), R(i.shape[4] === n[4], (() => `Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));
                    const o = {
                            x: a,
                            dy: i
                        },
                        u = {
                            strides: s,
                            pad: r,
                            filterShape: n
                        };
                    return Er.runKernel(Ye, o, u)
                }
            }),
            Hh = {
                kernelName: Xe,
                inputsToSave: ["x", "filter"],
                gradFunc: (e, t, n) => {
                    const {
                        dilations: s,
                        strides: r,
                        pad: a
                    } = n;
                    R(Bi(s), (() => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));
                    const [i, o] = t;
                    return {
                        x: () => oo(i.shape, e, o, r, a),
                        filter: () => Gh(i, e, o.shape, r, a)
                    }
                }
            };
        const jh = Pr({
                sin_: function(e) {
                    const t = {
                        x: zr(e, "x", "sin", "float32")
                    };
                    return Er.runKernel(Bn, t)
                }
            }),
            qh = {
                kernelName: Ze,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(Xo(jh(Ra(n, "float32"))), e)
                    }
                }
            };
        const Kh = Pr({
                sinh_: function(e) {
                    const t = {
                        x: zr(e, "x", "sinh")
                    };
                    return Er.runKernel(Pn, t)
                }
            }),
            Xh = {
                kernelName: Qe,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(Kh(Ra(n, "float32")), e)
                    }
                }
            };
        const Yh = Pr({
                cumsum_: function(e, t = 0, n = !1, s = !1) {
                    const r = {
                            x: zr(e, "x", "cumsum")
                        },
                        a = {
                            axis: t,
                            exclusive: n,
                            reverse: s
                        };
                    return Er.runKernel(tt, r, a)
                }
            }),
            Jh = {
                kernelName: tt,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        axis: r,
                        exclusive: a,
                        reverse: i
                    } = n;
                    return {
                        x: () => {
                            const t = Go([r], s.rank);
                            let n = Yh(e, r, a, !i);
                            return null != t && (n = _u(n, t)), n
                        }
                    }
                }
            },
            Zh = {
                kernelName: at,
                inputsToSave: ["x", "filter"],
                gradFunc: (e, t, n) => {
                    const {
                        dilations: s,
                        strides: r,
                        pad: a,
                        dimRoundingMode: i
                    } = n, o = null == s ? [1, 1] : s;
                    R(Bi(o), (() => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));
                    const [u, l] = t;
                    return R(4 === u.rank, (() => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`)), R(4 === l.rank, (() => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`)), R(u.shape[3] === l.shape[2], (() => `Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)), R(Pi(r, o), (() => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`)), Wi("depthwiseConv2d", a, i), {
                        x: () => Xu(u.shape, e, l, r, a, o, i),
                        filter: () => Ku(u, e, l.shape, r, a, o, i)
                    }
                }
            },
            Qh = {
                kernelName: lt,
                inputsToSave: ["x", "filter"],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, a = {
                        x: s,
                        filter: r,
                        dy: e
                    }, i = {
                        x: s,
                        filter: r,
                        dy: e
                    };
                    return {
                        x: () => Er.runKernel(ct, a, n),
                        filter: () => Er.runKernel(ht, i, n)
                    }
                }
            },
            ep = {
                kernelName: ft,
                outputsToSave: [!0],
                gradFunc: (e, t) => {
                    const [n] = t, s = {
                        dy: e,
                        y: n
                    };
                    return {
                        x: () => Er.runKernel(mt, s)
                    }
                }
            },
            tp = {
                kernelName: gt,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t, s = Co(mo(Xo(qo(n))), 2 / Math.sqrt(Math.PI));
                    return {
                        x: () => Co(e, s)
                    }
                }
            },
            np = {
                kernelName: bt,
                outputsToSave: [!0],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(e, n)
                    }
                }
            },
            sp = {
                kernelName: xt,
                inputsToSave: ["input"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        input: () => Vi(e, n.shape)
                    }
                }
            },
            rp = {
                kernelName: wt,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(e, mo(n))
                    }
                }
            },
            ap = {
                kernelName: Nt,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            ip = {
                kernelName: St,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = Ga(n.shape, s.shape);
                    return {
                        a: () => {
                            const t = ho(e, Ra(s, "float32")),
                                a = Va(n.shape, r);
                            return a.length > 0 ? Vi(Ao(t, a), n.shape) : t
                        },
                        b: () => {
                            let t = Co(e, Ra(n, "float32"));
                            const a = Va(s.shape, r);
                            a.length > 0 && (t = Vi(Ao(t, a), s.shape));
                            const i = qo(s);
                            return Xo(ho(t, Ra(i, "float32")))
                        }
                    }
                }
            };
        const op = Pr({
                rsqrt_: function(e) {
                    const t = {
                        x: zr(e, "x", "rsqrt", "float32")
                    };
                    return Er.runKernel(Dn, t)
                }
            }),
            up = {
                kernelName: Tt,
                inputsToSave: ["x", "mean", "variance", "scale"],
                gradFunc: (e, t, n) => {
                    const {
                        varianceEpsilon: s
                    } = n, [r, a, i, o] = t, u = null == o ? vi(1) : o, l = Va(a.shape, r.shape), c = [];
                    if (1 === a.rank) {
                        for (let e = 0; e < r.shape.length - 1; ++e) c.push(r.shape[e]);
                        c.push(1)
                    }
                    const h = Eo(r, a),
                        p = Co(e, u),
                        d = op(Si(i, vi(s))),
                        f = Co(Co(Co(d, d), d), vi(-.5));
                    return {
                        x: () => 1 === a.rank ? Vi(Co(Co(e, yo(Vi(d, [1, 1, 1, a.shape[0]]), c)), u), r.shape) : Vi(Co(Co(e, d), u), r.shape),
                        mean: () => {
                            let e = Co(Co(d, vi(-1)), p);
                            return 1 === a.rank && (e = Ao(e, l)), Vi(e, a.shape)
                        },
                        variance: () => {
                            let e = Co(Co(f, h), p);
                            return 1 === a.rank && (e = Ao(e, l)), Vi(e, a.shape)
                        },
                        scale: () => {
                            const t = Co(h, d);
                            let n = Co(e, t);
                            return 1 === a.rank && (n = Ao(n, l)), Vi(n, a.shape)
                        },
                        offset: () => {
                            let t = e;
                            return 1 === a.rank && (t = Ao(t, l)), Vi(t, a.shape)
                        }
                    }
                }
            };
        const lp = Pr({
                unsortedSegmentSum_: function(e, t, n) {
                    const s = zr(e, "x", "unsortedSegmentSum"),
                        r = zr(t, "segmentIds", "unsortedSegmentSum", "int32");
                    R(L(n), (() => "numSegments must be of dtype int"));
                    const a = {
                            x: s,
                            segmentIds: r
                        },
                        i = {
                            numSegments: n
                        };
                    return Er.runKernel(ms, a, i)
                }
            }),
            cp = {
                kernelName: $t,
                inputsToSave: ["x", "indices"],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        axis: a
                    } = n, i = W(a, s.shape)[0];
                    return {
                        x: () => {
                            const t = s.shape,
                                n = r.size,
                                o = t.slice(0, i),
                                u = o.length,
                                l = t.slice(a, t.length).slice(1),
                                c = l.length,
                                h = hp(0, u),
                                p = hp(u + 1, u + 1 + c),
                                d = pp([o, [n], l]),
                                f = Vi(e, d),
                                m = Vi(r, [n]),
                                g = pp([
                                    [u], h, p
                                ]),
                                y = _u(f, g);
                            let b = lp(y, m, s.shape[i]);
                            const x = Ho(g);
                            return b = _u(b, x), b
                        },
                        indices: () => r
                    }
                }
            };

        function hp(e, t) {
            const n = [];
            for (let s = e; s < t; ++s) n.push(s);
            return n
        }

        function pp(e) {
            const t = [];
            for (let n = 0; n < e.length; ++n)
                for (let s = 0; s < e[n].length; ++s) t.push(e[n][s]);
            return t
        }
        const dp = {
                kernelName: At,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t;
                    return {
                        a: () => Ru(n),
                        b: () => Ru(s)
                    }
                }
            },
            fp = {
                kernelName: Rt,
                gradFunc: e => ({
                    x: () => Ra(e, "float32")
                })
            },
            mp = {
                kernelName: _t,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            gp = {
                kernelName: Ot,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            yp = {
                kernelName: Mt,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            bp = {
                kernelName: Lt,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        alpha: r
                    } = n, a = vo(s, 0);
                    return {
                        x: () => Au(a, e, Co(e, r))
                    }
                }
            },
            xp = {
                kernelName: Wt,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => ho(e, Si(n, 1))
                    }
                }
            },
            wp = {
                kernelName: Ut,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => ho(e, Ra(n, "float32"))
                    }
                }
            },
            kp = {
                kernelName: "LogSoftmax",
                inputsToSave: [],
                outputsToSave: [!0],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        axis: r
                    } = n;
                    return {
                        logits: () => {
                            const t = mo(s);
                            return Eo(e, Co(Ao(e, r, !0), t))
                        }
                    }
                }
            };
        const vp = Pr({
                localResponseNormalizationBackprop_: function(e, t, n, s = 5, r = 1, a = 1, i = .5) {
                    const o = {
                            x: e,
                            y: t,
                            dy: n
                        },
                        u = {
                            depthRadius: s,
                            bias: r,
                            alpha: a,
                            beta: i
                        };
                    return Er.runKernel(qt, o, u)
                }
            }),
            Ip = {
                kernelName: jt,
                inputsToSave: ["x"],
                outputsToSave: [!0],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        depthRadius: a,
                        bias: i,
                        alpha: o,
                        beta: u
                    } = n;
                    return {
                        x: () => vp(s, r, e, a, i, o, u)
                    }
                }
            };

        function Np(e, t, n, s) {
            return t.rank < n.rank && (t = Vi(t, Wo(t.shape, s))), e.rank < n.rank && (e = Vi(e, Wo(e.shape, s))), {
                x: () => Co(e, Ra(fo(n, t), e.dtype))
            }
        }
        const Sp = {
            kernelName: Kt,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: (e, t, n) => {
                const s = n,
                    {
                        reductionIndices: r
                    } = s,
                    a = t[0],
                    i = Np(e, t[1], a, W(r, a.shape));
                return {
                    x: () => i.x()
                }
            }
        };
        const Tp = Pr({
                less_: function(e, t) {
                    let n = zr(e, "a", "less", "string_or_numeric"),
                        s = zr(t, "b", "less", "string_or_numeric");
                    [n, s] = kr(n, s), Ga(n.shape, s.shape);
                    const r = {
                        a: n,
                        b: s
                    };
                    return Er.runKernel(zt, r)
                }
            }),
            $p = {
                kernelName: Xt,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t;
                    return {
                        a: () => Co(e, Ra(Io(n, s), "float32")),
                        b: () => Co(e, Ra(Tp(n, s), "float32"))
                    }
                }
            };
        const Cp = Pr({
                maxPool3dGrad_: function(e, t, n, s, r, a, i) {
                    const o = zr(e, "dy", "maxPool3dGrad"),
                        u = zr(t, "input", "maxPool3dGrad"),
                        l = zr(n, "output", "maxPool3dGrad");
                    let c = o,
                        h = u,
                        p = l,
                        d = !1;
                    4 === u.rank && (d = !0, c = Vi(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), h = Vi(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), p = Vi(l, [1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]])), R(5 === c.rank, (() => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)), R(5 === h.rank, (() => `Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)), R(5 === p.rank, (() => `Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)), Wi("maxPool3dGrad", a, i);
                    const f = {
                            dy: c,
                            input: h,
                            output: p
                        },
                        m = {
                            filterSize: s,
                            strides: r,
                            pad: a,
                            dimRoundingMode: i
                        },
                        g = Er.runKernel(Qt, f, m);
                    return d ? Vi(g, [g.shape[1], g.shape[2], g.shape[3], g.shape[4]]) : g
                }
            }),
            Ep = {
                kernelName: Zt,
                inputsToSave: ["x"],
                outputsToSave: [!0],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        filterSize: a,
                        strides: i,
                        pad: o,
                        dimRoundingMode: u
                    } = n;
                    return {
                        x: () => Cp(e, s, r, a, i, o, u)
                    }
                }
            };
        const Ap = Pr({
                maxPoolGrad_: function(e, t, n, s, r, a, i) {
                    const o = zr(e, "dy", "maxPoolGrad"),
                        u = zr(t, "input", "maxPoolGrad"),
                        l = zr(n, "output", "maxPoolGrad");
                    R(u.rank === o.rank, (() => `Rank of input (${u.rank}) does not match rank of dy (${o.rank})`)), R(4 === o.rank, (() => `Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)), R(4 === u.rank, (() => `Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`)), Wi("maxPoolGrad", a, i);
                    const c = {
                            dy: o,
                            input: u,
                            output: l
                        },
                        h = {
                            filterSize: s,
                            strides: r,
                            pad: a,
                            dimRoundingMode: i
                        };
                    return Er.runKernel(Jt, c, h)
                }
            }),
            Rp = {
                kernelName: Yt,
                inputsToSave: ["x"],
                outputsToSave: [!0],
                gradFunc: (e, t, n) => {
                    const [s, r] = t, {
                        filterSize: a,
                        strides: i,
                        pad: o
                    } = n;
                    return {
                        x: () => Ap(e, s, r, a, i, o)
                    }
                }
            },
            Fp = {
                kernelName: tn,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        axis: r
                    } = n, a = W(r, s.shape), i = O(Uo(s.shape, a)[1]);
                    return {
                        x: () => {
                            const t = s.shape.slice();
                            a.forEach((e => {
                                t[e] = 1
                            }));
                            const n = Vi(e, t);
                            return ho(Co(n, Qo(s.shape, "float32")), i)
                        }
                    }
                }
            },
            Dp = {
                kernelName: nn,
                inputsToSave: ["x"],
                outputsToSave: [!0],
                gradFunc: (e, t, n) => {
                    const s = n,
                        {
                            axis: r
                        } = s,
                        [a, i] = t,
                        o = Np(e, i, a, W(r, a.shape));
                    return {
                        x: () => o.x()
                    }
                }
            },
            _p = {
                kernelName: sn,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t;
                    return {
                        a: () => Co(e, Ra(Tl(n, s), "float32")),
                        b: () => Co(e, Ra(vo(n, s), "float32"))
                    }
                }
            },
            Op = {
                kernelName: rn,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const s = t[0],
                        {
                            paddings: r
                        } = n,
                        a = r.map((e => e[0]));
                    return {
                        x: () => du(e, a, s.shape)
                    }
                }
            },
            Mp = {
                kernelName: an,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = Ga(n.shape, s.shape);
                    return {
                        a: () => {
                            const t = Va(n.shape, r);
                            return t.length > 0 ? Vi(Ao(e, t), n.shape) : e
                        },
                        b: () => {
                            const t = Co(e, Xo(wo(ho(n, s)))),
                                a = Va(s.shape, r);
                            return a.length > 0 ? Vi(Ao(t, a), s.shape) : t
                        }
                    }
                }
            },
            Lp = {
                kernelName: un,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = Ga(n.shape, s.shape);
                    return {
                        a: () => {
                            const t = Co(e, Ra(s, "float32")),
                                a = Va(n.shape, r);
                            return a.length > 0 ? Vi(Ao(t, a), n.shape) : t
                        },
                        b: () => {
                            const t = Co(e, Ra(n, "float32")),
                                a = Va(s.shape, r);
                            return a.length > 0 ? Vi(Ao(t, a), s.shape) : t
                        }
                    }
                }
            },
            zp = {
                kernelName: ln,
                gradFunc: e => ({
                    x: () => Xo(e)
                })
            },
            Bp = {
                kernelName: mn,
                inputsToSave: ["indices"],
                gradFunc: (e, t) => {
                    const n = t[0];
                    return {
                        indices: () => Zo(n.shape, "float32")
                    }
                }
            },
            Pp = {
                kernelName: fn,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            Up = {
                kernelName: gn,
                saveAllInputs: !0,
                gradFunc: (e, t, n) => {
                    const {
                        axis: s
                    } = n;
                    return Cu(e, s).map((e => () => e))
                }
            },
            Wp = {
                kernelName: yn,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const s = t[0],
                        {
                            paddings: r
                        } = n,
                        a = r.map((e => e[0]));
                    return {
                        x: () => du(e, a, s.shape)
                    }
                }
            },
            Vp = {
                kernelName: bn,
                inputsToSave: ["a", "b"],
                outputsToSave: [!0],
                gradFunc: (e, t) => {
                    const [n, s, r] = t, a = n, i = s, o = Ga(a.shape, i.shape);
                    return {
                        a: () => {
                            const t = Ra(i, "float32");
                            let n = Co(e, Co(t, Dl(a, Eo(t, vi(1)))));
                            const s = Va(a.shape, o);
                            return s.length > 0 && (n = Ao(n, s)), Vi(n, a.shape)
                        },
                        b: () => {
                            const t = vo(a, 0),
                                n = Au(t, So(a), Ru(a));
                            let s = Co(e, Co(r, n));
                            const u = Va(i.shape, o);
                            return u.length > 0 && (s = Ao(s, u)), Vi(s, i.shape)
                        }
                    }
                }
            },
            Gp = {
                kernelName: xn,
                inputsToSave: ["x", "alpha"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = vo(n, 0);
                    return {
                        x: () => Au(r, e, Co(e, s)),
                        alpha: () => {
                            let t = Au(r, Ru(e), Co(e, n));
                            const a = Va(s.shape, e.shape);
                            return a.length > 0 && (t = Ao(t, a)), Vi(t, s.shape)
                        }
                    }
                }
            };
        const Hp = Pr({
            cumprod_: function(e, t = 0, n = !1, s = !1) {
                const r = {
                        x: zr(e, "x", "cumprod")
                    },
                    a = {
                        axis: t,
                        exclusive: n,
                        reverse: s
                    };
                return Er.runKernel(et, r, a)
            }
        });

        function jp(e, t, n) {
            const s = e.shape.length,
                r = s - n.length,
                a = Go(n, s);
            let i = e;
            null != a && (i = _u(e, a));
            const o = i.shape.slice(),
                u = o.splice(s - n.length, n.length).reduce(((e, t) => e * t), 1);
            o.push(u);
            let l = function(e, t, n) {
                const s = e.shape.slice();
                s[n] = 1;
                const r = Vi(t, s),
                    a = Hp(e, n, !0, !1),
                    i = Hp(e, n, !0, !0),
                    o = Co(a, i);
                return Co(r, o)
            }(i.reshape(o), t, r);
            if (l = l.reshape(i.shape), null != a) {
                const e = Ho(a);
                l = _u(l, e)
            }
            return l
        }
        const qp = {
                kernelName: wn,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        axis: r
                    } = n;
                    let a = [];
                    return a = null == r ? s.shape.map(((e, t) => t)) : "number" == typeof r ? [r] : r, {
                        x: () => jp(s, e, a)
                    }
                }
            },
            Kp = {
                kernelName: pt,
                inputsToSave: ["a", "b"],
                gradFunc: (e, t) => {
                    const [n, s] = t, r = Ga(n.shape, s.shape);
                    return {
                        a: () => {
                            const t = ho(e, Ra(s, "float32")),
                                a = Va(n.shape, r);
                            return a.length > 0 ? Vi(Ao(t, a), n.shape) : t
                        },
                        b: () => {
                            let t = Co(e, Ra(n, "float32"));
                            const a = Va(s.shape, r);
                            a.length > 0 && (t = Vi(Ao(t, a), s.shape));
                            const i = qo(s);
                            return Xo(ho(t, Ra(i, "float32")))
                        }
                    }
                }
            },
            Xp = {
                kernelName: In,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => ho(e, Xo(qo(n)))
                    }
                }
            },
            Yp = {
                kernelName: An,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t, s = Co(Tl(n, 6), Wu(n));
                    return {
                        x: () => Co(e, Ra(s, "float32"))
                    }
                }
            },
            Jp = {
                kernelName: Nn,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(e, Ra(Wu(n), "float32"))
                    }
                }
            },
            Zp = {
                kernelName: Sn,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Vi(e, n.shape)
                    }
                }
            },
            Qp = {
                kernelName: Cn,
                inputsToSave: ["images"],
                gradFunc: (e, t, n) => {
                    const [s] = t, r = {
                        dy: e,
                        images: s
                    };
                    return {
                        images: () => Er.runKernel(En, r, n)
                    }
                }
            },
            ed = {
                kernelName: Tn,
                inputsToSave: ["images"],
                gradFunc: (e, t, n) => {
                    const [s] = t, r = {
                        dy: e,
                        images: s
                    };
                    return {
                        images: () => Er.runKernel($n, r, n)
                    }
                }
            },
            td = {
                kernelName: Rn,
                gradFunc: (e, t, n) => {
                    const {
                        dims: s
                    } = n, r = W(s, e.shape);
                    return {
                        x: () => lu(e, r)
                    }
                }
            },
            nd = {
                kernelName: Fn,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            },
            sd = {
                kernelName: Dn,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Xo(ho(e, Co(Dl(n, 1.5), 2)))
                    }
                }
            };
        const rd = Pr({
                logicalNot_: function(e) {
                    const t = {
                        x: zr(e, "x", "logicalNot", "bool")
                    };
                    return Er.runKernel(Gt, t)
                }
            }),
            ad = {
                kernelName: Mn,
                inputsToSave: ["condition"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        condition: () => Ra(Ru(n), "float32"),
                        t: () => Co(e, Ra(n, e.dtype)),
                        e: () => Co(e, Ra(rd(n), e.dtype))
                    }
                }
            },
            id = {
                kernelName: Ln,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => {
                            const t = vo(n, vi(0)),
                                s = vi(Tc),
                                r = vi($c),
                                a = Co(e, r),
                                i = Co(Co(e, s), mo(Ra(n, "float32")));
                            return Au(t, a, i)
                        }
                    }
                }
            },
            od = {
                kernelName: Wn,
                outputsToSave: [!0],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(e, Co(n, Eo(vi(1), n)))
                    }
                }
            },
            ud = {
                kernelName: Un,
                gradFunc: e => ({
                    x: () => Ru(e)
                })
            };
        const ld = Pr({
                cos_: function(e) {
                    const t = {
                        x: zr(e, "x", "cos", "float32")
                    };
                    return Er.runKernel(Ze, t)
                }
            }),
            cd = {
                kernelName: Bn,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(ld(Ra(n, "float32")), e)
                    }
                }
            };
        const hd = Pr({
                cosh_: function(e) {
                    const t = {
                        x: zr(e, "x", "cosh", "float32")
                    };
                    return Er.runKernel(Qe, t)
                }
            }),
            pd = {
                kernelName: Pn,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(hd(Ra(n, "float32")), e)
                    }
                }
            },
            dd = {
                kernelName: zn,
                inputsToSave: ["x"],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        begin: r,
                        size: a
                    } = n, i = s.shape, [o, u] = li(s, r, a), l = [];
                    for (let t = 0; t < e.rank; t++) l.push([o[t], i[t] - o[t] - u[t]]);
                    return {
                        x: () => tu(e, l)
                    }
                }
            },
            fd = {
                kernelName: Kn,
                outputsToSave: [!0],
                gradFunc: (e, t, n) => {
                    const [s] = t, {
                        dim: r
                    } = n, a = Co(e, s);
                    return {
                        logits: () => Eo(a, Co(Ao(a, [r], true), s))
                    }
                }
            },
            md = {
                kernelName: Vn,
                inputsToSave: ["x"],
                gradFunc: (e, t) => {
                    const [n] = t;
                    return {
                        x: () => Co(e, pu(n))
                    }
                }
            };
        const gd = Pr({
                batchToSpaceND_: function(e, t, n) {
                    const s = zr(e, "x", "batchToSpaceND"),
                        r = t.reduce(((e, t) => e * t));
                    R(s.rank >= 1 + t.length, (() => `input rank is ${s.rank} but should be > than blockShape.length ${t.length}`)), R(n.length === t.length, (() => `crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)), R(s.shape[0] % r == 0, (() => `input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`));
                    const a = {
                            x: s
                        },
                        i = {
                            blockShape: t,
                            crops: n
                        };
                    return Er.runKernel(Le, a, i)
                }
            }),
            yd = {
                kernelName: jn,
                gradFunc: (e, t, n) => {
                    const {
                        blockShape: s,
                        paddings: r
                    } = n;
                    return {
                        x: () => gd(e, s, r)
                    }
                }
            },
            bd = {
                kernelName: qn,
                gradFunc: (e, t, n) => {
                    const {
                        axis: s
                    } = n;
                    return {
                        x: () => Ji(e, s)
                    }
                }
            };
        const xd = [yh, bh, xh, wh, kh, vh, Ih, Nh, Sh, Th, $h, Ch, Ah, Fh, Dh, Oh, Mh, Lh, zh, Bh, Ph, Uh, Vh, Wh, Hh, qh, Xh, Jh, Zh, Qh, Kp, ep, tp, np, sp, rp, ip, ap, up, cp, dp, fp, mp, gp, yp, bp, xp, wp, kp, Ip, Sp, Sp, $p, Ep, Rp, Fp, Dp, _p, Op, Mp, Lp, zp, Bp, Pp, Up, Wp, Wp, Vp, Gp, qp, Xp, Yp, Jp, Zp, Qp, ed, td, nd, sd, ad, id, od, ud, cd, pd, dd, fd, md, yd, yd, bd, bd, {
            kernelName: Gn,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => ho(e, Co(ku(Ra(n, "float32")), 2))
                }
            }
        }, {
            kernelName: es,
            inputsToSave: ["a", "b"],
            gradFunc: (e, t) => {
                const [n, s] = t, r = vi(2);
                return {
                    a: () => Co(e, Co(r, Eo(n, s))),
                    b: () => Co(e, Co(r, Eo(s, n)))
                }
            }
        }, {
            kernelName: ts,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => Co(e, Co(Ra(n, "float32"), 2))
                }
            }
        }, {
            kernelName: ys,
            gradFunc: e => ({
                x: () => Ru(e)
            })
        }, {
            kernelName: is,
            inputsToSave: ["a", "b"],
            gradFunc: (e, t) => {
                const [n, s] = t, r = Ga(n.shape, s.shape);
                return {
                    a: () => {
                        let t = e;
                        const s = Va(n.shape, r);
                        return s.length > 0 && (t = Ao(t, s)), Vi(t, n.shape)
                    },
                    b: () => {
                        let t = e;
                        const n = Va(s.shape, r);
                        return n.length > 0 && (t = Ao(t, n)), Vi(Xo(t), s.shape)
                    }
                }
            }
        }, {
            kernelName: Hn,
            inputsToSave: ["x"],
            gradFunc: (e, t, n) => {
                const [s] = t, r = s.shape.slice(), {
                    axis: a
                } = n;
                W(a, s.shape).forEach((e => {
                    r[e] = 1
                }));
                const i = Vi(e, r),
                    o = Co(i, Qo(s.shape, "float32"));
                return {
                    x: () => o
                }
            }
        }, {
            kernelName: os,
            inputsToSave: ["x"],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => ho(e, qo(ld(n)))
                }
            }
        }, {
            kernelName: us,
            outputsToSave: [!0],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => Co(Eo(vi(1), qo(n)), e)
                }
            }
        }, {
            kernelName: ls,
            inputsToSave: ["x"],
            gradFunc: (e, t, n) => {
                const [s] = t, {
                    reps: r
                } = n;
                return {
                    x: () => {
                        let t = Ru(s);
                        if (1 === s.rank)
                            for (let n = 0; n < r[0]; ++n) t = Si(t, du(e, [n * s.shape[0]], [s.shape[0]]));
                        else if (2 === s.rank)
                            for (let n = 0; n < r[0]; ++n)
                                for (let a = 0; a < r[1]; ++a) t = Si(t, du(e, [n * s.shape[0], a * s.shape[1]], [s.shape[0], s.shape[1]]));
                        else if (3 === s.rank)
                            for (let n = 0; n < r[0]; ++n)
                                for (let a = 0; a < r[1]; ++a)
                                    for (let i = 0; i < r[2]; ++i) t = Si(t, du(e, [n * s.shape[0], a * s.shape[1], i * s.shape[2]], [s.shape[0], s.shape[1], s.shape[2]]));
                        else {
                            if (4 !== s.rank) throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);
                            for (let n = 0; n < r[0]; ++n)
                                for (let a = 0; a < r[1]; ++a)
                                    for (let i = 0; i < r[2]; ++i)
                                        for (let o = 0; o < r[3]; ++o) t = Si(t, du(e, [n * s.shape[0], a * s.shape[1], i * s.shape[2], o * s.shape[3]], [s.shape[0], s.shape[1], s.shape[2], s.shape[3]]))
                        }
                        return t
                    }
                }
            }
        }, {
            kernelName: ps,
            gradFunc: (e, t, n) => {
                const s = n,
                    {
                        perm: r
                    } = s,
                    a = Ho(r);
                return {
                    x: () => _u(e, a)
                }
            }
        }, {
            kernelName: fs,
            gradFunc: (e, t, n) => {
                const s = n,
                    {
                        axis: r
                    } = s;
                return {
                    value: () => Iu(e, r)
                }
            }
        }, {
            kernelName: ms,
            inputsToSave: ["segmentIds"],
            gradFunc: (e, t) => {
                const [n] = t;
                return {
                    x: () => function(e, t) {
                        const n = Mo(t, Ru(t)),
                            s = ko(e, n);
                        let r = Io(t, vi(0, "int32"));
                        const a = s.rank - r.rank;
                        for (let e = 0; e < a; ++e) r = go(r, e + 1);
                        r = Fo(r, Qo(s.shape, "bool"));
                        const i = Ru(s);
                        return Au(r, s, i)
                    }(e, n)
                }
            }
        }, {
            kernelName: gs,
            gradFunc: e => ({
                x: () => Ru(e)
            })
        }];
        for (const e of xd) Rs(e);
        hr().prototype.abs = function() {
            return this.throwIfDisposed(), Ni(this)
        };
        const wd = Pr({
            acos_: function(e) {
                const t = {
                    x: zr(e, "x", "acos")
                };
                return Er.runKernel(xe, t)
            }
        });
        hr().prototype.acos = function() {
            return this.throwIfDisposed(), wd(this)
        };
        const kd = Pr({
            acosh_: function(e) {
                const t = {
                    x: zr(e, "x", "acosh")
                };
                return Er.runKernel(we, t)
            }
        });
        hr().prototype.acosh = function() {
            return this.throwIfDisposed(), kd(this)
        }, hr().prototype.add = function(e) {
            return this.throwIfDisposed(), Si(this, e)
        }, hr().prototype.all = function(e, t) {
            return this.throwIfDisposed(), Ti(this, e, t)
        }, hr().prototype.any = function(e, t) {
            return this.throwIfDisposed(), $i(this, e, t)
        }, hr().prototype.argMax = function(e) {
            return this.throwIfDisposed(), Ci(this, e)
        };
        const vd = Pr({
            argMin_: function(e, t = 0) {
                const n = {
                        x: zr(e, "x", "argMin")
                    },
                    s = {
                        axis: t
                    };
                return Er.runKernel(Te, n, s)
            }
        });
        hr().prototype.argMin = function(e) {
            return this.throwIfDisposed(), vd(this, e)
        }, hr().prototype.asScalar = function() {
            return this.throwIfDisposed(), R(1 === this.size, (() => "The array must have only 1 element.")), Vi(this, [])
        }, hr().prototype.asType = function(e) {
            return this.throwIfDisposed(), Ra(this, e)
        }, hr().prototype.as1D = function() {
            return this.throwIfDisposed(), Vi(this, [this.size])
        }, hr().prototype.as2D = function(e, t) {
            return this.throwIfDisposed(), Vi(this, [e, t])
        }, hr().prototype.as3D = function(e, t, n) {
            return this.throwIfDisposed(), Vi(this, [e, t, n])
        }, hr().prototype.as4D = function(e, t, n, s) {
            return this.throwIfDisposed(), Vi(this, [e, t, n, s])
        }, hr().prototype.as5D = function(e, t, n, s, r) {
            return this.throwIfDisposed(), Vi(this, [e, t, n, s, r])
        };
        const Id = Pr({
            asin_: function(e) {
                const t = {
                    x: zr(e, "x", "asin")
                };
                return Er.runKernel($e, t)
            }
        });
        hr().prototype.asin = function() {
            return this.throwIfDisposed(), Id(this)
        };
        const Nd = Pr({
            asinh_: function(e) {
                const t = {
                    x: zr(e, "x", "asinh")
                };
                return Er.runKernel(Ce, t)
            }
        });
        hr().prototype.asinh = function() {
            return this.throwIfDisposed(), Nd(this)
        };
        const Sd = Pr({
            atan_: function(e) {
                const t = {
                    x: zr(e, "x", "atan")
                };
                return Er.runKernel(Ee, t)
            }
        });
        hr().prototype.atan = function() {
            return this.throwIfDisposed(), Sd(this)
        };
        const Td = Pr({
            atan2_: function(e, t) {
                let n = zr(e, "a", "atan2"),
                    s = zr(t, "b", "atan2");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(Re, r)
            }
        });
        hr().prototype.atan2 = function(e) {
            return this.throwIfDisposed(), Td(this, e)
        };
        const $d = Pr({
            atanh_: function(e) {
                const t = {
                    x: zr(e, "x", "atanh")
                };
                return Er.runKernel(Ae, t)
            }
        });
        hr().prototype.atanh = function() {
            return this.throwIfDisposed(), $d(this)
        }, hr().prototype.avgPool = function(e, t, n, s) {
            return this.throwIfDisposed(), Gi(this, e, t, n, s)
        }, hr().prototype.batchToSpaceND = function(e, t) {
            return this.throwIfDisposed(), gd(this, e, t)
        }, hr().prototype.batchNorm = function(e, t, n, s, r) {
            return this.throwIfDisposed(), ji(this, e, t, n, s, r)
        }, hr().prototype.broadcastTo = function(e) {
            return this.throwIfDisposed(), Eu(this, e)
        }, hr().prototype.cast = function(e) {
            return this.throwIfDisposed(), Ra(this, e)
        };
        const Cd = Pr({
            ceil_: function(e) {
                const t = {
                    x: zr(e, "x", "ceil", "float32")
                };
                return Er.runKernel(Ue, t)
            }
        });
        hr().prototype.ceil = function() {
            return this.throwIfDisposed(), Cd(this)
        }, hr().prototype.clipByValue = function(e, t) {
            return this.throwIfDisposed(), Yi(this, e, t)
        }, hr().prototype.concat = function(e, t) {
            return this.throwIfDisposed(), e instanceof cr && (e = [e]), Ji([this, ...e], t)
        }, hr().prototype.conv1d = function(e, t, n, s, r, a) {
            return this.throwIfDisposed(), so(this, e, t, n, s, r, a)
        }, hr().prototype.conv2dTranspose = function(e, t, n, s, r) {
            return this.throwIfDisposed(), ao(this, e, t, n, s, r)
        }, hr().prototype.conv2d = function(e, t, n, s, r, a) {
            return this.throwIfDisposed(), no(this, e, t, n, s, r, a)
        }, hr().prototype.cos = function() {
            return this.throwIfDisposed(), ld(this)
        }, hr().prototype.cosh = function() {
            return this.throwIfDisposed(), hd(this)
        }, hr().prototype.cumprod = function(e, t, n) {
            return this.throwIfDisposed(), Hp(this, e, t, n)
        }, hr().prototype.cumsum = function(e, t, n) {
            return this.throwIfDisposed(), Yh(this, e, t, n)
        };
        const Ed = Pr({
            depthToSpace_: function(e, t, n = "NHWC") {
                const s = zr(e, "x", "depthToSpace", "float32"),
                    r = "NHWC" === n ? s.shape[1] : s.shape[2],
                    a = "NHWC" === n ? s.shape[2] : s.shape[3],
                    i = "NHWC" === n ? s.shape[3] : s.shape[1];
                R(t > 1, (() => `blockSize should be > 1 for depthToSpace, but was: ${t}`)), R(r * t >= 0, (() => `Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${s.shape}`)), R(a * t >= 0, (() => `Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${s.shape}`)), R(i % (t * t) == 0, (() => `Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${s.shape}`));
                const o = {
                        x: s
                    },
                    u = {
                        blockSize: t,
                        dataFormat: n
                    };
                return Er.runKernel(rt, o, u)
            }
        });
        hr().prototype.depthToSpace = function(e, t) {
            return this.throwIfDisposed(), Ed(this, e, t)
        }, hr().prototype.depthwiseConv2d = function(e, t, n, s, r, a) {
            return this.throwIfDisposed(), lo(this, e, t, n, s, r, a)
        };
        const Ad = Pr({
            dilation2d_: function(e, t, n, s, r = [1, 1], a = "NHWC") {
                const i = zr(e, "x", "dilation2d"),
                    o = zr(t, "filter", "dilation2d");
                R(3 === i.rank || 4 === i.rank, (() => `Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)), R(3 === o.rank, (() => `Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)), R("NHWC" === a, (() => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));
                let u = i,
                    l = !1;
                3 === i.rank && (u = Vi(i, [1, i.shape[0], i.shape[1], i.shape[2]]), l = !0);
                const c = {
                        x: u,
                        filter: o
                    },
                    h = {
                        strides: n,
                        pad: s,
                        dilations: r
                    },
                    p = Er.runKernel(lt, c, h);
                return l ? Vi(p, [p.shape[1], p.shape[2], p.shape[3]]) : p
            }
        });
        hr().prototype.dilation2d = function(e, t, n, s, r) {
            return this.throwIfDisposed(), Ad(this, e, t, n, s, r)
        };
        const Rd = Pr({
            divNoNan_: function(e, t) {
                let n = zr(e, "a", "div"),
                    s = zr(t, "b", "div");
                [n, s] = kr(n, s);
                const r = ho(n, s),
                    a = Ru(r),
                    i = fo(s, a);
                return Au(i, a, r)
            }
        });
        hr().prototype.divNoNan = function(e) {
            return this.throwIfDisposed(), Rd(this, e)
        }, hr().prototype.div = function(e) {
            return this.throwIfDisposed(), ho(this, e)
        };
        const Fd = Pr({
            dot_: function(e, t) {
                const n = zr(e, "t1", "dot"),
                    s = zr(t, "t2", "dot");
                R(!(1 !== n.rank && 2 !== n.rank || 1 !== s.rank && 2 !== s.rank), (() => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`));
                const r = 1 === n.rank ? n.size : n.shape[1],
                    a = 1 === s.rank ? s.size : s.shape[0];
                if (R(r === a, (() => `Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`)), 1 === n.rank && 1 === s.rank) {
                    const e = Vi(n, [1, -1]),
                        t = Vi(s, [-1, 1]),
                        r = Do(e, t);
                    return Vi(r, [])
                }
                if (1 === n.rank && 2 === s.rank) {
                    const e = Vi(n, [1, -1]),
                        t = Vi(s, [s.shape[0], s.shape[1]]),
                        r = Do(e, t);
                    return Vi(r, [r.size])
                }
                if (2 === n.rank && 1 === s.rank) {
                    const e = Vi(s, [-1, 1]),
                        t = Do(n, e);
                    return Vi(t, [t.size])
                } {
                    const e = Vi(s, [s.shape[0], s.shape[1]]);
                    return Do(n, e)
                }
            }
        });
        hr().prototype.dot = function(e) {
            return this.throwIfDisposed(), Fd(this, e)
        }, hr().prototype.elu = function() {
            return this.throwIfDisposed(), po(this)
        }, hr().prototype.equal = function(e) {
            return this.throwIfDisposed(), fo(this, e)
        };
        const Dd = Pr({
            erf_: function(e) {
                let t = zr(e, "x", "erf");
                R("int32" === t.dtype || "float32" === t.dtype, (() => "Input dtype must be `int32` or `float32`.")), "int32" === t.dtype && (t = Ra(t, "float32"));
                const n = {
                    x: t
                };
                return Er.runKernel(gt, n)
            }
        });
        hr().prototype.erf = function() {
            return this.throwIfDisposed(), Dd(this)
        };
        const _d = Pr({
            euclideanNorm_: function(e, t = null, n = !1) {
                return Ol(e, "euclidean", t, n)
            }
        });
        hr().prototype.euclideanNorm = function(e, t) {
            return this.throwIfDisposed(), _d(this, e, t)
        }, hr().prototype.exp = function() {
            return this.throwIfDisposed(), mo(this)
        }, hr().prototype.expandDims = function(e) {
            return this.throwIfDisposed(), go(this, e)
        };
        const Od = Pr({
            expm1_: function(e) {
                const t = {
                    x: zr(e, "x", "expm1")
                };
                return Er.runKernel(wt, t)
            }
        });
        hr().prototype.expm1 = function() {
            return this.throwIfDisposed(), Od(this)
        }, hr().prototype.fft = function() {
            return this.throwIfDisposed(), Mu(this)
        }, hr().prototype.flatten = function() {
            return this.throwIfDisposed(), Vi(this, [this.size])
        }, hr().prototype.floor = function() {
            return this.throwIfDisposed(), wo(this)
        }, hr().prototype.floorDiv = function(e) {
            return this.throwIfDisposed(), co(this, e)
        }, hr().prototype.gather = function(e, t) {
            return this.throwIfDisposed(), ko(this, e, t)
        }, hr().prototype.greaterEqual = function(e) {
            return this.throwIfDisposed(), Io(this, e)
        }, hr().prototype.greater = function(e) {
            return this.throwIfDisposed(), vo(this, e)
        }, hr().prototype.ifft = function() {
            return this.throwIfDisposed(), zu(this)
        }, hr().prototype.irfft = function() {
            return this.throwIfDisposed(), Bu(this)
        };
        const Md = Pr({
            isFinite_: function(e) {
                const t = {
                    x: zr(e, "x", "isFinite")
                };
                return Er.runKernel(_t, t)
            }
        });
        hr().prototype.isFinite = function() {
            return this.throwIfDisposed(), Md(this)
        };
        const Ld = Pr({
            isInf_: function(e) {
                const t = {
                    x: zr(e, "x", "isInf")
                };
                return Er.runKernel(Ot, t)
            }
        });
        hr().prototype.isInf = function() {
            return this.throwIfDisposed(), Ld(this)
        };
        const zd = Pr({
            isNaN_: function(e) {
                const t = {
                    x: zr(e, "x", "isNaN")
                };
                return Er.runKernel(Mt, t)
            }
        });
        hr().prototype.isNaN = function() {
            return this.throwIfDisposed(), zd(this)
        }, hr().prototype.leakyRelu = function(e) {
            return this.throwIfDisposed(), No(this, e)
        }, hr().prototype.lessEqual = function(e) {
            return this.throwIfDisposed(), Tl(this, e)
        }, hr().prototype.less = function(e) {
            return this.throwIfDisposed(), Tp(this, e)
        };
        const Bd = Pr({
            localResponseNormalization_: function(e, t = 5, n = 1, s = 1, r = .5) {
                const a = zr(e, "x", "localResponseNormalization");
                R(4 === a.rank || 3 === a.rank, (() => `Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)), R(L(t), (() => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));
                let i = a,
                    o = !1;
                3 === a.rank && (o = !0, i = Vi(a, [1, a.shape[0], a.shape[1], a.shape[2]]));
                const u = {
                        x: i
                    },
                    l = {
                        depthRadius: t,
                        bias: n,
                        alpha: s,
                        beta: r
                    },
                    c = Er.runKernel(jt, u, l);
                return o ? Vi(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
            }
        });
        hr().prototype.localResponseNormalization = function(e, t, n, s) {
            return this.throwIfDisposed(), Bd(this, e, t, n, s)
        };
        const Pd = Pr({
            logSigmoid_: function(e) {
                const t = zr(e, "x", "logSigmoid");
                return ki((e => ({
                    value: Xo(xu(Xo(e))),
                    gradFunc: t => Co(t, pu(Xo(e)))
                })))(t)
            }
        });
        hr().prototype.logSigmoid = function() {
            return this.throwIfDisposed(), Pd(this)
        }, hr().prototype.logSoftmax = function(e) {
            return this.throwIfDisposed(), Ro(this, e)
        }, hr().prototype.logSumExp = function(e, t) {
            return this.throwIfDisposed(), Wl(this, e, t)
        }, hr().prototype.log = function() {
            return this.throwIfDisposed(), So(this)
        }, hr().prototype.log1p = function() {
            return this.throwIfDisposed(), To(this)
        }, hr().prototype.logicalAnd = function(e) {
            return this.throwIfDisposed(), Fo(this, e)
        }, hr().prototype.logicalNot = function() {
            return this.throwIfDisposed(), rd(this)
        };
        const Ud = Pr({
            logicalOr_: function(e, t) {
                const n = zr(e, "a", "logicalOr", "bool"),
                    s = zr(t, "b", "logicalOr", "bool");
                Ga(n.shape, s.shape);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(Ht, r)
            }
        });
        hr().prototype.logicalOr = function(e) {
            return this.throwIfDisposed(), Ud(this, e)
        };
        const Wd = Pr({
            logicalXor_: function(e, t) {
                const n = zr(e, "a", "logicalXor", "bool"),
                    s = zr(t, "b", "logicalXor", "bool");
                return Ga(n.shape, s.shape), Fo(Ud(e, t), rd(Fo(e, t)))
            }
        });
        hr().prototype.logicalXor = function(e) {
            return this.throwIfDisposed(), Wd(this, e)
        }, hr().prototype.matMul = function(e, t, n) {
            return this.throwIfDisposed(), Do(this, e, t, n)
        }, hr().prototype.maxPool = function(e, t, n, s) {
            return this.throwIfDisposed(), _o(this, e, t, n, s)
        }, hr().prototype.max = function(e, t) {
            return this.throwIfDisposed(), $o(this, e, t)
        }, hr().prototype.maximum = function(e) {
            return this.throwIfDisposed(), Mo(this, e)
        }, hr().prototype.mean = function(e, t) {
            return this.throwIfDisposed(), Lo(this, e, t)
        }, hr().prototype.min = function(e, t) {
            return this.throwIfDisposed(), Fl(this, e, t)
        }, hr().prototype.minimum = function(e) {
            return this.throwIfDisposed(), zo(this, e)
        };
        const Vd = Pr({
            mirrorPad_: function(e, t, n) {
                R("reflect" === n || "symmetric" === n, (() => `Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));
                const s = zr(e, "x", "mirrorPad");
                if (0 === s.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
                R(t.length === s.rank, (() => `Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`));
                const r = "reflect" === n ? 1 : 0;
                for (let e = 0; e < s.rank; e++) R(2 === t[e].length, (() => "Invalid number of paddings. Must be length of 2 each.")), R(t[e][0] >= 0 && t[e][0] <= s.shape[e] - r && t[e][1] >= 0 && t[e][1] <= s.shape[e] - r, (() => `Padding in dimension ${e} cannot be greater than or equal to ${s.shape[e]-r} or less than 0 for input of shape ${s.shape}`));
                const a = {
                        paddings: t,
                        mode: n
                    },
                    i = {
                        x: s
                    };
                return Er.runKernel(rn, i, a)
            }
        });
        hr().prototype.mirrorPad = function(e, t) {
            return this.throwIfDisposed(), Vd(this, e, t)
        };
        const Gd = Pr({
            mod_: function(e, t) {
                let n = zr(e, "a", "mod"),
                    s = zr(t, "b", "mod");
                [n, s] = kr(n, s);
                const r = {
                    a: n,
                    b: s
                };
                return Er.runKernel(an, r)
            }
        });
        hr().prototype.mod = function(e) {
            return this.throwIfDisposed(), Gd(this, e)
        }, hr().prototype.mul = function(e) {
            return this.throwIfDisposed(), Co(this, e)
        }, hr().prototype.neg = function() {
            return this.throwIfDisposed(), Xo(this)
        }, hr().prototype.norm = function(e, t, n) {
            return this.throwIfDisposed(), Ol(this, e, t, n)
        }, hr().prototype.notEqual = function(e) {
            return this.throwIfDisposed(), Yo(this, e)
        }, hr().prototype.oneHot = function(e, t = 1, n = 0) {
            return this.throwIfDisposed(), Jo(this, e, t, n)
        }, hr().prototype.onesLike = function() {
            return this.throwIfDisposed(), eu(this)
        }, hr().prototype.pad = function(e, t) {
            return this.throwIfDisposed(), tu(this, e, t)
        };
        const Hd = Pr({
            pool_: function(e, t, n, s, r, a, i) {
                null == r && (r = [1, 1]), null == a && (a = 1), 0 === s && (s = "valid");
                const o = zr(e, "x", "maxPool");
                let u = o,
                    l = !1;
                3 === o.rank && (l = !0, u = Vi(o, [1, o.shape[0], o.shape[1], o.shape[2]])), R(Pi(a, r), (() => `Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`));
                const c = Ai(u.shape, t, a, r, s),
                    h = [c.dilationHeight, c.dilationWidth];
                let p;
                p = "same" === s ? function(e, t) {
                    const n = e.map(((e, n) => e + (e - 1) * (t[n] - 1))),
                        s = n.map((e => e - 1)),
                        r = s.map((e => Math.floor(e / 2))),
                        a = s.map(((e, t) => e - r[t]));
                    return s.map(((e, t) => [r[t], a[t]]))
                }([c.filterHeight, c.filterWidth], h) : [
                    [0, 0],
                    [0, 0]
                ];
                const d = 1 === h[0] && 1 === h[1],
                    [f, m] = function(e, t, n) {
                        const s = n.map((e => e[0])),
                            r = n.map((e => e[1])),
                            a = e.concat(s, r),
                            i = t.map(((e, t) => (e - a[t] % e) % e)),
                            o = r.map(((e, t) => e + i[t])),
                            u = t.map(((e, t) => [s[t], o[t]])),
                            l = t.map(((e, t) => [0, i[t]]));
                        return [u, l]
                    }([c.inHeight, c.inWidth], h, p),
                    g = d ? s : "valid",
                    y = d ? u : _h(u, h, f),
                    b = ("avg" === n ? () => Gi(y, t, a, g, i) : () => _o(y, t, a, g, i))(),
                    x = d ? b : gd(b, h, m);
                return l ? Vi(x, [x.shape[1], x.shape[2], x.shape[3]]) : x
            }
        });
        hr().prototype.pool = function(e, t, n, s, r, a) {
            return this.throwIfDisposed(), Hd(this, e, t, n, s, r, a)
        }, hr().prototype.pow = function(e) {
            return this.throwIfDisposed(), Dl(this, e)
        }, hr().prototype.prelu = function(e) {
            return this.throwIfDisposed(), nu(this, e)
        };
        const jd = Pr({
            prod_: function(e, t = null, n = !1) {
                let s = zr(e, "x", "prod");
                "bool" === s.dtype && (s = Ra(s, "int32"));
                const r = {
                        x: s
                    },
                    a = {
                        axis: t,
                        keepDims: n
                    };
                return Er.runKernel(wn, r, a)
            }
        });
        hr().prototype.prod = function(e, t) {
            return this.throwIfDisposed(), jd(this, e, t)
        };
        const qd = Pr({
            reciprocal_: function(e) {
                const t = {
                    x: zr(e, "x", "reciprocal")
                };
                return Er.runKernel(In, t)
            }
        });
        hr().prototype.reciprocal = function() {
            return this.throwIfDisposed(), qd(this)
        }, hr().prototype.relu = function() {
            return this.throwIfDisposed(), uu(this)
        }, hr().prototype.relu6 = function() {
            return this.throwIfDisposed(), Uu(this)
        }, hr().prototype.reshapeAs = function(e) {
            return this.throwIfDisposed(), Vi(this, e.shape)
        }, hr().prototype.reshape = function(e) {
            return this.throwIfDisposed(), Vi(this, e)
        }, hr().prototype.resizeBilinear = function(e, t, n) {
            return this.throwIfDisposed(), Il(this, e, t, n)
        }, hr().prototype.resizeNearestNeighbor = function(e, t, n) {
            return this.throwIfDisposed(), Nl(this, e, t, n)
        }, hr().prototype.reverse = function(e) {
            return this.throwIfDisposed(), lu(this, e)
        }, hr().prototype.rfft = function() {
            return this.throwIfDisposed(), Lu(this)
        }, hr().prototype.round = function() {
            return this.throwIfDisposed(), $l(this)
        }, hr().prototype.rsqrt = function() {
            return this.throwIfDisposed(), op(this)
        }, hr().prototype.selu = function() {
            return this.throwIfDisposed(), cu(this)
        }, hr().prototype.separableConv2d = function(e, t, n, s, r, a) {
            return this.throwIfDisposed(), hu(this, e, t, n, s, r, a)
        }, hr().prototype.sigmoid = function() {
            return this.throwIfDisposed(), pu(this)
        };
        const Kd = Pr({
            sign_: function(e) {
                const t = {
                    x: zr(e, "x", "sign")
                };
                return Er.runKernel(Un, t)
            }
        });
        hr().prototype.sign = function() {
            return this.throwIfDisposed(), Kd(this)
        }, hr().prototype.sin = function() {
            return this.throwIfDisposed(), jh(this)
        }, hr().prototype.sinh = function() {
            return this.throwIfDisposed(), Kh(this)
        }, hr().prototype.slice = function(e, t) {
            return this.throwIfDisposed(), du(this, e, t)
        }, hr().prototype.softmax = function(e) {
            return this.throwIfDisposed(), bu(this, e)
        }, hr().prototype.softplus = function() {
            return this.throwIfDisposed(), xu(this)
        }, hr().prototype.spaceToBatchND = function(e, t) {
            return this.throwIfDisposed(), _h(this, e, t)
        }, hr().prototype.split = function(e, t) {
            return this.throwIfDisposed(), wu(this, e, t)
        }, hr().prototype.sqrt = function() {
            return this.throwIfDisposed(), ku(this)
        }, hr().prototype.square = function() {
            return this.throwIfDisposed(), qo(this)
        }, hr().prototype.squaredDifference = function(e) {
            return this.throwIfDisposed(), Ul(this, e)
        }, hr().prototype.squeeze = function(e) {
            return this.throwIfDisposed(), vu(this, e)
        }, hr().prototype.stack = function(e, t) {
            this.throwIfDisposed();
            const n = e instanceof cr ? [this, e] : [this, ...e];
            return Iu(n, t)
        }, hr().prototype.step = function(e) {
            return this.throwIfDisposed(), Wu(this, e)
        };
        const Xd = Pr({
            stridedSlice_: function(e, t, n, s, r = 0, a = 0, i = 0, o = 0, u = 0) {
                const l = {
                        x: zr(e, "x", "stridedSlice", "string_or_numeric")
                    },
                    c = {
                        begin: t,
                        end: n,
                        strides: s,
                        beginMask: r,
                        endMask: a,
                        ellipsisMask: i,
                        newAxisMask: o,
                        shrinkAxisMask: u
                    };
                return Er.runKernel(ns, l, c)
            }
        });
        hr().prototype.stridedSlice = function(e, t, n, s, r, a, i, o) {
            return this.throwIfDisposed(), Xd(this, e, t, n, s, r, a, i, o)
        }, hr().prototype.sub = function(e) {
            return this.throwIfDisposed(), Eo(this, e)
        }, hr().prototype.sum = function(e, t) {
            return this.throwIfDisposed(), Ao(this, e, t)
        };
        const Yd = Pr({
            tan_: function(e) {
                const t = {
                    x: zr(e, "x", "tan", "float32")
                };
                return Er.runKernel(os, t)
            }
        });
        hr().prototype.tan = function() {
            return this.throwIfDisposed(), Yd(this)
        }, hr().prototype.tanh = function() {
            return this.throwIfDisposed(), Nu(this)
        }, hr().prototype.tile = function(e) {
            return this.throwIfDisposed(), yo(this, e)
        }, hr().prototype.toBool = function() {
            return this.throwIfDisposed(), Ra(this, "bool")
        }, hr().prototype.toFloat = function() {
            return this.throwIfDisposed(), Ra(this, "float32")
        }, hr().prototype.toInt = function() {
            return this.throwIfDisposed(), Ra(this, "int32")
        };
        const Jd = Pr({
            topk_: function(e, t = 1, n = !0) {
                const s = zr(e, "x", "topk");
                if (0 === s.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
                const r = s.shape[s.shape.length - 1];
                if (t < 0) throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
                if (t > r) throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);
                const a = {
                        x: s
                    },
                    i = {
                        k: t,
                        sorted: n
                    },
                    [o, u] = Er.runKernel(cs, a, i);
                return {
                    values: o,
                    indices: u
                }
            }
        });
        hr().prototype.topk = function(e, t) {
            return this.throwIfDisposed(), Jd(this, e, t)
        }, hr().prototype.transpose = function(e) {
            return this.throwIfDisposed(), _u(this, e)
        };
        const Zd = Pr({
            unique_: function(e, t = 0) {
                const n = zr(e, "x", "unique", "string_or_numeric");
                R(n.rank > 0, (() => "The input tensor must be at least 1D"));
                const s = {
                        x: n
                    },
                    r = {
                        axis: t
                    },
                    [a, i] = Er.runKernel(ds, s, r);
                return {
                    values: a,
                    indices: i
                }
            }
        });
        hr().prototype.unique = function(e) {
            return this.throwIfDisposed(), Zd(this, e)
        }, hr().prototype.unsortedSegmentSum = function(e, t) {
            return this.throwIfDisposed(), lp(this, e, t)
        }, hr().prototype.unstack = function(e) {
            return this.throwIfDisposed(), Cu(this, e)
        }, hr().prototype.where = function(e, t) {
            return this.throwIfDisposed(), Au(e, this, t)
        }, hr().prototype.zerosLike = function() {
            return this.throwIfDisposed(), Ru(this)
        };
        class Qd extends Error {
            constructor(e) {
                super(e), Object.setPrototypeOf(this, Qd.prototype)
            }
        }
        class ef extends Error {
            constructor(e) {
                super(e), Object.setPrototypeOf(this, ef.prototype)
            }
        }
        class tf extends Error {
            constructor(e) {
                super(e), Object.setPrototypeOf(this, tf.prototype)
            }
        }
        class nf extends Error {
            constructor(e) {
                super(e), Object.setPrototypeOf(this, nf.prototype)
            }
        }
        class sf extends Error {
            constructor(e) {
                super(e), Object.setPrototypeOf(this, sf.prototype)
            }
        }
        Error;
        class rf {
            constructor(e) {
                this.maxEntries = e || 100, this.cache = new Map
            }
            get(e) {
                let t;
                return this.cache.has(e) && (t = this.cache.get(e), this.cache.delete(e), this.cache.set(e, t)), t
            }
            put(e, t) {
                if (this.cache.has(e)) this.cache.delete(e);
                else if (this.cache.size >= this.maxEntries) {
                    const e = this.cache.keys().next().value;
                    this.cache.delete(e)
                }
                this.cache.set(e, t)
            }
            getMaxEntries() {
                return this.maxEntries
            }
            setMaxEntries(e) {
                if (e < 0) throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);
                if (this.maxEntries > e)
                    for (let t = 0; t < this.maxEntries - e; t++) {
                        const e = this.cache.keys().next().value;
                        this.cache.delete(e)
                    }
                this.maxEntries = e
            }
        }

        function af(e, t) {
            if (Array.isArray(e)) {
                let n = [];
                for (let s = 0; s < t; s++) n = n.concat(e);
                return n
            } {
                const n = new Array(t);
                return n.fill(e), n
            }
        }

        function of(e, t) {
            if (!e) throw new sf(t)
        }

        function uf(e, t) {
            let n = 0;
            for (const s of e) s === t && n++;
            return n
        }

        function lf(e) {
            return 1 === e.length ? e[0] : e
        }

        function cf(e) {
            return Array.isArray(e) ? e : [e]
        }

        function hf(e) {
            const t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
            return "_" !== t[0] ? t : "private" + t
        }

        function pf(e) {
            return e.length <= 1 || -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, ((e, t) => t.toUpperCase()))
        }
        let df = {};

        function ff(e) {
            if (null == e) return null;
            const t = {};
            return t.className = e.getClassName(), t.config = e.getConfig(), t
        }

        function mf(e) {
            if (null != e && "object" == typeof e)
                if (Array.isArray(e)) e.forEach((e => mf(e)));
                else {
                    const t = Object.keys(e);
                    for (const n of t) {
                        const t = e[n];
                        null != t && "object" == typeof t && (Array.isArray(t) || "ndarray" !== t.type || "number" != typeof t.value ? mf(t) : e[n] = t.value)
                    }
                }
        }

        function gf(e, t = {}, n = {}, s = "object", r = !1) {
            if ("string" == typeof e) {
                const r = e;
                let a;
                if (r in n) a = n[r];
                else if (r in df) a = df[r];
                else if (a = t[r], null == a) throw new tf(`Unknown ${s}: ${e}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
                return a
            } {
                const a = e;
                if (null == a.className || null == a.config) throw new tf(`${s}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);
                const i = a.className;
                let o, u;
                if (i in n ? [o, u] = n[i] : i in df ? [o, u] = df.className : i in t && ([o, u] = t[i]), null == o) throw new tf(`Unknown ${s}: ${i}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
                if (null != u) {
                    const e = {};
                    for (const t of Object.keys(df)) e[t] = df[t];
                    for (const t of Object.keys(n)) e[t] = n[t];
                    a.config.customObjects = e;
                    const t = Object.assign({}, df);
                    for (const e of Object.keys(n)) df[e] = n[e];
                    mf(a.config);
                    const s = u(o, a.config, n, r);
                    return df = Object.assign({}, t), s
                } {
                    const e = Object.assign({}, df);
                    for (const e of Object.keys(n)) df[e] = n[e];
                    const t = new o(a.config);
                    return df = Object.assign({}, e), t
                }
            }
        }

        function yf(e, t) {
            return -1 * function(e, t) {
                return e < t ? -1 : e > t ? 1 : 0
            }(e, t)
        }

        function bf(e) {
            if (null == e) return e;
            const t = [];
            for (const n of e) - 1 === t.indexOf(n) && t.push(n);
            return t
        }

        function xf(e) {
            if (null == e) throw new tf(`Invalid value in obj: ${JSON.stringify(e)}`);
            for (const t in e)
                if (e.hasOwnProperty(t)) return !1;
            return !0
        }

        function wf(e, t, n) {
            if (null != n && e.indexOf(n) < 0) throw new tf(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)
        }

        function kf(e, t, n = 0, s = 1 / 0) {
            return of(n >= 0), of(s >= n), Array.isArray(e) && e.length >= n && e.length <= s && e.every((e => typeof e === t))
        }

        function vf(e, t) {
            Array.isArray(e) ? (R(e.length > 0, (() => `${t} is unexpectedly an empty array.`)), e.forEach(((e, n) => vf(e, `element ${n+1} of ${t}`)))) : R(Number.isInteger(e) && e > 0, (() => `Expected ${t} to be a positive integer, but got ${If(e)}.`))
        }

        function If(e) {
            return null === e ? "null" : Array.isArray(e) ? "[" + e.map((e => If(e))).join(",") + "]" : "string" == typeof e ? `"${e}"` : `${e}`
        }

        function Nf(e) {
            return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null
        }
        let Sf = 0;

        function Tf() {
            return Sf++
        }
        const $f = {};

        function Cf(e = "") {
            return e in $f || ($f[e] = 0), $f[e] += 1, e + $f[e].toString()
        }
        const Ef = ["channelsFirst", "channelsLast"],
            Af = ["nearest", "bilinear"],
            Rf = ["valid", "same", "causal"],
            Ff = ["max", "avg"],
            Df = ["sum", "mul", "concat", "ave"],
            _f = new Map;

        function Of(e) {
            wf(Ef, "DataFormat", e)
        }

        function Mf(e) {
            wf(Rf, "PaddingMode", e)
        }

        function Lf(e) {
            wf(Ff, "PoolMode", e)
        }
        const zf = [];

        function Bf(e, t) {
            zf.push(e);
            try {
                const e = t();
                return zf.pop(), e
            } catch (e) {
                throw zf.pop(), e
            }
        }

        function Pf(e) {
            if (!Vf(e)) throw new Error("Not a valid tensor name: '" + e + "'");
            return (0 === zf.length ? "" : zf.join("/") + "/") + e
        }

        function Uf(e) {
            if (!Vf(e)) throw new Error("Not a valid tensor name: '" + e + "'");
            _f.has(e) || _f.set(e, 0);
            const t = _f.get(e);
            if (_f.set(e, _f.get(e) + 1), t > 0) {
                const n = `${e}_${t}`;
                return _f.set(n, 1), n
            }
            return e
        }
        const Wf = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

        function Vf(e) {
            return !!e.match(Wf)
        }

        function Gf(e, t, n) {
            null == t && (t = 0), null == n && (n = e.length);
            let s = 1;
            for (let r = t; r < n; ++r) s *= e[r];
            return s
        }

        function Hf(e) {
            if (0 === e.length) return Number.NaN;
            let t = Number.POSITIVE_INFINITY;
            for (let n = 0; n < e.length; n++) {
                const s = e[n];
                s < t && (t = s)
            }
            return t
        }

        function jf(e) {
            if (0 === e.length) return Number.NaN;
            let t = Number.NEGATIVE_INFINITY;
            for (let n = 0; n < e.length; n++) {
                const s = e[n];
                s > t && (t = s)
            }
            return t
        }

        function qf(e, t) {
            if (t < e) throw new tf(`end (${t}) < begin (${e}) is forbidden.`);
            const n = [];
            for (let s = e; s < t; ++s) n.push(s);
            return n
        }
        let Kf;

        function Xf() {
            return null == Kf && (Kf = Er.backend.epsilon()), Kf
        }

        function Yf(e, t) {
            return Ra(e, t)
        }

        function Jf(e, t = -1) {
            const n = e.shape.slice();
            return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), Vi(e, n)
        }

        function Zf(e, t, n) {
            return yi((() => {
                switch (e.rank) {
                    case 1:
                        return fu(e, t, n);
                    case 2:
                        return mu(e, [t, 0], [n, e.shape[1]]);
                    case 3:
                        return gu(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);
                    case 4:
                        return yu(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);
                    case 5:
                        return du(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);
                    case 6:
                        return du(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);
                    default:
                        throw new tf(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)
                }
            }))
        }

        function Qf(e, t, n) {
            return yi((() => {
                switch (e.rank) {
                    case 1:
                        return fu(e, t, n);
                    case 2:
                        return mu(e, [0, t], [e.shape[0], n]);
                    case 3:
                        return gu(e, [0, 0, t], [e.shape[0], e.shape[1], n]);
                    case 4:
                        return yu(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);
                    default:
                        throw new tf(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)
                }
            }))
        }

        function em(e, t, n, s) {
            return yi((() => {
                switch (e.rank) {
                    case 1:
                        return fu(e, t, n);
                    case 2:
                        switch (s) {
                            case 1:
                                return Zf(e, t, n);
                            case 2:
                                return Qf(e, t, n);
                            default:
                                throw new tf(`The axis is not within the rank of the tensor ${s}`)
                        }
                    case 3:
                        switch (s) {
                            case 1:
                                return Zf(e, t, n);
                            case 2:
                                return gu(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);
                            case 3:
                                return Qf(e, t, n);
                            default:
                                throw new tf(`The axis is not within the rank of the tensor ${s}`)
                        }
                    case 4:
                        switch (s) {
                            case 1:
                                return Zf(e, t, n);
                            case 2:
                                return yu(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);
                            case 3:
                                return yu(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);
                            case 4:
                                return Qf(e, t, n);
                            default:
                                throw new tf(`The axis is not within the rank of the tensor ${s}`)
                        }
                    default:
                        throw new tf(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)
                }
            }))
        }

        function tm(e, t = -1) {
            let n;
            return t < 0 && (n = e[0].rank, t = 0 !== n ? n : 0), t === e[0].rank && (t = -1), Ji(e, t)
        }

        function nm(e, t) {
            switch (e.rank) {
                case 1:
                    return Zi([e, t]);
                case 2:
                    return Qi([e, t], 0);
                case 3:
                    return eo([e, t], 0);
                case 4:
                    return to([e, t], 0);
                default:
                    throw new tf(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)
            }
        }

        function sm(e, t) {
            if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new tf(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);
            return yo(e, t)
        }

        function rm(e, t = 0, n = 1, s, r) {
            return iu(e, t, n, s, r)
        }

        function am(e, t, n, s) {
            if (e.rank < 2 || t.rank < 2) throw new nf(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);
            if (t.rank >= 3) {
                if (e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) throw new nf(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)
            }
            if (2 === e.rank && 2 === t.rank) {
                return Ju({
                    a: e,
                    b: t,
                    transposeA: !1,
                    transposeB: !1,
                    bias: s ? um(e.rank, s, "channelsLast") : null,
                    activation: n
                })
            } {
                const r = e.shape.slice(),
                    a = r.pop();
                e = Vi(e, [-1, a]);
                const i = t.shape.slice(),
                    o = i.pop(),
                    u = i.pop(),
                    l = [...i, o],
                    c = Array.from({
                        length: t.rank
                    }, ((e, n) => 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n));
                t = Vi(_u(t, c), [u, -1]);
                const h = [...r, ...l];
                return Vi(Ju({
                    a: e,
                    b: t,
                    transposeA: !1,
                    transposeB: !1,
                    bias: s ? um(e.rank, s, "channelsLast") : null,
                    activation: n
                }), h)
            }
        }

        function im(e, t, n) {
            return yi((() => (t = Array.isArray(t) ? Su(t, "int32") : Ra(t, "int32"), ko(e, t, n))))
        }

        function om(e) {
            return Co(e, e)
        }

        function um(e, t, n) {
            const s = t.shape;
            if (1 !== t.rank && t.rank !== e) throw new tf(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);
            if (5 === e) {
                if ("channelsFirst" === n) return 1 === s.length ? Vi(t, [1, s[0], 1, 1, 1]) : Vi(t, [1, s[3], s[0], s[1], s[2]]);
                if ("channelsLast" === n) return 1 === s.length ? Vi(t, [1, 1, 1, 1, s[0]]) : Vi(t, [1].concat(s))
            } else if (4 === e) {
                if ("channelsFirst" === n) return 1 === s.length ? Vi(t, [1, s[0], 1, 1]) : Vi(t, [1, s[2], s[0], s[1]]);
                if ("channelsLast" === n) return 1 === s.length ? Vi(t, [1, 1, 1, s[0]]) : Vi(t, [1].concat(s))
            } else if (3 === e) {
                if ("channelsFirst" === n) return 1 === s.length ? Vi(t, [1, s[0], 1]) : Vi(t, [1, s[1], s[0]]);
                if ("channelsLast" === n) return 1 === s.length ? Vi(t, [1, 1, s[0]]) : Vi(t, [1].concat(s))
            } else if (e < 3) return t;
            throw new tf(`Unsupported input rank by biasAdd: ${t.rank}`)
        }

        function lm(e, t, n) {
            return yi((() => (null == n && (n = "channelsLast"), Of(n), Si(e, um(e.rank, t, n)))))
        }

        function cm(e, t, n, s) {
            return yi((() => Ou(e, t, n, s)))
        }

        function hm(e, t, n = !1) {
            return n ? e() : t()
        }
        const pm = ["fanIn", "fanOut", "fanAvg"],
            dm = ["normal", "uniform", "truncatedNormal"];
        class fm extends pi {
            fromConfigUsesCustomObjects() {
                return !1
            }
            getConfig() {
                return {}
            }
        }
        class mm extends fm {
            apply(e, t) {
                return Zo(e, t)
            }
        }
        mm.className = "Zeros", fi(mm);
        class gm extends fm {
            apply(e, t) {
                return Qo(e, t)
            }
        }
        gm.className = "Ones", fi(gm);
        class ym extends fm {
            constructor(e) {
                if (super(), "object" != typeof e) throw new tf(`Expected argument of type ConstantConfig but got ${e}`);
                if (void 0 === e.value) throw new tf(`config must have value set but got ${e}`);
                this.value = e.value
            }
            apply(e, t) {
                return yi((() => Co(vi(this.value), Qo(e, t))))
            }
            getConfig() {
                return {
                    value: this.value
                }
            }
        }
        ym.className = "Constant", fi(ym);
        class bm extends fm {
            constructor(e) {
                super(), this.DEFAULT_MINVAL = -.05, this.DEFAULT_MAXVAL = .05, this.minval = e.minval || this.DEFAULT_MINVAL, this.maxval = e.maxval || this.DEFAULT_MAXVAL, this.seed = e.seed
            }
            apply(e, t) {
                return ou(e, this.minval, this.maxval, t)
            }
            getConfig() {
                return {
                    minval: this.minval,
                    maxval: this.maxval,
                    seed: this.seed
                }
            }
        }
        bm.className = "RandomUniform", fi(bm);
        class xm extends fm {
            constructor(e) {
                super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = .05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed
            }
            apply(e, t) {
                if ("float32" !== (t = t || "float32") && "int32" !== t) throw new nf(`randomNormal does not support dType ${t}.`);
                return rm(e, this.mean, this.stddev, t, this.seed)
            }
            getConfig() {
                return {
                    mean: this.mean,
                    stddev: this.stddev,
                    seed: this.seed
                }
            }
        }
        xm.className = "RandomNormal", fi(xm);
        class wm extends fm {
            constructor(e) {
                super(), this.DEFAULT_MEAN = 0, this.DEFAULT_STDDEV = .05, this.mean = e.mean || this.DEFAULT_MEAN, this.stddev = e.stddev || this.DEFAULT_STDDEV, this.seed = e.seed
            }
            apply(e, t) {
                if ("float32" !== (t = t || "float32") && "int32" !== t) throw new nf(`truncatedNormal does not support dType ${t}.`);
                return $u(e, this.mean, this.stddev, t, this.seed)
            }
            getConfig() {
                return {
                    mean: this.mean,
                    stddev: this.stddev,
                    seed: this.seed
                }
            }
        }
        wm.className = "TruncatedNormal", fi(wm);
        class km extends fm {
            constructor(e) {
                super(), this.gain = null != e.gain ? e.gain : 1
            }
            apply(e, t) {
                return yi((() => {
                    if (2 !== e.length || e[0] !== e[1]) throw new tf("Identity matrix initializer can only be used for 2D square matrices.");
                    return Co(this.gain, bo(e[0]))
                }))
            }
            getConfig() {
                return {
                    gain: this.gain
                }
            }
        }
        km.className = "Identity", fi(km);
        class vm extends fm {
            constructor(e) {
                if (super(), e.scale < 0) throw new tf(`scale must be a positive float. Got: ${e.scale}`);
                var t;
                this.scale = null == e.scale ? 1 : e.scale, this.mode = null == e.mode ? "fanIn" : e.mode, t = this.mode, wf(pm, "FanMode", t), this.distribution = null == e.distribution ? "normal" : e.distribution,
                    function(e) {
                        wf(dm, "Distribution", e)
                    }(this.distribution), this.seed = e.seed
            }
            apply(e, t) {
                const n = function(e, t = "channelsLast") {
                        let n, s;
                        if (Of(t), 2 === e.length) n = e[0], s = e[1];
                        else if (-1 !== [3, 4, 5].indexOf(e.length)) {
                            if ("channelsFirst" === t) {
                                const t = Gf(e, 2);
                                n = e[1] * t, s = e[0] * t
                            } else if ("channelsLast" === t) {
                                const t = Gf(e, 0, e.length - 2);
                                n = e[e.length - 2] * t, s = e[e.length - 1] * t
                            }
                        } else {
                            const t = Gf(e);
                            n = Math.sqrt(t), s = Math.sqrt(t)
                        }
                        return [n, s]
                    }(e),
                    s = n[0],
                    r = n[1];
                let a = this.scale;
                if ("fanIn" === this.mode ? a /= Math.max(1, s) : "fanOut" === this.mode ? a /= Math.max(1, r) : a /= Math.max(1, (s + r) / 2), "normal" === this.distribution) {
                    const n = Math.sqrt(a);
                    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new nf(`${this.getClassName()} does not support dType ${t}.`);
                    return $u(e, 0, n, t, this.seed)
                } {
                    const n = Math.sqrt(3 * a);
                    return ou(e, -n, n, t)
                }
            }
            getConfig() {
                return {
                    scale: this.scale,
                    mode: this.mode,
                    distribution: this.distribution,
                    seed: this.seed
                }
            }
        }
        vm.className = "VarianceScaling", fi(vm);
        class Im extends vm {
            constructor(e) {
                super({
                    scale: 1,
                    mode: "fanAvg",
                    distribution: "uniform",
                    seed: null == e ? null : e.seed
                })
            }
            getClassName() {
                return vm.className
            }
        }
        Im.className = "GlorotUniform", fi(Im);
        class Nm extends vm {
            constructor(e) {
                super({
                    scale: 1,
                    mode: "fanAvg",
                    distribution: "normal",
                    seed: null == e ? null : e.seed
                })
            }
            getClassName() {
                return vm.className
            }
        }
        Nm.className = "GlorotNormal", fi(Nm);
        class Sm extends vm {
            constructor(e) {
                super({
                    scale: 2,
                    mode: "fanIn",
                    distribution: "normal",
                    seed: null == e ? null : e.seed
                })
            }
            getClassName() {
                return vm.className
            }
        }
        Sm.className = "HeNormal", fi(Sm);
        class Tm extends vm {
            constructor(e) {
                super({
                    scale: 2,
                    mode: "fanIn",
                    distribution: "uniform",
                    seed: null == e ? null : e.seed
                })
            }
            getClassName() {
                return vm.className
            }
        }
        Tm.className = "HeUniform", fi(Tm);
        class $m extends vm {
            constructor(e) {
                super({
                    scale: 1,
                    mode: "fanIn",
                    distribution: "normal",
                    seed: null == e ? null : e.seed
                })
            }
            getClassName() {
                return vm.className
            }
        }
        $m.className = "LeCunNormal", fi($m);
        class Cm extends vm {
            constructor(e) {
                super({
                    scale: 1,
                    mode: "fanIn",
                    distribution: "uniform",
                    seed: null == e ? null : e.seed
                })
            }
            getClassName() {
                return vm.className
            }
        }
        Cm.className = "LeCunNormal", fi(Cm);
        class Em extends fm {
            constructor(e) {
                if (super(), this.DEFAULT_GAIN = 1, this.gain = null == e.gain ? this.DEFAULT_GAIN : e.gain, this.seed = e.seed, null != this.seed) throw new nf("Random seed is not implemented for Orthogonal Initializer yet.")
            }
            apply(e, t) {
                return yi((() => {
                    if (e.length < 2) throw new nf("Shape must be at least 2D.");
                    e[0] * e[1] > 2e3 && console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);
                    const t = rm(e[0] > e[1] ? [e[1], e[0]] : e, 0, 1, "float32");
                    let n = Zl.gramSchmidt(t);
                    return e[0] > e[1] && (n = _u(n)), Co(this.gain, n)
                }))
            }
            getConfig() {
                return {
                    gain: this.gain,
                    seed: this.seed
                }
            }
        }
        Em.className = "Orthogonal", fi(Em);
        const Am = {
            constant: "Constant",
            glorotNormal: "GlorotNormal",
            glorotUniform: "GlorotUniform",
            heNormal: "HeNormal",
            heUniform: "HeUniform",
            identity: "Identity",
            leCunNormal: "LeCunNormal",
            leCunUniform: "LeCunUniform",
            ones: "Ones",
            orthogonal: "Orthogonal",
            randomNormal: "RandomNormal",
            randomUniform: "RandomUniform",
            truncatedNormal: "TruncatedNormal",
            varianceScaling: "VarianceScaling",
            zeros: "Zeros"
        };

        function Rm(e, t = {}) {
            return gf(e, di.getMap().classNameMap, t, "initializer")
        }

        function Fm(e) {
            return ff(e)
        }

        function Dm(e) {
            if ("string" == typeof e) {
                const t = e in Am ? Am[e] : e;
                if ("GlorotNormal" === t) return new Nm;
                if ("GlorotUniform" === t) return new Im;
                if ("HeNormal" === t) return new Sm;
                if ("HeUniform" === t) return new Tm;
                if ("LeCunNormal" === t) return new $m;
                if ("LeCunUniform" === t) return new Cm;
                {
                    const e = {};
                    return e.className = t, e.config = {}, Rm(e)
                }
            }
            return e instanceof fm ? e : Rm(e)
        }

        function _m(e) {
            return Array.isArray(e) && Array.isArray(e[0])
        }

        function Om(e) {
            return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e]
        }

        function Mm(e) {
            let t;
            if (Array.isArray(e)) {
                if (1 !== e.length) throw new tf(`Expected Tensor length to be 1; got ${e.length}`);
                t = e[0]
            } else t = e;
            return t
        }

        function Lm(e) {
            if (Array.isArray(e) && Array.isArray(e[0])) {
                if (1 === e.length) return e[0];
                throw new tf(`Expected exactly 1 Shape; got ${e.length}`)
            }
            return e
        }

        function zm(e) {
            let t = 0;
            for (const n of e) 0 === n.shape.length ? t += 1 : t += n.shape.reduce(((e, t) => e * t));
            return t
        }
        const Bm = "Variable";
        class Pm {
            constructor(e, t = "float32", n = Bm, s = !0, r = null) {
                this.dtype = null == t ? "float32" : t, this.shape = e.shape, this.id = Tf(), n = null == n ? Bm : n, this.originalName = Pf(n), this.name = Uf(this.originalName), this.trainable_ = s, this.constraint = r, this.val = function(e, t = !0, n, s) {
                    return Er.makeVariable(e, t, n, s)
                }(e, this.trainable_, this.name, this.dtype)
            }
            read() {
                return this.assertNotDisposed(), this.val
            }
            write(e) {
                return this.assertNotDisposed(),
                    function(e, t) {
                        if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape))
                    }(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this
            }
            dispose() {
                this.assertNotDisposed(), this.val.dispose()
            }
            assertNotDisposed() {
                if (this.val.isDisposed) throw new Error(`LayersVariable ${this.name} is already disposed.`)
            }
            get trainable() {
                return this.trainable_
            }
            set trainable(e) {
                this.trainable_ = e, this.val.trainable = e
            }
        }

        function Um(e) {
            return e.map((e => e.read()))
        }

        function Wm(e) {
            e.forEach((e => {
                e[0].write(e[1])
            }))
        }
        class Vm {
            constructor(e) {
                this.dtype = e.dtype, this.shape = e.shape, null != e.shape ? this.ndim = e.shape.length : this.ndim = e.ndim, this.maxNDim = e.maxNDim, this.minNDim = e.minNDim, this.axes = e.axes || {}
            }
        }
        class Gm {
            constructor(e, t, n, s, r, a, i) {
                this.dtype = e, this.shape = t, this.sourceLayer = n, this.inputs = s, this.callArgs = r, this.outputTensorIndex = i, this.id = Tf(), null != a && (this.originalName = Pf(a), this.name = Uf(this.originalName)), this.rank = t.length
            }
        }
        let Hm = 0;
        class jm {
            constructor(e, t) {
                this.callArgs = t, this.id = Hm++, this.outboundLayer = e.outboundLayer, this.inboundLayers = e.inboundLayers, this.nodeIndices = e.nodeIndices, this.tensorIndices = e.tensorIndices, this.inputTensors = e.inputTensors, this.outputTensors = e.outputTensors, this.inputMasks = e.inputMasks, this.outputMasks = e.outputMasks, this.inputShapes = e.inputShapes, this.outputShapes = e.outputShapes;
                for (const t of e.inboundLayers) null != t && t.outboundNodes.push(this);
                e.outboundLayer.inboundNodes.push(this)
            }
            getConfig() {
                const e = [];
                for (const t of this.inboundLayers) null != t ? e.push(t.name) : e.push(null);
                return {
                    outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
                    inboundLayers: e,
                    nodeIndices: this.nodeIndices,
                    tensorIndices: this.tensorIndices
                }
            }
        }
        let qm = 0;
        class Km extends pi {
            constructor(e = {}) {
                super(), this._callHook = null, this._addedWeightNames = [], this._stateful = !1, this.id = qm++, this.activityRegularizer = null, this.inputSpec = null, this.supportsMasking = !1, this._trainableWeights = [], this._nonTrainableWeights = [], this._losses = [], this._updates = [], this._built = !1, this.inboundNodes = [], this.outboundNodes = [];
                let t = e.name;
                if (!t) {
                    const e = this.getClassName();
                    t = hf(e) + "_" + Cf(e)
                }
                if (this.name = t, this.trainable_ = null == e.trainable || e.trainable, null != e.inputShape || null != e.batchInputShape) {
                    let t;
                    if (null != e.batchInputShape) t = e.batchInputShape;
                    else if (null != e.inputShape) {
                        let n = null;
                        null != e.batchSize && (n = e.batchSize), t = [n].concat(e.inputShape)
                    }
                    this.batchInputShape = t;
                    let n = e.dtype;
                    null == n && (n = e.inputDType), null == n && (n = "float32"), this.dtype = n
                }
                null != e.weights ? this.initialWeights = e.weights : this.initialWeights = null, this._refCount = null, this.fastWeightInitDuringBuild = !1
            }
            static nodeKey(e, t) {
                return e.name + "_ib-" + t.toString()
            }
            getNodeAtIndex(e, t) {
                if (0 === this.inboundNodes.length) throw new ef(`The layer has never been called and thus has no defined ${t}.`);
                if (this.inboundNodes.length <= e) throw new tf(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
                return this.inboundNodes[e]
            }
            getInputAt(e) {
                return lf(this.getNodeAtIndex(e, "input").inputTensors)
            }
            getOutputAt(e) {
                return lf(this.getNodeAtIndex(e, "output").outputTensors)
            }
            get input() {
                if (this.inboundNodes.length > 1) throw new Qd(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
                if (0 === this.inboundNodes.length) throw new Qd(`Layer ${this.name} is not connected, no input to return.`);
                return lf(this.getNodeAtIndex(0, "input").inputTensors)
            }
            get output() {
                if (0 === this.inboundNodes.length) throw new Qd(`Layer ${this.name} has no inbound nodes.`);
                if (this.inboundNodes.length > 1) throw new Qd(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
                return lf(this.getNodeAtIndex(0, "output").outputTensors)
            }
            get losses() {
                return this._losses
            }
            calculateLosses() {
                return this.losses.map((e => e()))
            }
            get updates() {
                return this._updates
            }
            get built() {
                return this._built
            }
            set built(e) {
                this._built = e
            }
            get trainable() {
                return this.trainable_
            }
            set trainable(e) {
                this._trainableWeights.forEach((t => t.trainable = e)), this.trainable_ = e
            }
            get trainableWeights() {
                return this.trainable_ ? this._trainableWeights.filter((e => e.trainable)) : []
            }
            set trainableWeights(e) {
                this._trainableWeights = e
            }
            get nonTrainableWeights() {
                return this.trainable ? this._trainableWeights.filter((e => !e.trainable)).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights)
            }
            set nonTrainableWeights(e) {
                this._nonTrainableWeights = e
            }
            get weights() {
                return this.trainableWeights.concat(this.nonTrainableWeights)
            }
            get stateful() {
                return this._stateful
            }
            resetStates() {
                if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")
            }
            assertInputCompatibility(e) {
                if (e = cf(e), null == this.inputSpec || 0 === this.inputSpec.length) return;
                const t = cf(this.inputSpec);
                if (e.length !== t.length) throw new tf(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);
                for (let n = 0; n < e.length; n++) {
                    const s = e[n],
                        r = t[n];
                    if (null == r) continue;
                    const a = s.rank;
                    if (null != r.ndim && a !== r.ndim) throw new tf(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);
                    if (null != r.maxNDim && a > r.maxNDim) throw new tf(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);
                    if (null != r.minNDim && a < r.minNDim) throw new tf(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);
                    if (null != r.dtype && s.dtype !== r.dtype) throw new tf(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${s.dtype}.`);
                    if (r.axes) {
                        const e = s.shape;
                        for (const t in r.axes) {
                            const s = Number(t),
                                a = r.axes[t],
                                i = s >= 0 ? e[s] : e[e.length + s];
                            if (null != a && -1 === [a, null].indexOf(i)) throw new tf(`Input ${n} is incompatible with layer ${this.name}: expected axis ${s} of input shape to have value ${a} but got shape ${e}.`)
                        }
                    }
                    if (null != r.shape)
                        for (let e = 0; e < r.shape.length; ++e) {
                            const t = r.shape[e],
                                a = s.shape[e];
                            if (null != t && null != a && t !== a) throw new tf(`Input ${n} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${s.shape}.`)
                        }
                }
            }
            call(e, t) {
                return e
            }
            invokeCallHook(e, t) {
                null != this._callHook && this._callHook(e, t)
            }
            setCallHook(e) {
                this._callHook = e
            }
            clearCallHook() {
                this._callHook = null
            }
            apply(e, t) {
                t = t || {}, this.assertNotDisposed();
                const n = cf(e);
                let s = !0;
                for (const e of n)
                    if (!(e instanceof Gm)) {
                        s = !1;
                        break
                    } let r = !0;
                for (const e of n)
                    if (e instanceof Gm) {
                        r = !1;
                        break
                    } if (s === r) throw new tf("Arguments to apply() must be all SymbolicTensors or all Tensors");
                return Bf(this.name, (() => {
                    if (!this.built) {
                        this.assertInputCompatibility(e);
                        const t = [];
                        for (const n of cf(e)) t.push(n.shape);
                        this.build(lf(t)), this.built = !0, this.initialWeights && this.setWeights(this.initialWeights), null === this._refCount && r && (this._refCount = 1)
                    }
                    if (this.assertInputCompatibility(e), r) {
                        let s = this.call(e, t);
                        const r = cf(s),
                            a = [];
                        for (let e of r) - 1 !== n.indexOf(e) && (e = e.clone()), a.push(e);
                        if (s = lf(a), null != this.activityRegularizer) throw new nf("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                        return s
                    } {
                        const n = function(e) {
                                e = cf(e);
                                const t = [];
                                for (const n of e) t.push(n.shape);
                                return lf(t)
                            }(e),
                            s = this.computeOutputShape(n);
                        let r;
                        const a = "float32";
                        if (this.warnOnIncompatibleInputShape(Array.isArray(e) ? n[0] : n), r = null != s && s.length > 0 && Array.isArray(s[0]) ? s.map(((n, s) => new Gm(a, n, this, cf(e), t, this.name, s))) : new Gm(a, s, this, cf(e), t, this.name), this.addInboundNode(e, r, null, null, n, s, t), this._refCount++, null != this.activityRegularizer) throw new nf("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                        return r
                    }
                }))
            }
            warnOnIncompatibleInputShape(e) {
                if (null != this.batchInputShape)
                    if (e.length !== this.batchInputShape.length) console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
                    else {
                        let t = !1;
                        this.batchInputShape.forEach(((n, s) => {
                            null != n && null != e[s] && e[s] !== n && (t = !0)
                        })), t && console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)
                    }
            }
            get outputShape() {
                if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new Qd(`The layer ${this.name} has never been called and thus has no defined output shape.`);
                const e = [];
                for (const t of this.inboundNodes) {
                    const n = JSON.stringify(t.outputShapes); - 1 === e.indexOf(n) && e.push(n)
                }
                if (1 === e.length) {
                    const e = this.inboundNodes[0].outputShapes;
                    return Array.isArray(e) && Array.isArray(e[0]) && 1 === e.length ? e[0] : e
                }
                throw new Qd(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)
            }
            countParams() {
                if (!this.built) throw new ef(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
                return zm(this.weights)
            }
            build(e) {
                this.built = !0
            }
            getWeights(e = !1) {
                return Um(e ? this.trainableWeights : this.weights)
            }
            setWeights(e) {
                yi((() => {
                    const t = this.weights;
                    if (t.length !== e.length) throw new tf(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);
                    if (0 === t.length) return;
                    const n = [],
                        s = Um(t);
                    for (let r = 0; r < s.length; ++r) {
                        const a = s[r],
                            i = t[r],
                            o = e[r];
                        if (!M(a.shape, o.shape)) throw new tf(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);
                        n.push([i, o])
                    }
                    Wm(n)
                }))
            }
            addWeight(e, t, n, s, r, a, i, o) {
                if (-1 !== this._addedWeightNames.indexOf(e)) throw new tf(`Duplicate weight name ${e} for layer ${this.name}`);
                this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (s = null != o ? o() : Dm("zeros"));
                const u = s.apply(t, n),
                    l = new Pm(u, n, e, a, i);
                return u.dispose(), null != r && this.addLoss((() => r.apply(l.read()))), null == a && (a = !0), a ? this._trainableWeights.push(l) : this._nonTrainableWeights.push(l), l
            }
            setFastWeightInitDuringBuild(e) {
                this.fastWeightInitDuringBuild = e
            }
            addLoss(e) {
                null == e || Array.isArray(e) && 0 === e.length || (e = cf(e), void 0 !== this._losses && null !== this._losses && this.losses.push(...e))
            }
            computeOutputShape(e) {
                return e
            }
            computeMask(e, t) {
                if (!this.supportsMasking) {
                    if (null != t) {
                        if (!Array.isArray(t)) throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
                        t.forEach((e => {
                            if (null != e) throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)
                        }))
                    }
                    return null
                }
                return t
            }
            addInboundNode(e, t, n, s, r, a, i = null) {
                const o = cf(e);
                t = cf(t), n = cf(n), s = cf(s), r = Om(r), a = Om(a);
                const u = [],
                    l = [],
                    c = [];
                for (const e of o) u.push(e.sourceLayer), l.push(e.nodeIndex), c.push(e.tensorIndex);
                new jm({
                    outboundLayer: this,
                    inboundLayers: u,
                    nodeIndices: l,
                    tensorIndices: c,
                    inputTensors: o,
                    outputTensors: t,
                    inputMasks: n,
                    outputMasks: s,
                    inputShapes: r,
                    outputShapes: a
                }, i);
                for (let e = 0; e < t.length; e++) t[e].sourceLayer = this, t[e].nodeIndex = this.inboundNodes.length - 1, t[e].tensorIndex = e
            }
            getConfig() {
                const e = {
                    name: this.name,
                    trainable: this.trainable
                };
                return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e
            }
            disposeWeights() {
                return this.weights.forEach((e => e.dispose())), this.weights.length
            }
            assertNotDisposed() {
                if (0 === this._refCount) throw new Error(`Layer '${this.name}' is already disposed.`)
            }
            dispose() {
                if (!this.built) throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
                if (null === this._refCount) throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
                this.assertNotDisposed();
                let e = 0;
                return 0 == --this._refCount && (e = this.disposeWeights()), {
                    refCountAfterDispose: this._refCount,
                    numDisposedVariables: e
                }
            }
        }

        function Xm(e, t, n) {
            if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
            {
                const e = t.inboundNodes[n];
                if (0 === e.inboundLayers.length) return e.inputTensors;
                {
                    const t = [];
                    for (let n = 0; n < e.inboundLayers.length; n++) {
                        const s = Xm(e.inputTensors[n], e.inboundLayers[n], e.nodeIndices[n]);
                        for (const e of s) - 1 === t.indexOf(e) && t.push(e)
                    }
                    return t
                }
            }
        }
        class Ym extends Km {
            constructor(e) {
                if (super({
                        dtype: e.dtype,
                        name: null != e.name ? e.name : Cf("input").toString()
                    }), null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), this.trainable = !1, this.built = !0, this.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new tf("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
                let t = e.batchInputShape;
                if (null == t) {
                    if (null == e.inputShape) throw new tf("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
                    t = [e.batchSize].concat(e.inputShape)
                } else if (null != e.batchSize) throw new tf("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
                const n = e.dtype || "float32";
                this.batchInputShape = t, this.dtype = n, this.inputSpec = [{
                    shape: t
                }];
                const s = new Gm(this.dtype, this.batchInputShape, this, [], {}, this.name);
                s.nodeIndex = 0, s.tensorIndex = 0, new jm({
                    outboundLayer: this,
                    inboundLayers: [],
                    nodeIndices: [],
                    tensorIndices: [],
                    inputTensors: [s],
                    outputTensors: [s],
                    inputMasks: [null],
                    outputMasks: [null],
                    inputShapes: [t],
                    outputShapes: [t]
                })
            }
            apply(e, t) {
                throw new tf(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)
            }
            dispose() {
                return {
                    refCountAfterDispose: this._refCount,
                    numDisposedVariables: 0
                }
            }
            getConfig() {
                return {
                    batchInputShape: this.batchInputShape,
                    dtype: this.dtype,
                    sparse: this.sparse,
                    name: this.name
                }
            }
        }
        Ym.className = "InputLayer", fi(Ym);
        class Jm {
            constructor(e) {
                if (this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, e instanceof Jm)
                    for (const t in e.id2Value) this.id2Value[t] = e.id2Value[t], t in e.id2Mask && (this.id2Mask[t] = e.id2Mask[t]);
                else {
                    if (null == e) return;
                    for (const t of e) this.add(t.key, t.value)
                }
            }
            add(e, t, n) {
                if (null != this.id2Value[e.id]) throw new tf(`Duplicate key: name=${e.name}, id=${e.id}`);
                return this.id2Value[e.id] = function(e, t) {
                    if (null == e.dtype || e.dtype === t.dtype) return t;
                    try {
                        return Ra(t, e.dtype)
                    } catch (n) {
                        throw new tf(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)
                    }
                }(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this
            }
            addFeed(e) {
                this.add(e.key, e.value)
            }
            hasKey(e) {
                return null != this.id2Value[e.id]
            }
            names() {
                return Object.keys(this.name2Id)
            }
            getValue(e) {
                if (e instanceof Gm) {
                    if (null == this.id2Value[e.id]) throw new tf(`Nonexistent key: ${e.name}`);
                    return this.id2Value[e.id]
                } {
                    const t = this.name2Id[e];
                    if (null == t) throw new tf(`Feed dict has no SymbolicTensor name: ${e}`);
                    return this.id2Value[t]
                }
            }
            getMask(e) {
                if (e instanceof Gm) {
                    if (null == this.id2Value[e.id]) throw new tf(`Nonexistent key: ${e.name}`);
                    return this.id2Mask[e.id]
                } {
                    const t = this.name2Id[e];
                    if (null == t) throw new tf(`Feed dict has no SymbolicTensor name: ${e}`);
                    return this.id2Mask[t]
                }
            }
            disposeMasks() {
                null != this.id2Mask && bi(this.id2Mask)
            }
        }
        const Zm = new rf,
            Qm = new rf;

        function eg(e, t, n, s) {
            const r = null != n && n.training,
                a = Array.isArray(e),
                i = a ? e : [e],
                o = i.map((e => e.name)),
                u = [],
                l = t.names();
            for (const e of o) - 1 !== l.indexOf(e) ? u.push(t.getValue(e)) : u.push(null);
            null != s && (s.maxNumTensors = -1 / 0, s.minNumTensors = 1 / 0);
            const c = o.join(",") + "|" + t.names().sort().join(",");
            let h, p = Zm.get(c);
            if (null == p) {
                const e = function(e, t) {
                    R(null != e && e.length > 0, (() => "Expected at least one fetch, got none"));
                    let n = [],
                        s = {};
                    if (1 === e.length) {
                        const r = ng(e[0], t);
                        n = r.sorted, s = r.recipientMap
                    } else {
                        const r = new Set;
                        for (const a of e) {
                            const {
                                sorted: e,
                                recipientMap: i
                            } = ng(a, t);
                            for (const t of e) r.has(t.name) || (n.push(t), r.add(t.name));
                            for (const e in i) null == s[e] && (s[e] = new Set), i[e].forEach((t => s[e].add(t)))
                        }
                    }
                    return {
                        sorted: n,
                        recipientCounts: tg(s)
                    }
                }(i, t);
                p = e.sorted, h = e.recipientCounts, Zm.put(c, p), Qm.put(c, h)
            }
            h = {}, r || Object.assign(h, Qm.get(c));
            const d = new Jm(t);
            for (let e = 0; e < p.length; ++e) {
                if (null != s) {
                    const e = gi().numTensors;
                    e > s.maxNumTensors && (s.maxNumTensors = e), e < s.minNumTensors && (s.minNumTensors = e)
                }
                const a = p[e],
                    i = a.sourceLayer;
                if (i instanceof Ym) continue;
                const l = [],
                    c = [],
                    f = [];
                let m = !1;
                for (const e of a.inputs) {
                    const n = d.getValue(e),
                        s = d.getMask(e);
                    l.push(n), c.push(s), null != s && (m = !0), r || (h[e.name]--, 0 !== h[e.name] || t.hasKey(e) || -1 !== o.indexOf(e.name) || n.isDisposed || !0 === e.sourceLayer.stateful || f.push(n))
                }
                m && ((n = n || {}).mask = c[0]);
                const g = cf(i.apply(l, n));
                let y = null;
                i.supportsMasking && (y = i.computeMask(l, c));
                const b = sg(a),
                    x = Array.isArray(b) ? b : [b];
                for (let e = 0; e < x.length; ++e) {
                    d.hasKey(x[e]) || d.add(x[e], g[e], Array.isArray(y) ? y[0] : y);
                    const t = o.indexOf(x[e].name); - 1 !== t && (u[t] = g[e])
                }
                r || bi(f)
            }
            return d.disposeMasks(), a ? u : u[0]
        }

        function tg(e) {
            const t = {};
            for (const n in e) t[n] = e[n].size;
            return t
        }

        function ng(e, t) {
            const n = new Set,
                s = [],
                r = {};
            for (const e of t.names()) n.add(e);
            const a = [],
                i = [];
            for (a.push(e); a.length > 0;) {
                const e = a[a.length - 1];
                if (n.has(e.name)) {
                    a.pop();
                    continue
                }
                const t = i[i.length - 1] === a.length - 1;
                if (0 === e.inputs.length || t) a.pop(), s.push(e), n.add(e.name), t && i.pop();
                else {
                    i.push(a.length - 1);
                    for (const t of e.inputs) null == r[t.name] && (r[t.name] = new Set), r[t.name].add(e.name), n.has(t.name) || a.push(t)
                }
            }
            return {
                sorted: s,
                recipientMap: r
            }
        }

        function sg(e) {
            let t;
            if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;
            else {
                let n = null;
                for (let t = 0; t < e.sourceLayer.inboundNodes.length; ++t)
                    for (const s of e.sourceLayer.inboundNodes[t].outputTensors)
                        if (s.id === e.id) {
                            n = t;
                            break
                        } t = e.sourceLayer.getOutputAt(n)
            }
            return t
        }

        function rg(e, t) {
            return yi((() => ku(Ao(Co(e, e), t, !0))))
        }
        de().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", (() => 100), (function(e) {
            null != Zm && Zm.setMaxEntries(e), null != Qm && Qm.setMaxEntries(e)
        }));
        class ag extends pi {
            getConfig() {
                return {}
            }
        }
        class ig extends ag {
            constructor(e) {
                super(), this.defaultMaxValue = 2, this.defaultAxis = 0, this.maxValue = null != e.maxValue ? e.maxValue : this.defaultMaxValue, this.axis = null != e.axis ? e.axis : this.defaultAxis
            }
            apply(e) {
                return yi((() => {
                    const t = rg(e, this.axis),
                        n = Yi(t, 0, this.maxValue);
                    return Co(e, ho(n, Si(Xf(), t)))
                }))
            }
            getConfig() {
                return {
                    maxValue: this.maxValue,
                    axis: this.axis
                }
            }
        }
        ig.className = "MaxNorm", fi(ig);
        class og extends ag {
            constructor(e) {
                super(), this.defaultAxis = 0, this.axis = null != e.axis ? e.axis : this.defaultAxis
            }
            apply(e) {
                return yi((() => ho(e, Si(Xf(), rg(e, this.axis)))))
            }
            getConfig() {
                return {
                    axis: this.axis
                }
            }
        }
        og.className = "UnitNorm", fi(og);
        class ug extends ag {
            apply(e) {
                return uu(e)
            }
        }
        ug.className = "NonNeg", fi(ug);
        class lg extends ag {
            constructor(e) {
                super(), this.defaultMinValue = 0, this.defaultMaxValue = 1, this.defaultRate = 1, this.defaultAxis = 0, this.minValue = null != e.minValue ? e.minValue : this.defaultMinValue, this.maxValue = null != e.maxValue ? e.maxValue : this.defaultMaxValue, this.rate = null != e.rate ? e.rate : this.defaultRate, this.axis = null != e.axis ? e.axis : this.defaultAxis
            }
            apply(e) {
                return yi((() => {
                    const t = rg(e, this.axis),
                        n = Si(Co(this.rate, Yi(t, this.minValue, this.maxValue)), Co(1 - this.rate, t));
                    return Co(e, ho(n, Si(Xf(), t)))
                }))
            }
            getConfig() {
                return {
                    minValue: this.minValue,
                    maxValue: this.maxValue,
                    rate: this.rate,
                    axis: this.axis
                }
            }
        }
        lg.className = "MinMaxNorm", fi(lg);
        const cg = {
            maxNorm: "MaxNorm",
            minMaxNorm: "MinMaxNorm",
            nonNeg: "NonNeg",
            unitNorm: "UnitNorm"
        };

        function hg(e) {
            return ff(e)
        }

        function pg(e, t = {}) {
            return gf(e, di.getMap().classNameMap, t, "constraint")
        }

        function dg(e) {
            if (null == e) return null;
            if ("string" == typeof e) {
                return pg({
                    className: e in cg ? cg[e] : e,
                    config: {}
                })
            }
            return e instanceof ag ? e : pg(e)
        }
        async function fg(e) {
            if (null == e) return;
            const t = [],
                n = [],
                s = [];
            for (const r in e) {
                const a = e[r];
                if ("number" != typeof a) {
                    const e = a;
                    t.push(e.data()), n.push(r), s.push(e)
                }
            }
            if (t.length > 0) {
                const r = await Promise.all(t);
                for (let t = 0; t < r.length; ++t) e[n[t]] = r[t][0];
                bi(s)
            }
        }

        function mg(e) {
            if (null != e)
                for (const t in e) {
                    const n = e[t];
                    "number" != typeof n && n.dispose()
                }
        }
        var gg;
        ! function(e) {
            e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE"
        }(gg || (gg = {}));
        class yg {
            constructor() {
                this.validationData = null
            }
            setParams(e) {
                this.params = e
            }
            async onEpochBegin(e, t) {}
            async onEpochEnd(e, t) {}
            async onBatchBegin(e, t) {}
            async onBatchEnd(e, t) {}
            async onTrainBegin(e) {}
            async onTrainEnd(e) {}
            setModel(e) {}
        }
        class bg {
            constructor(e, t = 10) {
                null == e && (e = []), this.callbacks = e, this.queueLength = t
            }
            append(e) {
                this.callbacks.push(e)
            }
            setParams(e) {
                for (const t of this.callbacks) t.setParams(e)
            }
            setModel(e) {
                for (const t of this.callbacks) t.setModel(e)
            }
            async onEpochBegin(e, t) {
                null == t && (t = {});
                for (const n of this.callbacks) await n.onEpochBegin(e, t)
            }
            async onEpochEnd(e, t) {
                null == t && (t = {});
                for (const n of this.callbacks) await n.onEpochEnd(e, t)
            }
            async onBatchBegin(e, t) {
                null == t && (t = {});
                for (const n of this.callbacks) await n.onBatchBegin(e, t)
            }
            async onBatchEnd(e, t) {
                null == t && (t = {});
                for (const n of this.callbacks) await n.onBatchEnd(e, t)
            }
            async onTrainBegin(e) {
                null == e && (e = {});
                for (const t of this.callbacks) await t.onTrainBegin(e)
            }
            async onTrainEnd(e) {
                null == e && (e = {});
                for (const t of this.callbacks) await t.onTrainEnd(e)
            }
        }
        class xg extends yg {
            constructor() {
                super()
            }
            async onEpochBegin(e) {
                this.seen = 0, this.totals = {}
            }
            async onBatchEnd(e, t) {
                null == t && (t = {});
                const n = null == t.size ? 0 : t.size;
                this.seen += n;
                for (const e in t) {
                    const s = t[e];
                    if ("number" == typeof s) this.totals.hasOwnProperty(e) || (this.totals[e] = 0), this.totals[e] = this.totals[e] + s * n;
                    else {
                        let t;
                        e in this.totals ? t = this.totals[e] : this.totals[e] = 0;
                        const r = yi((() => Si(this.totals[e], Co(s, n))));
                        this.totals[e] = r, null != t && t.dispose()
                    }
                }
            }
            async onEpochEnd(e, t) {
                if (null != t)
                    for (const e of this.params.metrics) null != this.totals[e] && ("number" == typeof this.totals[e] ? t[e] = this.totals[e] / this.seen : yi((() => {
                        const n = Co(ho(1, this.seen), this.totals[e]);
                        t[e] = n, this.totals[e].dispose(), xi(t[e])
                    })))
            }
        }
        class wg extends yg {
            async onTrainBegin(e) {
                this.epoch = [], this.history = {}
            }
            async onEpochEnd(e, t) {
                null == t && (t = {}), this.epoch.push(e);
                for (const e in t) null == this.history[e] && (this.history[e] = []), this.history[e].push(t[e])
            }
            async syncData() {
                const e = [],
                    t = [],
                    n = [];
                for (const s in this.history) {
                    const r = this.history[s];
                    for (let a = 0; a < r.length; ++a)
                        if ("number" != typeof r[a]) {
                            const i = r[a];
                            e.push(i.data()), t.push(s), n.push(a)
                        }
                }
                const s = await Promise.all(e);
                for (let e = 0; e < s.length; ++e) {
                    this.history[t[e]][n[e]].dispose(), this.history[t[e]][n[e]] = s[e][0]
                }
            }
        }
        class kg extends yg {
            constructor(e, t) {
                if (super(), this.currentEpoch = 0, this.nowFunc = e.nowFunc, this.nextFrameFunc = e.nextFrameFunc || hc, this.yieldEvery = t || "auto", "auto" === this.yieldEvery && (this.yieldEvery = 125), "never" === this.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
                Y(this.yieldEvery) && (this.maybeWait = function(e, t, n) {
                    let s, r = null != n ? n() : Xs();
                    return (...a) => {
                        const i = null != n ? n() : Xs();
                        return i - r < t || (r = i, s = e(...a)), s
                    }
                }(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc)), this.trainBegin = e.onTrainBegin, this.trainEnd = e.onTrainEnd, this.epochBegin = e.onEpochBegin, this.epochEnd = e.onEpochEnd, this.batchBegin = e.onBatchBegin, this.batchEnd = e.onBatchEnd, this.yield = e.onYield
            }
            async maybeWait(e, t, n) {
                const s = [];
                null != this.yield && (await fg(n), s.push(this.yield(e, t, n))), s.push(this.nextFrameFunc()), await Promise.all(s)
            }
            async onEpochBegin(e, t) {
                this.currentEpoch = e, null != this.epochBegin && (await fg(t), await this.epochBegin(e, t))
            }
            async onEpochEnd(e, t) {
                const n = [];
                null != this.epochEnd && (await fg(t), n.push(this.epochEnd(e, t))), "epoch" === this.yieldEvery && n.push(this.nextFrameFunc()), await Promise.all(n)
            }
            async onBatchBegin(e, t) {
                null != this.batchBegin && (await fg(t), await this.batchBegin(e, t))
            }
            async onBatchEnd(e, t) {
                const n = [];
                null != this.batchEnd && (await fg(t), n.push(this.batchEnd(e, t))), "batch" === this.yieldEvery ? n.push(this.nextFrameFunc()) : Y(this.yieldEvery) && n.push(this.maybeWait(this.currentEpoch, e, t)), await Promise.all(n)
            }
            async onTrainBegin(e) {
                null != this.trainBegin && (await fg(e), await this.trainBegin(e))
            }
            async onTrainEnd(e) {
                null != this.trainEnd && (await fg(e), await this.trainEnd(e))
            }
        }

        function vg(e, t) {
            if (null == e && (e = {}), e instanceof yg) return [e];
            if (Array.isArray(e) && e[0] instanceof yg) return e;
            return cf(e).map((e => new kg(e, t)))
        }
        class Ig {
            constructor() {}
            static registerCallbackConstructor(e, t) {
                R(e >= 0 && Number.isInteger(e), (() => `Verbosity level is expected to be an integer >= 0, but got ${e}`)), Ig.checkForDuplicate(t), null == Ig.constructors[e] && (Ig.constructors[e] = []), Ig.constructors[e].push(t)
            }
            static checkForDuplicate(e) {
                for (const t in Ig.constructors) {
                    Ig.constructors[+t].forEach((t => {
                        if (t === e) throw new tf("Duplicate callback constructor.")
                    }))
                }
            }
            static clear() {
                Ig.constructors = {}
            }
            static createCallbacks(e) {
                const t = [];
                for (const n in Ig.constructors) {
                    const s = +n;
                    e >= s && t.push(...Ig.constructors[s])
                }
                return t.map((e => new e))
            }
        }

        function Ng(e, t, n, s, r, a, i, o, u) {
            const l = new wg,
                c = [new xg, ...Ig.createCallbacks(t)];
            null != e && c.push(...e), c.push(l);
            const h = new bg(c);
            return h.setParams({
                epochs: n,
                initialEpoch: s,
                samples: r,
                steps: a,
                batchSize: i,
                verbose: t,
                doValidation: o,
                metrics: u
            }), {
                callbackList: h,
                history: l
            }
        }

        function Sg(e, t = {}, n = !1) {
            return gf(e, di.getMap().classNameMap, t, "layer", n)
        }

        function Tg(e, t) {
            return yi((() => {
                "float32" !== e.dtype && (e = Ra(e, "float32"));
                const n = Ao(om(e), t, !0),
                    s = xo(n.shape, Xf()),
                    r = ku(Mo(n, s));
                return ho(e, r)
            }))
        }

        function $g(e, t) {
            return yi((() => Lo(om(Eo(t, e)), -1)))
        }

        function Cg(e, t) {
            return yi((() => Lo(Ni(Eo(t, e)), -1)))
        }

        function Eg(e, t) {
            return yi((() => {
                const n = Eo(e, t),
                    s = Yi(Ni(e), Xf(), Number.MAX_VALUE),
                    r = Ni(ho(n, s));
                return Co(100, Lo(r, -1))
            }))
        }

        function Ag(e, t) {
            return yi((() => {
                const n = Yi(t, Xf(), Number.MAX_VALUE),
                    s = So(Si(1, n)),
                    r = Yi(e, Xf(), Number.MAX_VALUE),
                    a = So(Si(1, r));
                return Lo(om(Eo(s, a)), -1)
            }))
        }

        function Rg(e, t, n = !1) {
            return yi((() => {
                if (n) t = bu(t);
                else {
                    const e = Ao(t, t.shape.length - 1, !0);
                    t = ho(t, e)
                }
                return t = Yi(t, Xf(), 1 - Xf()), Xo(Ao(Co(Ra(e, "float32"), So(t)), t.shape.length - 1))
            }))
        }

        function Fg(e, t, n = !1) {
            return yi((() => {
                const s = Ra(wo(function(e) {
                        const t = [Gf(e.shape)];
                        return Vi(e, t)
                    }(e)), "int32"),
                    r = (t = Yi(t, Xf(), 1 - Xf())).shape;
                return Rg(Vi(Jo(s, r[r.length - 1]), r), t, n)
            }))
        }

        function Dg(e, t) {
            return yi((() => {
                let n;
                return n = Yi(t, Xf(), 1 - Xf()), n = So(ho(n, Eo(1, n))), Lo(function(e, t) {
                    if (!M(e.shape, t.shape)) throw new tf(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);
                    return yi((() => {
                        const n = uu(t),
                            s = Xo(Ni(t));
                        return Si(Eo(n, Co(t, e)), To(mo(s)))
                    }))
                }(e, n), -1)
            }))
        }

        function _g(e, t) {
            return yi((() => {
                const n = Yi(e, Xf(), 1),
                    s = Yi(t, Xf(), 1);
                return Ao(Co(e, So(ho(n, s))), -1)
            }))
        }

        function Og(e, t) {
            return yi((() => {
                const n = Tg(e, -1),
                    s = Tg(t, -1),
                    r = Co(n, s);
                return Xo(Ao(r, -1))
            }))
        }
        Ig.constructors = {};
        const Mg = {
            meanSquaredError: $g,
            meanAbsoluteError: Cg,
            meanAbsolutePercentageError: Eg,
            meanSquaredLogarithmicError: Ag,
            squaredHinge: function(e, t) {
                return yi((() => {
                    const n = Mo(0, Eo(1, Co(e, t)));
                    return Lo(om(n), -1)
                }))
            },
            hinge: function(e, t) {
                return yi((() => {
                    const n = Mo(0, Eo(1, Co(e, t)));
                    return Lo(n, -1)
                }))
            },
            categoricalHinge: function(e, t) {
                return yi((() => {
                    const n = Ao(Co(e, t), -1),
                        s = $o(Co(Eo(1, e), t), -1);
                    return Mo(0, Si(1, Eo(s, n)))
                }))
            },
            logcosh: function(e, t) {
                return yi((() => {
                    const n = Math.log(2),
                        s = Eo(t, e),
                        r = Eo(Si(s, xu(Co(-2, s))), n);
                    return Lo(r, -1)
                }))
            },
            categoricalCrossentropy: Rg,
            sparseCategoricalCrossentropy: Fg,
            binaryCrossentropy: Dg,
            kullbackLeiblerDivergence: _g,
            poisson: function(e, t) {
                return yi((() => {
                    const n = So(Si(Xf(), t));
                    return Lo(Eo(t, Co(e, n)), -1)
                }))
            },
            cosineProximity: Og
        };

        function Lg(e) {
            if ("string" == typeof e) {
                if (e in Mg) return Mg[e];
                let t = `Unknown loss ${e}`;
                throw e.toLowerCase().includes("softmaxcrossentropy") && (t = `Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`), new tf(t)
            }
            return e
        }

        function zg(e, t) {
            return yi((() => {
                const n = Co(.5, eu(t)),
                    s = Yf(vo(t, n), e.dtype);
                return Lo(fo(e, s), -1)
            }))
        }

        function Bg(e, t) {
            return yi((() => Yf(fo(Ci(e, -1), Ci(t, -1)), "float32")))
        }

        function Pg(e, t) {
            return yi((() => Ra(Ao(Fo(fo(e, 1), fo(t, 1))), "float32")))
        }

        function Ug(e, t) {
            return Dg(e, t)
        }

        function Wg(e, t) {
            return e.rank === t.rank && (e = vu(e, [e.rank - 1])), (t = Ci(t, -1)).dtype !== e.dtype && (t = Ra(t, e.dtype)), Ra(fo(e, t), "float32")
        }
        const Vg = Rg,
            Gg = Fg,
            Hg = {
                binaryAccuracy: zg,
                categoricalAccuracy: Bg,
                precision: function(e, t) {
                    return yi((() => {
                        const n = Pg(e, t),
                            s = function(e, t) {
                                return yi((() => Ra(Ao(Fo(fo(e, 0), fo(t, 1))), "float32")))
                            }(e, t),
                            r = Si(n, s);
                        return Ra(Au(vo(r, 0), ho(n, r), 0), "float32")
                    }))
                },
                categoricalCrossentropy: Vg,
                sparseCategoricalCrossentropy: Gg,
                mse: $g,
                MSE: $g,
                mae: Cg,
                MAE: Cg,
                mape: Eg,
                MAPE: Eg,
                cosine: Og
            };

        function jg(e) {
            if ("string" == typeof e && e in Hg) return Hg[e];
            if ("string" != typeof e && null != e) return e;
            throw new tf(`Unknown metric ${e}`)
        }

        function qg(e) {
            if (of(null !== e, `Unknown LossOrMetricFn ${e}`), "string" == typeof e) return e;
            {
                let t;
                for (const n of Object.keys(Mg))
                    if (Mg[n] === e) {
                        t = n;
                        break
                    } if (void 0 !== t) return t;
                for (const n of Object.keys(Hg))
                    if (Hg[n] === e) {
                        t = n;
                        break
                    } return void 0 !== t ? t : e.name
            }
        }
        const Kg = 1048576;

        function Xg(e, t, n = !1) {
            if (null == e || "object" != typeof e || Object.getPrototypeOf(e) !== Object.prototype || !Yg(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
            if (n) {
                const n = JSON.stringify(e);
                n.length > Kg && console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)
            }
        }

        function Yg(e) {
            if (null === e) return !0;
            if ("object" == typeof e) {
                if (Object.getPrototypeOf(e) === Object.prototype) {
                    const t = Object.keys(e);
                    for (const n of t) {
                        if ("string" != typeof n) return !1;
                        if (!Yg(e[n])) return !1
                    }
                    return !0
                }
                if (Array.isArray(e)) {
                    for (const t of e)
                        if (!Yg(t)) return !1;
                    return !0
                }
                return !1
            } {
                const t = typeof e;
                return "string" === t || "number" === t || "boolean" === t
            }
        }

        function Jg(e, t, n, s = console.log) {
            const r = function(e) {
                    let t = !0;
                    const n = [],
                        s = [];
                    for (const t in e.nodesByDepth) n.push(e.nodesByDepth[t]);
                    for (const e of n) {
                        if (e.length > 1 || 1 === e.length && e[0].inboundLayers.length > 1) {
                            t = !1;
                            break
                        }
                        s.push(...e)
                    }
                    if (t)
                        for (const n of e.layers) {
                            let e = !1;
                            for (const r of n.inboundNodes)
                                if (-1 !== s.indexOf(r)) {
                                    if (e) {
                                        t = !1;
                                        break
                                    }
                                    e = !0
                                } if (!t) break
                        }
                    return t
                }(e),
                a = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
            let i;
            if (r ? (t = t || 90, n = n || [.32, .61, .89, 1]) : (t = t || 115, n = n || [.24, .48, .7, .8, 1]), n[n.length - 1] <= 1 && (n = n.map((e => Math.floor(t * e)))), !r) {
                a.push("Receives inputs"), i = [];
                for (const t in e.nodesByDepth) i.push(...e.nodesByDepth[t])
            }
            s("_".repeat(t)), Zg(a, n, s), s("=".repeat(t));
            const o = e.layers;
            for (let e = 0; e < o.length; ++e) r ? Qg(o[e], n, s) : ey(o[e], n, i, s), s((e === o.length - 1 ? "=" : "_").repeat(t));
            e.checkTrainableWeightsConsistency();
            const u = function(e) {
                    let t;
                    t = null != e.collectedTrainableWeights ? zm(e.collectedTrainableWeights) : zm(e.trainableWeights);
                    return t
                }(e),
                l = zm(e.nonTrainableWeights);
            s(`Total params: ${u+l}`), s(`Trainable params: ${u}`), s(`Non-trainable params: ${l}`), s("_".repeat(t))
        }

        function Zg(e, t, n = console.log) {
            let s = "";
            for (let n = 0; n < e.length; ++n) n > 0 && (s = s.slice(0, s.length - 1) + " "), s += e[n], s = s.slice(0, t[n]), s += " ".repeat(t[n] - s.length);
            n(s)
        }

        function Qg(e, t, n) {
            let s, r;
            try {
                r = e.inboundNodes.map((e => JSON.stringify(e.inputShapes))).join(",")
            } catch (e) {
                r = "multiple"
            }
            try {
                s = JSON.stringify(e.outputShape)
            } catch (e) {
                s = "multiple"
            }
            Zg([`${e.name} (${e.getClassName()})`, r, s, e.countParams().toString()], t, n)
        }

        function ey(e, t, n, s) {
            let r, a;
            try {
                a = e.inboundNodes.map((e => JSON.stringify(e.inputShapes))).join(",")
            } catch (e) {
                a = "multiple"
            }
            try {
                r = JSON.stringify(e.outputShape)
            } catch (e) {
                r = "multiple"
            }
            const i = [];
            for (const t of e.inboundNodes)
                if (!(null != n && n.length > 0 && -1 === n.indexOf(t)))
                    for (let e = 0; e < t.inboundLayers.length; ++e) {
                        const n = t.inboundLayers[e].name,
                            s = t.nodeIndices[e],
                            r = t.tensorIndices[e];
                        i.push(`${n}[${s}][${r}]`)
                    }
            const o = e.name,
                u = e.getClassName(),
                l = 0 === i.length ? "" : i[0];
            Zg([`${o} (${u})`, a, r, e.countParams().toString(), l], t, s);
            for (let e = 1; e < i.length; ++e) Zg(["", "", "", "", i[e]], t, s)
        }

        function ty(e, t, n) {
            return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n
        }

        function ny(e, t) {
            if (null === e) return null;
            if ("string" == typeof e) return pf(e);
            if ("number" == typeof e || "boolean" == typeof e) return e;
            if (e instanceof Array) {
                const n = [],
                    s = e.length;
                for (let r = 0; r < s; ++r) {
                    const s = e[r];
                    ty(t, r, s) ? n.push(s) : n.push(ny(s, t))
                }
                return n
            } {
                const t = {};
                for (const n of Object.keys(e)) {
                    const s = e[n];
                    if ("name" === n && "string" == typeof s) t[n] = s;
                    else {
                        const e = pf(n);
                        t[e] = ny(s, e)
                    }
                }
                return t
            }
        }

        function sy(e, t) {
            if (null == e) return null;
            if ("string" == typeof e) return hf(e);
            if ("number" == typeof e || "boolean" == typeof e) return e;
            if (e instanceof Array) {
                const n = [],
                    s = e.length;
                for (let r = 0; r < s; ++r) {
                    const s = e[r];
                    ty(t, r, s) ? n.push(s) : n.push(sy(s, t))
                }
                return n
            } {
                const t = {};
                for (const n of Object.keys(e)) {
                    const s = e[n],
                        r = hf(n);
                    t[r] = "name" !== n && "className" !== n || "string" != typeof s ? sy(s, n) : s
                }
                return t
            }
        }
        const ry = "3.18.0";
        class ay extends Km {
            constructor(e) {
                if (super({}), this.containerNodes = new Set, this.name = e.name, null == this.name) {
                    const e = this.getClassName().toLowerCase();
                    this.name = Cf(e)
                }
                if (this.supportsMasking = !1, this.trainable_ = !0, Array.isArray(e.inputs) ? this.inputs = e.inputs.slice() : this.inputs = [e.inputs], Array.isArray(e.outputs) ? this.outputs = e.outputs.slice() : this.outputs = [e.outputs], bf(this.inputs).length !== this.inputs.length) throw new tf(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);
                bf(this.outputs).length !== this.outputs.length && console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`), this.inputLayers = [], this.inputLayersNodeIndices = [], this.inputLayersTensorIndices = [], this.outputLayers = [], this.outputLayersNodeIndices = [], this.outputLayersTensorIndices = [], this.layers = [], this.internalContainerRefs = [];
                for (const e of this.outputs) {
                    const t = e.sourceLayer,
                        n = e.nodeIndex,
                        s = e.tensorIndex;
                    this.outputLayers.push(t), this.outputLayersNodeIndices.push(n), this.outputLayersTensorIndices.push(s)
                }
                for (const e of this.inputs) {
                    const t = e.sourceLayer,
                        n = e.nodeIndex,
                        s = e.tensorIndex;
                    of(0 === n, "input layer has >1 nodes"), of(0 === s, "input layer has >1 tensors"), this.inputLayers.push(t), this.inputLayersNodeIndices.push(n), this.inputLayersTensorIndices.push(s)
                }
                this.inputNames = [], this.outputNames = [], this.feedInputShapes = [], this.feedInputNames = [], this.feedOutputNames = [];
                for (let t = 0; t < this.inputLayers.length; t++) {
                    const n = this.inputLayers[t];
                    if (!(n instanceof Ym)) throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);
                    this.inputNames.push(n.name), this.feedInputShapes.push(n.batchInputShape), this.feedInputNames.push(n.name)
                }
                for (const e of this.outputLayers) this.outputNames.push(e.name);
                this.internalInputShapes = this.inputs.map((e => e.shape)), this.internalOutputShapes = this.outputs.map((e => e.shape));
                const t = {},
                    n = {},
                    s = {},
                    r = {},
                    a = {},
                    i = [],
                    o = (e, t, n, s, r, u) => {
                        null != s && null != r && null != u || (s = e.sourceLayer, r = e.nodeIndex, u = e.tensorIndex);
                        const l = s.inboundNodes[r];
                        if (-1 !== n.indexOf(l)) throw new ef(`The tensor ${e.name} at layer "${s.name}" is part of a cycle.`);
                        if (-1 !== t.indexOf(l)) return;
                        this.containerNodes.add(ay.nodeKey(s, r)), s.id in a || (a[s.id] = Object.keys(a).length), -1 === n.indexOf(l) && n.push(l);
                        const c = l.inboundLayers.length;
                        for (let e = 0; e < c; e++) {
                            const s = l.inputTensors[e],
                                r = l.inboundLayers[e],
                                a = l.nodeIndices[e],
                                i = l.tensorIndices[e];
                            o(s, t, n, r, a, i)
                        }
                        for (t.push(l); n.indexOf(l) >= 0;) n.splice(n.indexOf(l), 1);
                        i.push(l)
                    },
                    u = [],
                    l = [];
                for (const e of this.outputs) o(e, u, l);
                const c = i.slice().reverse();
                for (const e of c) {
                    n[e.id] = e, e.id in t || (t[e.id] = 0);
                    let a = t[e.id];
                    const i = null == s[e.outboundLayer.id] ? 0 : s[e.outboundLayer.id];
                    a = Math.max(a, i), s[e.outboundLayer.id] = a, r[e.outboundLayer.id] = e.outboundLayer, t[e.id] = a;
                    for (let s = 0; s < e.inboundLayers.length; s++) {
                        const r = e.inboundLayers[s],
                            i = e.nodeIndices[s],
                            o = r.inboundNodes[i],
                            u = null == t[o.id] ? 0 : t[o.id];
                        t[o.id] = Math.max(a + 1, u), n[o.id] = o
                    }
                }
                const h = {};
                for (const e in t) {
                    const s = t[e];
                    s in h || (h[s] = []), h[s].push(n[e])
                }
                const p = {};
                for (const e in s) {
                    const t = s[e];
                    t in p || (p[t] = []), p[t].push(r[e])
                }
                let d = Object.keys(p).map((e => parseInt(e, 10))).sort(yf);
                this.layers = [];
                for (const e of d) {
                    const t = p[e];
                    t.sort(((e, t) => {
                        const n = a[e.id],
                            s = a[t.id];
                        return n < s ? -1 : n > s ? 1 : 0
                    }));
                    for (const e of t) e instanceof ay && this.internalContainerRefs.push(e), this.layers.push(e)
                }
                this.layersByDepth = p, d = Object.keys(h).map((e => parseInt(e, 10))).sort(yf);
                const f = this.inputs.slice(),
                    m = [];
                for (const e of d)
                    for (const t of h[e]) {
                        const e = t.outboundLayer;
                        if (null != e) {
                            for (const n of t.inputTensors)
                                if (-1 === f.indexOf(n)) throw new ef(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);
                            for (const e of t.outputTensors) f.push(e);
                            m.push(e.name)
                        }
                    }
                this.nodesByDepth = h;
                const g = this.layers.map((e => e.name));
                for (const e of g) {
                    const t = g.filter((t => t === e)).length;
                    if (1 !== t) throw new ef(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(g))
                }
                this.outboundNodes = [], this.inboundNodes = [], new jm({
                    outboundLayer: this,
                    inboundLayers: [],
                    nodeIndices: [],
                    tensorIndices: [],
                    inputTensors: this.inputs,
                    outputTensors: this.outputs,
                    inputMasks: this.inputs.map((e => null)),
                    outputMasks: this.outputs.map((e => null)),
                    inputShapes: this.inputs.map((e => e.shape)),
                    outputShapes: this.outputs.map((e => e.shape))
                }), this.built = !0, this._refCount = 1
            }
            assertNotDisposed() {
                if (0 === this._refCount) throw new Error(`Container '${this.name}' is already disposed.`)
            }
            dispose() {
                this.assertNotDisposed();
                const e = {
                    refCountAfterDispose: null,
                    numDisposedVariables: 0
                };
                if (0 == --this._refCount) {
                    for (const t of this.layers) e.numDisposedVariables += t.dispose().numDisposedVariables;
                    for (const t of this.internalContainerRefs) e.numDisposedVariables += t.dispose().numDisposedVariables
                }
                return e.refCountAfterDispose = this._refCount, e
            }
            get trainable() {
                return this.trainable_
            }
            set trainable(e) {
                this.layers.forEach((t => {
                    t._trainableWeights.forEach((t => t.trainable = e))
                })), this.trainable_ = e
            }
            get trainableWeights() {
                if (this._trainableWeights.length > 0) throw new tf("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
                if (!this.trainable) return [];
                let e = [];
                for (const t of this.layers) e = e.concat(t.trainableWeights);
                return e
            }
            get nonTrainableWeights() {
                const e = [];
                for (const t of this.layers) e.push(...t.nonTrainableWeights);
                if (!this.trainable) {
                    const t = [];
                    for (const e of this.layers) t.push(...e.trainableWeights);
                    return t.concat(e)
                }
                return e
            }
            get weights() {
                return this.trainableWeights.concat(this.nonTrainableWeights)
            }
            loadWeights(e, t = !0) {
                const n = {};
                let s = 0;
                for (const e of this.layers)
                    for (const t of e.weights) {
                        if (null != n[t.originalName]) throw new tf(`Duplicate weight name: ${t.originalName}`);
                        n[t.originalName] = t, s++
                    }
                const r = [];
                for (const s in e) {
                    let a = s;
                    if (null == n[s]) {
                        const e = s.split("/");
                        a = e.slice(0, -2).concat([e[e.length - 1]]).join("/")
                    }
                    if (null != n[a]) r.push([n[a], e[s]]);
                    else if (t) throw new tf(`Provided weight data has no target variable: ${s}`);
                    delete n[a]
                }
                if (t) {
                    const e = [];
                    for (const t in n) e.push(t);
                    if (e.length > 0) throw new tf(`${e.length} of ${s} weights are not set: ${e}`)
                }
                Wm(r)
            }
            updatedConfig() {
                const e = this.getConfig(),
                    t = {};
                return t.className = this.getClassName(), t.config = e, t.kerasVersion = `tfjs-layers ${ry}`, t.backend = "TensorFlow.js", t
            }
            toJSON(e, t = !0) {
                const n = sy(this.updatedConfig());
                return t ? JSON.stringify(n) : n
            }
            call(e, t) {
                return yi((() => {
                    e = cf(e);
                    const n = new Jm;
                    for (let t = 0; t < this.inputs.length; ++t) n.add(this.inputs[t], e[t]);
                    return eg(this.outputs, n, t)
                }))
            }
            computeMask(e, t) {
                return yi((() => {
                    let n;
                    return e = cf(e), n = null == t ? af(null, e.length) : cf(t), this.runInternalGraph(e, n)[1]
                }))
            }
            computeOutputShape(e) {
                const t = Om(e);
                if (t.length !== this.inputLayers.length) throw new tf(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);
                const n = {};
                for (let e = 0; e < t.length; e++) {
                    const s = this.inputLayers[e],
                        r = t[e];
                    n[s.name + "_0_0"] = r
                }
                const s = Object.keys(this.nodesByDepth).map((e => parseInt(e, 10))).sort(yf);
                if (s.length > 1)
                    for (const e of s) {
                        const t = this.nodesByDepth[e];
                        for (const e of t) {
                            const t = e.outboundLayer;
                            if (-1 !== this.inputLayers.map((e => e.id)).indexOf(t.id)) continue;
                            const s = [];
                            for (let t = 0; t < e.inboundLayers.length; t++) {
                                const r = e.inboundLayers[t],
                                    a = e.nodeIndices[t],
                                    i = e.tensorIndices[t],
                                    o = n[`${r.name}_${a}_${i}`];
                                s.push(o)
                            }
                            const r = Om(t.computeOutputShape(lf(s))),
                                a = t.inboundNodes.indexOf(e);
                            for (let e = 0; e < r.length; e++) {
                                n[`${t.name}_${a}_${e}`] = r[e]
                            }
                        }
                    }
                const r = [],
                    a = [];
                for (let e = 0; e < this.outputLayers.length; e++) {
                    const t = this.outputLayers[e],
                        n = this.outputLayersNodeIndices[e],
                        s = this.outputLayersTensorIndices[e],
                        r = `${t.name}_${n}_${s}`;
                    a.push(r)
                }
                for (let e = 0; e < a.length; e++) {
                    const t = a[e];
                    of(t in n), r.push(n[t])
                }
                return lf(r)
            }
            runInternalGraph(e, t) {
                null == t && (t = af(null, e.length));
                const n = {};
                for (let s = 0; s < this.inputs.length; ++s) {
                    const r = this.inputs[s],
                        a = e[s],
                        i = t[s];
                    n[r.id] = [a, i]
                }
                const s = Object.keys(this.nodesByDepth).map((e => parseInt(e, 10))).sort(yf);
                for (const e of s) {
                    const t = this.nodesByDepth[e];
                    for (const e of t) {
                        const t = e.outboundLayer,
                            s = e.inputTensors,
                            r = e.outputTensors,
                            a = new Array;
                        for (const e of s) e.id in n && a.push(n[e.id]);
                        if (a.length === s.length) {
                            let s, i, o, u, l = {};
                            if (null != e.callArgs && (l = e.callArgs), 1 === a.length) {
                                const [e, n] = a[0];
                                null == l.mask && (l.mask = n), o = cf(t.call(e, l)), u = cf(t.computeMask(e, n)), s = [e], i = [n]
                            } else s = a.map((e => e[0])), i = a.map((e => e[1])), null == l.mask && (l.mask = i), o = cf(t.call(s, l)), u = cf(t.computeMask(s, i));
                            if (t.activityRegularizer) throw new nf("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                            for (let e = 0; e < r.length; ++e) {
                                const t = r[e],
                                    s = o[e],
                                    a = u[e];
                                n[t.id] = [s, a]
                            }
                        }
                    }
                }
                const r = [],
                    a = [],
                    i = [];
                for (const e of this.outputs) {
                    of(e.id in n, `Could not compute output ${e.name} : ${e.id}`);
                    const [t, s] = n[e.id];
                    i.push(t.shape), r.push(t), a.push(s)
                }
                return [r, a, i]
            }
            buildNodeConversionMap(e) {
                const t = {};
                let n;
                for (const e of this.layers) {
                    n = e instanceof ay ? 1 : 0;
                    for (let s = 0; s < e.inboundNodes.length; s++) {
                        const r = ay.nodeKey(e, s);
                        this.containerNodes.has(r) && (t[r] = n, n += 1)
                    }
                }
                return t
            }
            getLayer(e, t) {
                if (null != t) {
                    if (this.layers.length <= t) throw new tf(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);
                    return this.layers[t]
                }
                if (null == e) throw new tf("Provide either a layer name or layer index");
                for (const t of this.layers)
                    if (t.name === e) return t;
                throw new tf(`No such layer: ${e}`)
            }
            calculateLosses() {
                return yi((() => {
                    const e = [];
                    for (const t of this.layers)
                        for (let n = 0; n < t.inboundNodes.length; ++n) {
                            const s = ay.nodeKey(t, n);
                            this.containerNodes.has(s) && e.push(...t.calculateLosses())
                        }
                    return e
                }))
            }
            getConfig() {
                const e = {
                        name: this.name
                    },
                    t = this.buildNodeConversionMap(this.layers),
                    n = [];
                for (const e of this.layers) {
                    const s = e.getClassName(),
                        r = e.getConfig(),
                        a = [];
                    for (let n = 0; n < e.inboundNodes.length; n++) {
                        const s = e.inboundNodes[n],
                            r = ay.nodeKey(e, n);
                        let i = {};
                        if (this.containerNodes.has(r)) {
                            if (s.callArgs) try {
                                JSON.stringify(s.callArgs), i = s.callArgs
                            } catch (t) {
                                console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${s.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`), i = {}
                            }
                            if (s.inboundLayers.length > 0) {
                                const e = [];
                                for (let n = 0; n < s.inboundLayers.length; n++) {
                                    const r = s.inboundLayers[n],
                                        a = s.nodeIndices[n],
                                        o = s.tensorIndices[n];
                                    let u = t[ay.nodeKey(r, a)];
                                    null == u && (u = 0), e.push([r.name, u, o, i])
                                }
                                a.push(e)
                            }
                        }
                    }
                    const i = {};
                    i.name = e.name, i.className = s, i.config = r, i.inboundNodes = a, n.push(i)
                }
                e.layers = n;
                const s = [];
                for (let e = 0; e < this.inputLayers.length; e++) {
                    const n = this.inputLayers[e],
                        r = this.inputLayersNodeIndices[e],
                        a = ay.nodeKey(n, r);
                    if (!this.containerNodes.has(a)) continue;
                    let i = t[a];
                    null == i && (i = 0);
                    const o = this.inputLayersTensorIndices[e];
                    s.push([n.name, i, o])
                }
                e.inputLayers = s;
                const r = [];
                for (let e = 0; e < this.outputLayers.length; e++) {
                    const n = this.outputLayers[e],
                        s = this.outputLayersNodeIndices[e],
                        a = ay.nodeKey(n, s);
                    if (!this.containerNodes.has(a)) continue;
                    let i = t[a];
                    null == i && (i = 0);
                    const o = this.outputLayersTensorIndices[e];
                    r.push([n.name, i, o])
                }
                return e.outputLayers = r, e
            }
            static fromConfig(e, t, n = {}, s = !1) {
                const r = {},
                    a = {};

                function i(e, t) {
                    e.name in a ? a[e.name].push(t) : a[e.name] = [t]
                }

                function o(e, t) {
                    const n = [];
                    let s;
                    for (const a of t) {
                        const o = a[0],
                            u = a[1],
                            l = a[2];
                        if (s = null == a[3] ? {} : a[3], !(o in r)) return void i(e, t);
                        const c = r[o];
                        if (c.inboundNodes.length <= u) return void i(e, t);
                        const h = c.inboundNodes[u];
                        n.push(h.outputTensors[l])
                    }
                    n.length > 0 && e.apply(lf(n), s)
                }

                function u(e) {
                    const n = e.name,
                        a = Sg(e, null != t.customObjects ? t.customObjects : {});
                    a.setFastWeightInitDuringBuild(s), r[n] = a;
                    e.inboundNodes.forEach((e => {
                        if (!(e instanceof Array)) throw new tf(`Corrupted configuration, expected array for nodeData: ${e}`);
                        i(a, e)
                    }))
                }
                const l = t.name,
                    c = t.layers;
                for (const e of c) u(e);
                for (; !xf(a);)
                    for (const e of c) {
                        const t = r[e.name];
                        if (t.name in a) {
                            const e = a[t.name];
                            delete a[t.name];
                            for (const n of e) o(t, n)
                        }
                    }
                const h = [],
                    p = [],
                    d = t.inputLayers;
                for (const e of d) {
                    const t = e[0],
                        n = e[1],
                        s = e[2];
                    of(t in r);
                    const a = r[t].inboundNodes[n].outputTensors;
                    h.push(a[s])
                }
                const f = t.outputLayers;
                for (const e of f) {
                    const t = e[0],
                        n = e[1],
                        s = e[2];
                    of(t in r);
                    const a = r[t].inboundNodes[n].outputTensors;
                    p.push(a[s])
                }
                return new e({
                    inputs: h,
                    outputs: p,
                    name: l
                })
            }
            get stateful() {
                if (this._stateful) throw new tf("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
                for (const e of this.layers)
                    if (e.stateful) return !0;
                return !1
            }
            resetStates() {
                yi((() => {
                    this.layers.forEach((e => {
                        e.stateful && e.resetStates()
                    }))
                }))
            }
        }

        function iy(e, t, n) {
            const s = t.length;
            if (null == e || Array.isArray(e) && 0 === e.length) return t.map((e => null));
            if (1 === s) return Array.isArray(e) && 1 === e.length ? e : "object" == typeof e && t[0] in e ? [e[t[0]]] : [e];
            if (Array.isArray(e)) {
                if (e.length !== s) throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);
                return e
            }
            if ("object" == typeof e && Object.keys(e).length > 0 && "object" == typeof e[Object.keys(e)[0]]) {
                const n = [];
                return t.forEach((t => {
                    t in e ? n.push(e[t]) : n.push(null)
                })), n
            }
            throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)
        }

        function oy(e, t) {
            return iy(e, t, "classWeight")
        }
        async function uy(e, t, n, s) {
            if (null != t || null != s) throw new Error("Support sampleWeight is not implemented yet");
            if (null != n) {
                const t = yi((() => {
                        if (1 === e.shape.length) return Fa(e);
                        if (2 === e.shape.length) {
                            if (e.shape[1] > 1) {
                                return Ci(e, 1)
                            }
                            if (1 === e.shape[1]) return Vi(e, [e.shape[0]]);
                            throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)
                        }
                        throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)
                    })),
                    s = Array.from(await t.data());
                bi(t);
                const r = [];
                return s.forEach((e => {
                    if (null == n[e]) throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);
                    r.push(n[e])
                })), Su(r, "float32")
            }
            return null
        }

        function ly(e, t) {
            return Co(e, t)
        }

        function cy(e, t) {
            let n, s;
            const r = t;
            n = r.xs, s = r.ys, R(null != n && null != s, (() => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));
            const a = hy("input", e.inputNames, n),
                i = hy("output", e.outputNames, s),
                o = a[0].shape[0];
            R(a.length === e.inputs.length, (() => `LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)), R(i.length === e.outputs.length, (() => `LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));
            for (let t = 0; t < a.length; t++) R(a[t].shape[0] === o, (() => `Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));
            for (let t = 0; t < i.length; t++) R(i[t].shape[0] === o, (() => `Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));
            return {
                xs: a,
                ys: i
            }
        }

        function hy(e, t, n) {
            if (n instanceof cr) return [n];
            if (Array.isArray(n)) return R(n.length === t.length, (() => `Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)), n;
            {
                const s = [];
                for (const r of t) {
                    if (null == n[r]) throw new tf(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);
                    s.push(n[r])
                }
                return s
            }
        }
        async function py(e, t, n) {
            const s = null != n.batchesPerEpoch;
            if (R(null != e.optimizer, (() => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")), R(null != n, (() => "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")), R(null != n.epochs && n.epochs > 0 && Number.isInteger(n.epochs), (() => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)), R(!s || n.batchesPerEpoch > 0 && Number.isInteger(n.batchesPerEpoch), (() => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)), R(null == n.validationSplit, (() => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")), e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
            e.isTraining = !0;
            try {
                const r = null != n.validationData;
                let a, i;
                if (r)
                    if (dy(n.validationData)) R(null == n.validationBatches || n.validationBatches > 0 && Number.isInteger(n.validationBatches), (() => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));
                    else {
                        const e = function(e) {
                            if (3 === e.length) throw new nf("Validation with sample weights is not implemented yet.");
                            return {
                                xs: e[0],
                                ys: e[1]
                            }
                        }(n.validationData);
                        a = e.xs, i = e.ys
                    } const o = e.makeTrainFunction(),
                    u = e.getDedupedMetricsNames();
                let l;
                l = r ? u.slice().concat(u.map((e => "val_" + e))) : u.slice();
                const c = vg(n.callbacks, n.yieldEvery),
                    h = null == n.verbose ? 1 : n.verbose,
                    {
                        callbackList: p,
                        history: d
                    } = Ng(c, h, n.epochs, null, null, function(e, t) {
                        let n = null;
                        null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size);
                        return n
                    }(t, n), null, r, l);
                p.setModel(e), e.history = d, await p.onTrainBegin(), e.stopTraining_ = !1;
                let f = null == n.initialEpoch ? 0 : n.initialEpoch,
                    m = await t.iterator();
                for (; f < n.epochs;) {
                    const l = {};
                    await p.onEpochBegin(f);
                    let c = 0,
                        h = 0;
                    for (s || (m = await t.iterator()); !s || c < n.batchesPerEpoch;) {
                        const t = await m.next();
                        if (s && t.done) {
                            console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ` + n.batchesPerEpoch * n.epochs + " batches). You may need to use the repeat() function when building your dataset.");
                            break
                        }
                        if (null != t.value) {
                            const {
                                xs: s,
                                ys: r
                            } = cy(e, t.value), a = {};
                            a.batch = h, a.size = s[0].shape[0], await p.onBatchBegin(h, a);
                            const i = [];
                            if (null != n.classWeight) {
                                const t = oy(n.classWeight, e.outputNames);
                                for (let e = 0; e < t.length; ++e) i.push(await uy(r[e], null, t[e]))
                            }
                            const l = s.concat(r).concat(i),
                                d = o(l);
                            bi(l);
                            for (let e = 0; e < u.length; ++e) {
                                const t = u[e],
                                    n = d[e];
                                a[t] = n, xi(n)
                            }
                            await p.onBatchEnd(h, a), mg(a), h++, c++
                        }
                        if (s ? c >= n.batchesPerEpoch : t.done) {
                            if (r) {
                                let t;
                                t = dy(n.validationData) ? cf(await e.evaluateDataset(n.validationData, {
                                    batches: n.validationBatches
                                })) : cf(e.evaluate(a, i, {
                                    batchSize: null == n.validationBatchSize ? 32 : n.validationBatchSize,
                                    verbose: 0
                                }));
                                for (let n = 0; n < e.metricsNames.length; ++n) l[`val_${e.metricsNames[n]}`] = t[n]
                            }
                            break
                        }
                        if (e.stopTraining_) break
                    }
                    if (await p.onEpochEnd(f, l), f++, e.stopTraining_) break
                }
                return await p.onTrainEnd(), await e.history.syncData(), e.history
            } finally {
                e.isTraining = !1
            }
        }

        function dy(e) {
            return "function" == typeof e.iterator
        }

        function fy(e) {
            R(e > 0 && Number.isInteger(e), (() => `batchSize is required to be a positive integer, but got ${e}`))
        }

        function my(e, t, n) {
            return null == e ? [null] : Array.isArray(e) ? e.map((e => Zf(e, t, n - t))) : Zf(e, t, n - t)
        }

        function gy(e, t) {
            return yi((() => null == e ? null : Array.isArray(e) ? e.map((e => gy(e, t))) : im(e, "int32" === t.dtype ? t : Ra(t, "int32"))))
        }

        function yy(e, t) {
            const n = [];
            let s = 0,
                r = null;
            for (; s < e;) r = s + t, r >= e && (r = e), n.push([s, r]), s = r;
            return n
        }
        async function by(e, t, n, s = {}) {
            if (e.isTraining) throw new Error("Cannot start training because another fit() call is ongoing.");
            let r, a, i, o, u, l, c, h, p;
            e.isTraining = !0;
            try {
                const d = null == s.batchSize ? 32 : s.batchSize;
                fy(d);
                const f = !1,
                    m = await e.standardizeUserData(t, n, s.sampleWeight, s.classWeight, f, d);
                r = m[0], a = m[1], p = m[2];
                let g, y = !1;
                if (null != s.validationData && s.validationData.length > 0) {
                    if (y = !0, 2 !== s.validationData.length) throw 3 === s.validationData.length ? new nf("validationData including sample weights is not supported yet.") : new tf(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);
                    u = s.validationData[0], l = s.validationData[1];
                    const t = !0,
                        n = await e.standardizeUserData(u, l, null, null, t, d);
                    c = n[0], h = n[1], g = c.concat(h)
                } else if (null != s.validationSplit && s.validationSplit > 0 && s.validationSplit < 1) {
                    y = !0;
                    const e = Math.floor(r[0].shape[0] * (1 - s.validationSplit)),
                        t = r[0].shape[0];
                    c = my(r, e, t), i = r, r = my(r, 0, e), h = my(a, e, t), o = a, a = my(a, 0, e), g = c.concat(h)
                } else null != s.validationSteps && (y = !0);
                const b = r.concat(a).concat(p);
                e.checkTrainableWeightsConsistency();
                const x = e.makeTrainFunction(),
                    w = e.getDedupedMetricsNames();
                let k, v;
                y ? (e.makeTestFunction(), k = e.testFunction, v = w.slice().concat(w.map((e => "val_" + e)))) : (k = null, g = [], v = w.slice());
                const I = vg(s.callbacks, s.yieldEvery),
                    N = await async function(e, t, n, s, r, a, i, o, u, l, c, h, p, d, f) {
                        null == r && (r = 32), null == a && (a = 1), null == c && (c = !0), null == p && (p = 0);
                        let m = !1;
                        if (null != u && null != l && (m = !0), null != f && (m = !0, null == d)) throw new tf("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
                        const g = e.checkNumSamples(n, r, d, "steps_per_epoch");
                        let y;
                        null != g && (y = qf(0, g)), null == i && (i = 1);
                        const {
                            callbackList: b,
                            history: x
                        } = Ng(o, i, a, p, g, d, r, m, h);
                        b.setModel(e), e.history = x, await b.onTrainBegin(), e.stopTraining_ = !1;
                        for (let i = p; i < a; ++i) {
                            await b.onEpochBegin(i);
                            const a = {};
                            if (null != d) throw new nf("stepsPerEpoch mode is not implemented yet.");
                            {
                                if ("batch" === c) throw new nf("batch shuffling is not implemneted yet");
                                c && $(y);
                                const i = Su(y),
                                    o = yy(g, r);
                                for (let c = 0; c < o.length; ++c) {
                                    const h = {};
                                    if (await b.onBatchBegin(c, h), yi((() => {
                                            const p = o[c][0],
                                                d = o[c][1],
                                                f = Zf(i, p, d - p);
                                            h.batch = c, h.size = d - p;
                                            const g = gy(n, f),
                                                y = t(g);
                                            for (let e = 0; e < s.length; ++e) {
                                                const t = s[e],
                                                    n = y[e];
                                                h[t] = n, xi(n)
                                            }
                                            if (c === o.length - 1 && m) {
                                                const t = e.testLoop(u, l, r);
                                                for (let e = 0; e < s.length; ++e) {
                                                    const n = s[e],
                                                        r = t[e];
                                                    xi(r), a["val_" + n] = r
                                                }
                                            }
                                        })), await b.onBatchEnd(c, h), mg(h), e.stopTraining_) break
                                }
                                i.dispose()
                            }
                            if (await b.onEpochEnd(i, a), e.stopTraining_) break
                        }
                        return await b.onTrainEnd(), await e.history.syncData(), e.history
                    }(e, x, b, w, d, s.epochs, s.verbose, I, k, g, s.shuffle, v, s.initialEpoch, null, null);
                return N
            } finally {
                e.isTraining = !1, wy(r, t), wy(a, n), wy(i, t), wy(o, n), wy(c, u), wy(h, l), null != p && bi(p)
            }
        }

        function xy(e) {
            const t = [];
            e instanceof cr && (e = [e]);
            for (let n = 0; n < e.length; ++n) {
                const s = e[n];
                if (1 === s.rank) t.push(Jf(s, 1));
                else {
                    if (0 === s.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
                    t.push(s)
                }
            }
            return t
        }

        function wy(e, t) {
            if (null == e) return;
            const n = [];
            if (t instanceof cr) n.push(t.id);
            else if (Array.isArray(t)) t.forEach((e => n.push(e.id)));
            else if (null != t)
                for (const e in t) {
                    const s = t[e];
                    n.push(s.id)
                }
            const s = [];
            if (e instanceof cr) - 1 === n.indexOf(e.id) && s.push(e);
            else if (Array.isArray(e)) e.forEach((e => {
                -1 === n.indexOf(e.id) && s.push(e)
            }));
            else if (null != e)
                for (const t in e) {
                    const r = e[t]; - 1 === n.indexOf(r.id) && s.push(r)
                }
            s.forEach((e => {
                e.isDisposed || e.dispose()
            }))
        }

        function ky(e) {
            return Array.isArray(e)
        }

        function vy(e) {
            return ! function(e) {
                return e instanceof cr
            }(e) && !ky(e)
        }

        function Iy(e, t, n, s = !0, r = "") {
            if (null == t || 0 === t.length) {
                if (null != e) {
                    let t = !1;
                    if (ky(e) && e.length > 0) t = !0;
                    else if (vy(e)) {
                        for (const n in e)
                            if (e.hasOwnProperty(n)) {
                                t = !0;
                                break
                            }
                    } else t = !0;
                    if (t) throw new tf(`Error when checking model ${r} expected no data, but got ${e}`)
                }
                return []
            }
            if (null == e) return t.map((e => null));
            let a;
            if (vy(e)) {
                a = [];
                for (const n of t) {
                    if (null == e[n]) throw new tf(`No data provided for "${n}". Need data for each key in: ${t}`);
                    a.push(e[n])
                }
            } else if (ky(e)) {
                if (e.length !== t.length) throw new tf(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);
                a = e
            } else {
                if (t.length > 1) throw new tf(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);
                a = [e]
            }
            if (a = xy(a), null != n)
                for (let e = 0; e < t.length; ++e) {
                    if (null == n[e]) continue;
                    const i = a[e];
                    if (i.shape.length !== n[e].length) throw new tf(`Error when checking ${r}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);
                    for (let t = 0; t < n[e].length; ++t) {
                        if (0 === t && !s) continue;
                        const a = i.shape[t],
                            o = n[e][t];
                        if (null != o && o >= 0 && a !== o) throw new tf(`${r} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${r} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)
                    }
                }
            return a
        }

        function Ny(e, t, n, s = !0, r = "") {
            let a;
            if (Array.isArray(e)) {
                if (e.length !== t.length) throw new tf(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);
                a = e
            } else {
                if (t.length > 1) throw new tf(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);
                a = [e]
            }
            if (null != n)
                for (let e = 0; e < t.length; ++e) {
                    if (null == n[e]) continue;
                    const i = a[e];
                    if (i.shape.length !== n[e].length) throw new tf(`Error when checking ${r}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);
                    for (let a = 0; a < n[e].length; ++a) {
                        if (0 === a && !s) continue;
                        const o = i.shape[a],
                            u = n[e][a];
                        if (null != u && u !== o) throw new tf(`Error when checking ${r}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)
                    }
                }
        }
        class Sy extends ay {
            constructor(e) {
                super(e), this.isTraining = !1
            }
            summary(e, t, n = console.log) {
                if (!this.built) throw new tf("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
                Jg(this, e, t, n)
            }
            compile(e) {
                if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = function(e) {
                    const t = {
                        Adagrad: () => lc.adagrad(.01),
                        Adadelta: () => lc.adadelta(1, .95, Xf()),
                        Adam: () => lc.adam(.001, .9, .999, Xf()),
                        Adamax: () => lc.adamax(.002, .9, .999, Xf(), 0),
                        RMSProp: () => lc.rmsprop(.001, .9, 0, Xf()),
                        SGD: () => lc.sgd(.01)
                    };
                    if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
                    throw new tf(`Unknown Optimizer ${e}`)
                }(e.optimizer), this.isOptimizerOwned = !0;
                else {
                    if (!(e.optimizer instanceof Ii)) throw new tf("User-defined optimizer must be an instance of tf.Optimizer.");
                    this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1
                }
                let t = [];
                if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss)
                    if (Array.isArray(e.loss)) {
                        if (e.loss.length !== this.outputs.length) throw new tf(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);
                        const n = e.loss;
                        t = n.map((e => Lg(e)))
                    } else {
                        const n = Lg(e.loss);
                        this.outputs.forEach((e => {
                            t.push(n)
                        }))
                    }
                else {
                    e.loss = e.loss;
                    for (const t in e.loss)
                        if (-1 === this.outputNames.indexOf(t)) throw new tf(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);
                    for (const n of this.outputNames) null == e.loss[n] && console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`), t.push(Lg(e.loss[n]))
                }
                this.lossFunctions = t, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
                for (let e = 0; e < this.outputs.length; ++e) {
                    const t = this.internalOutputShapes[e],
                        n = this.outputNames[e];
                    this.feedOutputNames.push(n), this.feedOutputShapes.push(t), this.feedLossFns.push(this.lossFunctions[e])
                }
                const n = [];
                this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], Bf("loss", (() => {
                    for (let e = 0; e < this.outputs.length; ++e) {
                        if (-1 !== n.indexOf(e)) continue;
                        const t = this.lossFunctions[e];
                        this.outputs.length > 1 && (this.metricsTensors.push([t, e]), this.metricsNames.push(this.outputNames[e] + "_loss"))
                    }
                }));
                const s = function(e, t) {
                        if (null == e || Array.isArray(e) && 0 === e.length) return t.map((e => []));
                        let n;
                        if ("string" == typeof e || "function" == typeof e) n = [e];
                        else {
                            if (!Array.isArray(e) && "object" != typeof e) throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);
                            n = e
                        }
                        if (Array.isArray(n)) return t.map((e => n));
                        {
                            const e = [];
                            for (const s of t) {
                                let t = n.hasOwnProperty(s) ? n[s] : [];
                                Array.isArray(t) || (t = [t]), e.push(t)
                            }
                            return e
                        }
                    }(e.metrics, this.outputNames),
                    r = (e, t, n) => {
                        this.outputNames.length > 1 && (t = this.outputNames[e] + "_" + t), this.metricsNames.push(t), this.metricsTensors.push([n, e])
                    };
                Bf("metric", (() => {
                    for (let e = 0; e < this.outputs.length; ++e) {
                        if (-1 !== n.indexOf(e)) continue;
                        (t => {
                            let n, s, a;
                            for (const i of t) {
                                if ("string" == typeof i && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(i)) {
                                    const t = this.internalOutputShapes[e];
                                    let r;
                                    1 === t[t.length - 1] || this.lossFunctions[e] === Dg ? -1 !== ["accuracy", "acc"].indexOf(i) ? s = zg : -1 !== ["crossentropy", "ce"].indexOf(i) && (s = Ug) : this.lossFunctions[e] === Fg ? -1 !== ["accuracy", "acc"].indexOf(i) ? s = Wg : -1 !== ["crossentropy", "ce"].indexOf(i) && (s = Gg) : -1 !== ["accuracy", "acc"].indexOf(i) ? s = Bg : -1 !== ["crossentropy", "ce"].indexOf(i) && (s = Vg), -1 !== ["accuracy", "acc"].indexOf(i) ? r = "acc" : -1 !== ["crossentropy", "ce"].indexOf(i) && (r = "ce"), a = s, n = "" + r
                                } else {
                                    const e = jg(i);
                                    a = e, n = "" + qg(i)
                                }
                                let t;
                                Bf(n, (() => {
                                    t = a
                                })), r(e, n, t)
                            }
                        })(s[e])
                    }
                })), this.collectedTrainableWeights = this.trainableWeights
            }
            checkTrainableWeightsConsistency() {
                null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")
            }
            evaluate(e, t, n = {}) {
                const s = null == n.batchSize ? 32 : n.batchSize;
                fy(s);
                const r = this.standardizeUserDataXY(e, t, !0, s);
                try {
                    const e = r[0].concat(r[1]);
                    this.makeTestFunction();
                    const t = this.testFunction;
                    return lf(this.testLoop(t, e, s, n.verbose, n.steps))
                } finally {
                    wy(r[0], e), wy(r[1], t)
                }
            }
            async evaluateDataset(e, t) {
                return this.makeTestFunction(), async function(e, t, n) {
                    const s = null != (n = n || {}).batches,
                        r = e.testFunction;
                    let a = [];
                    if (n.verbose > 0) throw new nf("Verbose mode is not implemented yet.");
                    R(!s || n.batches > 0 && Number.isInteger(n.batches), (() => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));
                    const i = "function" == typeof t.next ? t : await t.iterator();
                    let o = 0,
                        u = 0;
                    for (; !s || u < n.batches;) {
                        const t = await i.next();
                        if (a = yi((() => {
                                if (t.value) {
                                    const {
                                        xs: n,
                                        ys: s
                                    } = cy(e, t.value), i = n.concat(s), l = yi((() => r(i)));
                                    if (bi(i), 0 === u)
                                        for (let e = 0; e < l.length; ++e) a.push(vi(0));
                                    const c = i[0].shape[0];
                                    for (let e = 0; e < l.length; ++e) {
                                        const t = l[e],
                                            n = a[e];
                                        a[e] = yi((() => Si(a[e], Co(c, t)))), u > 0 && bi(n)
                                    }
                                    bi(l), o += c, ++u
                                }
                                return a
                            })), t.done) {
                            s && console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);
                            break
                        }
                    }
                    for (let e = 0; e < a.length; ++e) {
                        const t = a[e];
                        a[e] = ho(a[e], o), bi(t)
                    }
                    return lf(a)
                }(this, e, t)
            }
            checkNumSamples(e, t, n, s = "steps") {
                let r;
                if (null != n) {
                    if (r = null, null != t) throw new tf(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)
                } else {
                    if (null == e) throw new tf(`Either the input data should have a defined shape, or ${s} shoud be specified.`);
                    r = Array.isArray(e) ? e[0].shape[0] : e.shape[0]
                }
                return r
            }
            execute(e, t) {
                if (Array.isArray(t) && 0 === t.length) throw new tf("`outputs` is an empty Array, which is not allowed.");
                const n = Array.isArray(t),
                    s = n ? t : [t],
                    r = this.retrieveSymbolicTensors(s),
                    a = new Jm;
                if (e instanceof cr && (e = [e]), Array.isArray(e)) {
                    if (e.length !== this.inputs.length) throw new tf(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
                    for (let t = 0; t < this.inputs.length; ++t) a.add(this.inputs[t], e[t])
                } else
                    for (const t of this.inputs) {
                        const n = e[t.name];
                        if (null == n) throw new tf(`No value is provided for the model's input ${t.name}`);
                        a.add(t, n)
                    }
                const i = eg(r, a);
                return n ? i : i[0]
            }
            retrieveSymbolicTensors(e) {
                const t = af(null, e.length);
                let n = e.length;
                for (const s of this.layers) {
                    const r = Array.isArray(s.output) ? s.output : [s.output],
                        a = r.map((e => e.name));
                    for (let s = 0; s < e.length; ++s) {
                        const i = a.indexOf(e[s]);
                        if (-1 !== i && (t[s] = r[i], n--), 0 === n) break
                    }
                    if (0 === n) break
                }
                if (n > 0) {
                    const n = [];
                    throw t.forEach(((t, s) => {
                        null == t && n.push(e[s])
                    })), new tf(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)
                }
                return t
            }
            predictLoop(e, t = 32, n = !1) {
                return yi((() => {
                    const s = this.checkNumSamples(e);
                    if (n) throw new nf("Verbose predictLoop() is not implemented yet.");
                    const r = yy(s, t),
                        a = this.outputs.map((e => []));
                    for (let t = 0; t < r.length; ++t) {
                        yi((() => {
                            const n = r[t][0],
                                s = r[t][1],
                                a = my(e, n, s),
                                i = [];
                            if (Array.isArray(a))
                                for (let e = 0; e < a.length; ++e) i.push({
                                    key: this.inputs[e],
                                    value: a[e]
                                });
                            else i.push({
                                key: this.inputs[0],
                                value: a
                            });
                            const o = new Jm(i);
                            return eg(this.outputs, o)
                        })).forEach(((e, t) => a[t].push(e)))
                    }
                    return lf(a.map((e => Ji(e, 0))))
                }))
            }
            predict(e, t = {}) {
                const n = xy(e);
                Ny(n, this.inputNames, this.feedInputShapes, !1);
                try {
                    const e = null == t.batchSize ? 32 : t.batchSize;
                    return fy(e), this.predictLoop(n, e)
                } finally {
                    wy(n, e)
                }
            }
            predictOnBatch(e) {
                Ny(e, this.inputNames, this.feedInputShapes, !0);
                const t = (Array.isArray(e) ? e[0] : e).shape[0];
                return this.predictLoop(e, t)
            }
            standardizeUserDataXY(e, t, n = !0, s) {
                if (null == this.optimizer_) throw new ef("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
                const r = [];
                for (let e = 0; e < this.feedOutputShapes.length; ++e) {
                    const t = this.feedOutputShapes[e];
                    this.feedLossFns[e] === Fg ? r.push(t.slice(0, t.length - 1).concat([1])) : r.push(t)
                }
                if (function(e, t) {
                        const n = bf(e.map((e => e.shape[0])));
                        n.sort();
                        const s = bf(t.map((e => e.shape[0])));
                        if (s.sort(), n.length > 1) throw new tf(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);
                        if (s.length > 1) throw new tf(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);
                        if (n.length > 0 && s.length > 0 && !M(n, s)) throw new tf(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${s[0]} target sample(s).`)
                    }(e = Iy(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = Iy(t, this.feedOutputNames, r, !1, "target")), function(e, t, n) {
                        const s = [$g, Dg, Rg];
                        for (let r = 0; r < e.length; ++r) {
                            const a = e[r],
                                i = t[r],
                                o = n[r];
                            if (null != i) {
                                if (i === Rg && 1 === a.shape[a.shape.length - 1]) throw new tf(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
                                if (-1 !== s.indexOf(i)) {
                                    const e = a.shape.slice(1),
                                        t = o.slice(1);
                                    for (let n = 0; n < e.length; ++n) {
                                        const s = e[n],
                                            r = t[n];
                                        if (null != r && s !== r) throw new tf(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)
                                    }
                                }
                            }
                        }
                    }(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != s && s > 0 && e[0].shape[0] % s != 0) throw new tf(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);
                return [e, t]
            }
            async standardizeUserData(e, t, n, s, r = !0, a) {
                const [i, o] = this.standardizeUserDataXY(e, t, r, a);
                if (null != n) throw new Error("sample weight is not supported yet.");
                let u = null;
                if (null != s) {
                    const e = oy(s, this.outputNames);
                    u = [];
                    for (let t = 0; t < e.length; ++t) u.push(await uy(o[t], null, e[t]))
                }
                return [i, o, u]
            }
            testLoop(e, t, n, s = 0, r) {
                return yi((() => {
                    const a = this.checkNumSamples(t, n, r, "steps"),
                        i = [];
                    if (s > 0) throw new nf("Verbose mode is not implemented yet.");
                    if (null != r) throw new nf("steps mode in testLoop() is not implemented yet");
                    {
                        const s = yy(a, n),
                            r = Su(qf(0, a));
                        for (let n = 0; n < s.length; ++n) {
                            const a = s[n][0],
                                o = s[n][1],
                                u = Zf(r, a, o - a),
                                l = gy(t, u),
                                c = e(l);
                            if (0 === n)
                                for (let e = 0; e < c.length; ++e) i.push(vi(0));
                            for (let e = 0; e < c.length; ++e) {
                                const t = c[e];
                                i[e] = Si(i[e], Co(o - a, t))
                            }
                        }
                        for (let e = 0; e < i.length; ++e) i[e] = ho(i[e], a)
                    }
                    return i
                }))
            }
            getDedupedMetricsNames() {
                const e = this.metricsNames,
                    t = [];
                for (let n = 0; n < e.length; ++n) {
                    const s = e[n];
                    let r = s;
                    if (uf(e, s) > 1) {
                        r += `_${uf(e.slice(0,n),s)}`
                    }
                    t.push(r)
                }
                return t
            }
            makeTrainFunction() {
                return e => {
                    const t = [],
                        n = e.slice(0, this.inputs.length),
                        s = e.slice(this.inputs.length, this.inputs.length + this.outputs.length),
                        r = e.slice(this.inputs.length + this.outputs.length, this.inputs.length + 2 * this.outputs.length),
                        a = [],
                        i = this.collectedTrainableWeights.map((e => e.read()));
                    return [this.optimizer_.minimize((() => {
                        const e = [];
                        for (let t = 0; t < this.inputs.length; ++t) e.push({
                            key: this.inputs[t],
                            value: n[t]
                        });
                        const i = new Jm(e),
                            o = eg(this.outputs, i, {
                                training: !0
                            });
                        let u;
                        for (let e = 0; e < this.lossFunctions.length; ++e) {
                            let n = (0, this.lossFunctions[e])(s[e], o[e]);
                            null != r[e] && (n = ly(n, r[e]));
                            const a = Lo(n);
                            t.push(a), u = 0 === e ? n : Si(u, n)
                        }
                        for (let e = 0; e < this.metricsTensors.length; ++e) {
                            let n;
                            if (this.outputs.length > 1 && e < this.outputs.length) n = t[e];
                            else {
                                const t = this.metricsTensors[e][0],
                                    r = this.metricsTensors[e][1];
                                n = Lo(t(s[r], o[r]))
                            }
                            xi(n), a.push(n)
                        }
                        return u = Lo(u), this.calculateLosses().forEach((e => {
                            u = Si(u, e)
                        })), u
                    }), !0, i)].concat(a)
                }
            }
            makeTestFunction() {
                this.testFunction = e => yi((() => {
                    const t = [];
                    let n;
                    const s = e.slice(0, this.inputs.length),
                        r = e.slice(this.inputs.length, this.inputs.length + this.outputs.length),
                        a = [];
                    for (let e = 0; e < this.inputs.length; ++e) a.push({
                        key: this.inputs[e],
                        value: s[e]
                    });
                    const i = new Jm(a),
                        o = eg(this.outputs, i);
                    for (let e = 0; e < this.lossFunctions.length; ++e) {
                        const s = this.lossFunctions[e],
                            a = Lo(s(r[e], o[e]));
                        n = 0 === e ? a : Si(n, a), t.push(n)
                    }
                    for (let e = 0; e < this.metricsTensors.length; ++e) {
                        const n = this.metricsTensors[e][0],
                            s = this.metricsTensors[e][1],
                            a = Lo(n(r[s], o[s]));
                        t.push(a)
                    }
                    return t
                }))
            }
            async fit(e, t, n = {}) {
                return by(this, e, t, n)
            }
            async fitDataset(e, t) {
                return py(this, e, t)
            }
            async trainOnBatch(e, t) {
                const n = await this.standardizeUserData(e, t),
                    s = n[0],
                    r = n[1],
                    a = this.makeTrainFunction()(s.concat(r)),
                    i = [];
                for (const e of a) {
                    const t = await e.data();
                    i.push(t[0])
                }
                return bi(a), wy(n[0], e), wy(n[1], t), lf(i)
            }
            getNamedWeights(e) {
                const t = [],
                    n = null != e && e.trainableOnly,
                    s = n ? this.trainableWeights : this.weights,
                    r = this.getWeights(n);
                for (let e = 0; e < s.length; ++e) n && !s[e].trainable || t.push({
                    name: s[e].originalName,
                    tensor: r[e]
                });
                return t
            }
            set stopTraining(e) {
                this.stopTraining_ = e
            }
            get stopTraining() {
                return this.stopTraining_
            }
            get optimizer() {
                return this.optimizer_
            }
            set optimizer(e) {
                this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1)
            }
            dispose() {
                const e = super.dispose();
                if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
                    const t = gi().numTensors;
                    this.optimizer_.dispose(), e.numDisposedVariables += t - gi().numTensors
                }
                return e
            }
            getLossIdentifiers() {
                let e;
                if ("string" == typeof this.loss) e = hf(this.loss);
                else if (Array.isArray(this.loss)) {
                    for (const e of this.loss)
                        if ("string" != typeof e) throw new Error("Serialization of non-string loss is not supported.");
                    e = this.loss.map((e => hf(e)))
                } else {
                    const t = Object.keys(this.loss);
                    e = {};
                    const n = this.loss;
                    for (const s of t) {
                        if ("string" != typeof n[s]) throw new Error("Serialization of non-string loss is not supported.");
                        e[s] = hf(n[s])
                    }
                }
                return e
            }
            getMetricIdentifiers() {
                if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [hf(qg(this.metrics))];
                if (Array.isArray(this.metrics)) return this.metrics.map((e => hf(qg(e))));
                {
                    const e = {};
                    for (const t in this.metrics) e[t] = hf(qg(this.metrics[t]));
                    return e
                }
            }
            getTrainingConfig() {
                return {
                    loss: this.getLossIdentifiers(),
                    metrics: this.getMetricIdentifiers(),
                    optimizer_config: {
                        class_name: this.optimizer.getClassName(),
                        config: this.optimizer.getConfig()
                    }
                }
            }
            loadTrainingConfig(e) {
                if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
                if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
                if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
                const t = Sg(ny(e.optimizer_config));
                let n, s;
                if ("string" == typeof e.loss) n = pf(e.loss);
                else if (Array.isArray(e.loss)) n = e.loss.map((e => pf(e)));
                else if (null != e.loss) {
                    n = {};
                    for (const t in e.loss) n[t] = pf(e.loss[t])
                }
                if (Array.isArray(e.metrics)) s = e.metrics.map((e => pf(e)));
                else if (null != e.metrics) {
                    s = {};
                    for (const t in e.metrics) s[t] = pf(e.metrics[t])
                }
                this.compile({
                    loss: n,
                    metrics: s,
                    optimizer: t
                })
            }
            async save(e, t) {
                if ("string" == typeof e) {
                    const t = na(e);
                    if (0 === t.length) throw new tf(`Cannot find any save handlers for URL '${e}'`);
                    if (t.length > 1) throw new tf(`Found more than one (${t.length}) save handlers for URL '${e}'`);
                    e = t[0]
                }
                if (null == e.save) throw new tf("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                const n = await Hr(this.getNamedWeights(t)),
                    s = {
                        modelTopology: this.toJSON(null, !1),
                        format: "layers-model",
                        generatedBy: `TensorFlow.js tfjs-layers v${ry}`,
                        convertedBy: null
                    };
                if (null != t && t.includeOptimizer && null != this.optimizer) {
                    s.trainingConfig = this.getTrainingConfig();
                    const e = "optimizer",
                        {
                            data: t,
                            specs: r
                        } = await Hr(await this.optimizer.getWeights(), e);
                    n.specs.push(...r), n.data = Yr([n.data, t])
                }
                if (null != this.userDefinedMetadata) {
                    const e = !0;
                    Xg(this.userDefinedMetadata, this.name, e), s.userDefinedMetadata = this.userDefinedMetadata
                }
                return s.weightData = n.data, s.weightSpecs = n.specs, e.save(s)
            }
            setUserDefinedMetadata(e) {
                Xg(e, this.name), this.userDefinedMetadata = e
            }
            getUserDefinedMetadata() {
                return this.userDefinedMetadata
            }
        }
        Sy.className = "Model", fi(Sy);
        class Ty extends Sy {}
        Ty.className = "Functional", fi(Ty);
        class $y extends Sy {
            constructor(e) {
                if (super({
                        inputs: [],
                        outputs: []
                    }), e = e || {}, this.trainable = !0, this.built = !1, this.name = null != e.name ? e.name : Cf("sequential_"), null != e.layers)
                    for (const t of e.layers) this.add(t)
            }
            checkShape(e) {
                if (e.inboundNodes[0].outputTensors[0].shape.some((e => e < 0))) throw new tf(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)
            }
            add(e) {
                const t = e instanceof $y || e instanceof Sy;
                let n;
                if (t) {
                    if (n = e, 1 !== n.outputs.length) throw new tf("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                    if (1 !== n.inputs.length) throw new tf("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")
                }
                if (0 === this.outputs.length) {
                    if (0 === e.inboundNodes.length) {
                        if (null == e.batchInputShape) throw new tf("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
                        const t = function(e) {
                            if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
                            if (null != e.batchShape && null != e.shape) throw new tf("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
                            let t = e.batchShape;
                            null != e.shape && null == t && (t = [null].concat(e.shape));
                            let n = e.dtype;
                            return null == n && (n = "float32"), new Ym({
                                batchInputShape: t,
                                name: e.name,
                                dtype: n,
                                sparse: e.sparse
                            }).inboundNodes[0].outputTensors[0]
                        }({
                            batchShape: e.batchInputShape,
                            dtype: e.dtype,
                            name: e.name + "_input"
                        });
                        e.apply(t)
                    }
                    if (t) this.outputs = n.outputs, this.inputs = n.inputs;
                    else {
                        if (1 !== e.inboundNodes.length) throw new tf(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);
                        if (1 !== e.inboundNodes[0].outputTensors.length) throw new tf("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = Xm(this.outputs[0])
                    }
                    this.inboundNodes = [], new jm({
                        outboundLayer: this,
                        inboundLayers: [],
                        nodeIndices: [],
                        tensorIndices: [],
                        inputTensors: this.inputs,
                        outputTensors: this.outputs,
                        inputMasks: af(null, this.inputs.length),
                        outputMasks: [null],
                        inputShapes: this.inputs.map((e => e.shape)),
                        outputShapes: this.outputs[0].shape
                    })
                } else {
                    const t = e.apply(this.outputs[0]);
                    if (Array.isArray(t)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                    this.checkShape(e), this.outputs = [t], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
                }
                this.layers.push(e), this.built = !1
            }
            pop() {
                if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
                if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
                else {
                    const e = this.layers.length - 1;
                    this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
                }
            }
            call(e, t) {
                return null == this.model && this.build(), this.model.call(e, t)
            }
            build(e) {
                if (Lm(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
                this.model = new Sy({
                    inputs: this.inputs,
                    outputs: this.outputs[0],
                    name: this.name + "_model"
                }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0
            }
            countParams() {
                return this.built || this.build(), super.countParams()
            }
            summary(e, t, n = console.log) {
                this.built || this.build(), super.summary(e, t, n)
            }
            setWeights(e) {
                null == this.model && this.build(), this.model.setWeights(e)
            }
            evaluate(e, t, n = {}) {
                if (!this.built) throw new ef("The model needs to be compiled before being used.");
                return this.model.evaluate(e, t, n)
            }
            async evaluateDataset(e, t) {
                if (!this.built) throw new ef("The model needs to be compiled before being used.");
                return this.model.evaluateDataset(e, t)
            }
            predict(e, t = {}) {
                return null == this.model && this.build(), this.model.predict(e, t)
            }
            predictOnBatch(e) {
                return null == this.model && this.build(), this.model.predictOnBatch(e)
            }
            compile(e) {
                this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames
            }
            get optimizer() {
                return null == this.model ? void 0 : this.model.optimizer
            }
            set optimizer(e) {
                this.model.optimizer = e
            }
            async fit(e, t, n = {}) {
                if (!this.built) throw new ef("The model needs to be compiled before being used.");
                return this.model.fit(e, t, n)
            }
            async fitDataset(e, t) {
                if (!this.built) throw new ef("The model needs to be compiled before being used.");
                return this.model.fitDataset(e, t)
            }
            async trainOnBatch(e, t) {
                return this.model.trainOnBatch(e, t)
            }
            static fromConfig(e, t, n = {}, s = !1) {
                let r, a = {};
                if (t instanceof Array) {
                    if (null == t[0].className || "Merge" === t[0].className) throw new tf("Legacy serialization format not supported yet.");
                    r = t
                } else R(null != t.layers, (() => "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")), r = t.layers, delete t.layers, a = t;
                const i = new e(a);
                if (!(i instanceof $y)) throw new nf(`Sequential.fromConfig called on non-Sequential input: ${i}`);
                for (const e of r) {
                    const t = Sg(e, void 0, s);
                    s && t.setFastWeightInitDuringBuild(!0), i.add(t)
                }
                return i
            }
            set stopTraining(e) {
                if (null == this.model) throw new tf("Cannot set the stopTraining property of a sequential model before it is compiled.");
                this.model.stopTraining = e
            }
            get stopTraining() {
                if (null == this.model) throw new tf("Cannot get the stopTraining property of a sequential model before it is compiled.");
                return this.model.stopTraining
            }
            getConfig() {
                const e = [];
                for (const t of this.layers) {
                    const n = {};
                    n.className = t.getClassName(), n.config = t.getConfig(), e.push(n)
                }
                return {
                    name: this.name,
                    layers: e
                }
            }
        }
        $y.className = "Sequential", fi($y);
        class Cy extends pi {
            getConfig() {
                return {}
            }
        }
        class Ey extends Cy {
            apply(e, t = 1) {
                return function(e, t = 1) {
                    if (1 !== t) throw new nf(`Support for alpha values other than 1 (${t}) is not implemented yet.`);
                    return po(e)
                }(e, t)
            }
        }
        Ey.className = "elu", fi(Ey);
        class Ay extends Cy {
            apply(e) {
                return cu(e)
            }
        }
        Ay.className = "selu", fi(Ay);
        class Ry extends Cy {
            apply(e) {
                return uu(e)
            }
        }
        Ry.className = "relu", fi(Ry);
        class Fy extends Cy {
            apply(e) {
                return yi((() => zo(6, uu(e))))
            }
        }
        Fy.className = "relu6", fi(Fy);
        class Dy extends Cy {
            apply(e) {
                return e
            }
        }
        Dy.className = "linear", fi(Dy);
        class _y extends Cy {
            apply(e) {
                return pu(e)
            }
        }
        _y.className = "sigmoid", fi(_y);
        class Oy extends Cy {
            apply(e) {
                return function(e) {
                    return yi((() => {
                        const t = Si(.5, Co(.2, e));
                        return Yi(t, 0, 1)
                    }))
                }(e)
            }
        }
        Oy.className = "hardSigmoid", fi(Oy);
        class My extends Cy {
            apply(e) {
                return xu(e)
            }
        }
        My.className = "softplus", fi(My);
        class Ly extends Cy {
            apply(e) {
                return function(e) {
                    return yi((() => ho(e, Si(Ni(e), 1))))
                }(e)
            }
        }
        Ly.className = "softsign", fi(Ly);
        class zy extends Cy {
            apply(e) {
                return Nu(e)
            }
        }
        zy.className = "tanh", fi(zy);
        class By extends Cy {
            apply(e, t = -1) {
                return bu(e, t)
            }
        }
        By.className = "softmax", fi(By);
        class Py extends Cy {
            apply(e, t = -1) {
                return Ro(e, t)
            }
        }
        Py.className = "logSoftmax", fi(Py);
        class Uy extends Cy {
            apply(e, t = 1) {
                return yi((() => Co(pu(Co(e, t)), e)))
            }
        }
        Uy.className = "swish", fi(Uy);
        class Wy extends Cy {
            apply(e) {
                return yi((() => Co(e, Nu(xu(e)))))
            }
        }

        function Vy(e) {
            return e.getClassName()
        }

        function Gy(e, t = {}) {
            return gf(e, di.getMap().classNameMap, t, "activation")
        }

        function Hy(e) {
            if (null == e) {
                const e = {
                    className: "linear",
                    config: {}
                };
                return Gy(e)
            }
            if ("string" == typeof e) {
                const t = {};
                return t.className = e, t.config = {}, Gy(t)
            }
            return e instanceof Cy ? e : Gy(e)
        }

        function jy(e) {
            if (null != e && "object" != typeof e) throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)
        }
        Wy.className = "mish", fi(Wy);
        class qy extends pi {}
        class Ky extends qy {
            constructor(e) {
                super(), jy(e), this.l1 = null == e || null == e.l1 ? .01 : e.l1, this.l2 = null == e || null == e.l2 ? .01 : e.l2, this.hasL1 = 0 !== this.l1, this.hasL2 = 0 !== this.l2
            }
            apply(e) {
                return yi((() => {
                    let t = Zo([1]);
                    return this.hasL1 && (t = Si(t, Ao(Co(this.l1, Ni(e))))), this.hasL2 && (t = Si(t, Ao(Co(this.l2, om(e))))), Vi(t, [])
                }))
            }
            getConfig() {
                return {
                    l1: this.l1,
                    l2: this.l2
                }
            }
            static fromConfig(e, t) {
                return new e({
                    l1: t.l1,
                    l2: t.l2
                })
            }
        }
        Ky.className = "L1L2", fi(Ky);
        const Xy = {
            l1l2: "L1L2"
        };

        function Yy(e) {
            return ff(e)
        }

        function Jy(e, t = {}) {
            return gf(e, di.getMap().classNameMap, t, "regularizer")
        }

        function Zy(e) {
            if (null == e) return null;
            if ("string" == typeof e) {
                return Jy({
                    className: e in Xy ? Xy[e] : e,
                    config: {}
                })
            }
            return e instanceof qy ? e : Jy(e)
        }
        class Qy extends Km {
            constructor(e) {
                super(null == e ? {} : e), this.supportsMasking = !0, null != e && (this.maxValue = e.maxValue)
            }
            call(e, t) {
                e = Mm(e);
                let n = uu(e);
                return null != this.maxValue && (n = Yi(n, 0, this.maxValue)), n
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = {
                        maxValue: this.maxValue
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Qy.className = "ReLU", fi(Qy);
        class eb extends Km {
            constructor(e) {
                super(null == e ? {} : e), this.DEFAULT_ALPHA = .3, null == e && (e = {}), this.alpha = null == e.alpha ? this.DEFAULT_ALPHA : e.alpha
            }
            call(e, t) {
                const n = Mm(e);
                return No(n, this.alpha)
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = {
                        alpha: this.alpha
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        eb.className = "LeakyReLU", fi(eb);
        class tb extends Km {
            constructor(e) {
                if (super(null == e ? {} : e), this.DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), this.supportsMasking = !0, this.alphaInitializer = Dm(e.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER), this.alphaRegularizer = Zy(e.alphaRegularizer), this.alphaConstraint = dg(e.alphaConstraint), null == e.sharedAxes) this.sharedAxes = null;
                else if (Array.isArray(e.sharedAxes)) this.sharedAxes = e.sharedAxes;
                else {
                    if ("number" != typeof e.sharedAxes) throw new tf(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);
                    this.sharedAxes = [e.sharedAxes]
                }
            }
            build(e) {
                const t = (e = Lm(e)).slice(1);
                if (null != this.sharedAxes)
                    for (const e of this.sharedAxes) t[e - 1] = 1;
                this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
                const n = {};
                if (null != this.sharedAxes)
                    for (let t = 1; t < e.length; ++t) n[t] = e[t];
                this.inputSpec = [new Vm({
                    ndim: e.length,
                    axes: n
                })], this.built = !0
            }
            call(e, t) {
                return e = Mm(e), nu(e, this.alpha.read())
            }
            getConfig() {
                const e = {
                        alphaInitializer: Fm(this.alphaInitializer),
                        alphaRegularizer: Yy(this.alphaRegularizer),
                        alphaConstraint: hg(this.alphaConstraint),
                        sharedAxes: this.sharedAxes
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        tb.className = "PReLU", fi(tb);
        class nb extends Km {
            constructor(e) {
                if (super(null == e ? {} : e), this.DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== this.DEFAULT_ALPHA) throw new nf(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);
                this.alpha = null == e.alpha ? this.DEFAULT_ALPHA : e.alpha
            }
            call(e, t) {
                const n = Mm(e);
                return po(n)
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = {
                        alpha: this.alpha
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        nb.className = "ELU", fi(nb);
        class sb extends Km {
            constructor(e) {
                super(null == e ? {} : e), this.DEFAULT_THETA = 1, null == e && (e = {}), this.theta = null == e.theta ? this.DEFAULT_THETA : e.theta
            }
            call(e, t) {
                const n = Mm(e);
                return Co(n, Ra(vo(n, this.theta), "float32"))
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = {
                        theta: this.theta
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        sb.className = "ThresholdedReLU", fi(sb);
        class rb extends Km {
            constructor(e) {
                super(null == e ? {} : e), this.DEFAULT_AXIS = 1, null == e && (e = {}), this.softmax = (new By).apply, this.axis = null == e.axis ? this.DEFAULT_AXIS : e.axis
            }
            call(e, t) {
                const n = Mm(e);
                return this.softmax(n, this.axis)
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = {
                        axis: this.axis
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }

        function ab(e, t, n) {
            if ("number" == typeof e) return af(e, t);
            if (e.length !== t) throw new tf(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);
            for (let r = 0; r < t; ++r) {
                const a = e[r];
                if ((s = a) !== parseInt(s.toString(), 10)) throw new tf(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)
            }
            return e;
            var s
        }

        function ib(e, t, n, s, r = 1) {
            if (null == e) return e;
            let a;
            return a = "same" === n ? e : e - (t + (t - 1) * (r - 1)) + 1, Math.floor((a + s - 1) / s)
        }

        function ob(e, t, n, s) {
            if (null == e) return null;
            if ("valid" === s) e = e * t + jf([n - t, 0]);
            else {
                if ("same" !== s) throw new tf(`Unsupport padding mode: ${s}.`);
                e *= t
            }
            return e
        }

        function ub(e, t) {
            return yi((() => (Of(t), "channelsFirst" === t ? _u(e, [0, 2, 3, 1]) : e)))
        }

        function lb(e, t) {
            return yi((() => (Of(t), "channelsFirst" === t ? _u(e, [0, 2, 3, 4, 1]) : e)))
        }

        function cb(e, t, n, s = 1, r = "valid", a, i = 1) {
            return yi((() => {
                if (null == a && (a = "channelsLast"), Of(a), 3 !== e.shape.length) throw new tf(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);
                if (3 !== t.shape.length) throw new tf(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);
                if (null != n && 1 !== n.shape.length) throw new tf(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);
                if ("channelsFirst" === a && (e = _u(e, [0, 2, 1])), "causal" === r) throw new nf("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
                let o = so(e, t, s, "same" === r ? "same" : "valid", "NWC", i);
                return null != n && (o = lm(o, n)), o
            }))
        }

        function hb(e, t, n, s = [1, 1], r = "valid", a, i, o = null) {
            return yi((() => {
                if (null == a && (a = "channelsLast"), Of(a), 3 !== e.rank && 4 !== e.rank) throw new tf(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);
                if (3 !== t.rank && 4 !== t.rank) throw new tf(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);
                let u = ub(e, a);
                if ("causal" === r) throw new nf("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
                return u = qu({
                    x: u,
                    filter: t,
                    strides: s,
                    pad: "same" === r ? "same" : "valid",
                    dilations: i,
                    dataFormat: "NHWC",
                    bias: n,
                    activation: o
                }), "channelsFirst" === a && (u = _u(u, [0, 3, 1, 2])), u
            }))
        }

        function pb(e, t, n, s = [1, 1, 1], r = "valid", a, i) {
            return yi((() => {
                if (null == a && (a = "channelsLast"), Of(a), 4 !== e.rank && 5 !== e.rank) throw new tf(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);
                if (4 !== t.rank && 5 !== t.rank) throw new tf(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);
                let o = lb(e, a);
                if ("causal" === r) throw new nf("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
                return o = io(o, t, s, "same" === r ? "same" : "valid", "NDHWC", i), null != n && (o = lm(o, n)), "channelsFirst" === a && (o = _u(o, [0, 4, 1, 2, 3])), o
            }))
        }
        rb.className = "Softmax", fi(rb);
        class db extends Km {
            constructor(e, t) {
                if (super(t), this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", db.verifyArgs(t), this.rank = e, vf(this.rank, "rank"), 1 !== this.rank && 2 !== this.rank && 3 !== this.rank) throw new nf(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
                if (this.kernelSize = ab(t.kernelSize, e, "kernelSize"), this.strides = ab(null == t.strides ? 1 : t.strides, e, "strides"), this.padding = null == t.padding ? "valid" : t.padding, Mf(this.padding), this.dataFormat = null == t.dataFormat ? "channelsLast" : t.dataFormat, Of(this.dataFormat), this.activation = Hy(t.activation), this.useBias = null == t.useBias || t.useBias, this.biasInitializer = Dm(t.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.biasConstraint = dg(t.biasConstraint), this.biasRegularizer = Zy(t.biasRegularizer), this.activityRegularizer = Zy(t.activityRegularizer), this.dilationRate = ab(null == t.dilationRate ? 1 : t.dilationRate, e, "dilationRate"), 1 === this.rank && Array.isArray(this.dilationRate) && 1 !== this.dilationRate.length) throw new tf(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
                if (2 === this.rank) {
                    if ("number" == typeof this.dilationRate) this.dilationRate = [this.dilationRate, this.dilationRate];
                    else if (2 !== this.dilationRate.length) throw new tf(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)
                } else if (3 === this.rank)
                    if ("number" == typeof this.dilationRate) this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
                    else if (3 !== this.dilationRate.length) throw new tf(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)
            }
            static verifyArgs(e) {
                if (of("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !kf(e.kernelSize, "number", 1, 3)) throw new tf(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)
            }
            getConfig() {
                const e = {
                        kernelSize: this.kernelSize,
                        strides: this.strides,
                        padding: this.padding,
                        dataFormat: this.dataFormat,
                        dilationRate: this.dilationRate,
                        activation: Vy(this.activation),
                        useBias: this.useBias,
                        biasInitializer: Fm(this.biasInitializer),
                        biasRegularizer: Yy(this.biasRegularizer),
                        activityRegularizer: Yy(this.activityRegularizer),
                        biasConstraint: hg(this.biasConstraint)
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        class fb extends db {
            constructor(e, t) {
                super(e, t), this.kernel = null, fb.verifyArgs(t), this.filters = t.filters, vf(this.filters, "filters"), this.kernelInitializer = Dm(t.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.kernelConstraint = dg(t.kernelConstraint), this.kernelRegularizer = Zy(t.kernelRegularizer)
            }
            build(e) {
                e = Lm(e);
                const t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t]) throw new tf(`The channel dimension of the input should be defined. Found ${e[t]}`);
                const n = e[t],
                    s = this.kernelSize.concat([n, this.filters]);
                this.kernel = this.addWeight("kernel", s, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
                    ndim: this.rank + 2,
                    axes: {
                        [t]: n
                    }
                }], this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    let t;
                    e = Mm(e);
                    const n = null == this.bias ? null : this.bias.read(),
                        s = Nf(this.activation.getClassName());
                    if (null != s && 2 === this.rank) t = hb(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate, s);
                    else {
                        if (1 === this.rank) t = cb(e, this.kernel.read(), n, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
                        else if (2 === this.rank) t = hb(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate);
                        else {
                            if (3 !== this.rank) throw new nf("convolutions greater than 3D are not implemented yet.");
                            t = pb(e, this.kernel.read(), n, this.strides, this.padding, this.dataFormat, this.dilationRate)
                        }
                        null != this.activation && (t = this.activation.apply(t))
                    }
                    return t
                }))
            }
            computeOutputShape(e) {
                e = Lm(e);
                const t = [],
                    n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2);
                for (let e = 0; e < n.length; ++e) {
                    const s = ib(n[e], this.kernelSize[e], this.padding, this.strides[e], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[e]);
                    t.push(s)
                }
                let s = [e[0]];
                return "channelsLast" === this.dataFormat ? (s = s.concat(t), s.push(this.filters)) : (s.push(this.filters), s = s.concat(t)), s
            }
            getConfig() {
                const e = {
                        filters: this.filters,
                        kernelInitializer: Fm(this.kernelInitializer),
                        kernelRegularizer: Yy(this.kernelRegularizer),
                        kernelConstraint: hg(this.kernelConstraint)
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
            static verifyArgs(e) {
                if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new tf(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)
            }
        }
        class mb extends fb {
            constructor(e) {
                super(2, e), mb.verifyArgs(e)
            }
            getConfig() {
                const e = super.getConfig();
                return delete e.rank, e
            }
            static verifyArgs(e) {
                if ("number" != typeof e.kernelSize && !kf(e.kernelSize, "number", 1, 2)) throw new tf(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)
            }
        }
        mb.className = "Conv2D", fi(mb);
        class gb extends fb {
            constructor(e) {
                super(3, e), gb.verifyArgs(e)
            }
            getConfig() {
                const e = super.getConfig();
                return delete e.rank, e
            }
            static verifyArgs(e) {
                if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new tf(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)
            }
        }
        gb.className = "Conv3D", fi(gb);
        class yb extends mb {
            constructor(e) {
                if (super(e), this.inputSpec = [new Vm({
                        ndim: 4
                    })], "same" !== this.padding && "valid" !== this.padding) throw new tf(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)
            }
            build(e) {
                if (4 !== (e = Lm(e)).length) throw new tf("Input should have rank 4; Received input shape: " + JSON.stringify(e));
                const t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t]) throw new tf("The channel dimension of the inputs should be defined. Found `None`.");
                const n = e[t],
                    s = this.kernelSize.concat([this.filters, n]);
                this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new Vm({
                    ndim: 4,
                    axes: {
                        [t]: n
                    }
                })], this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    let t = Mm(e);
                    if (4 !== t.shape.length) throw new tf(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);
                    const n = t.shape,
                        s = n[0];
                    let r, a;
                    "channelsFirst" === this.dataFormat ? (r = 2, a = 3) : (r = 1, a = 2);
                    const i = n[r],
                        o = n[a],
                        u = this.kernelSize[0],
                        l = this.kernelSize[1],
                        c = this.strides[0],
                        h = this.strides[1],
                        p = [s, ob(i, c, u, this.padding), ob(o, h, l, this.padding), this.filters];
                    "channelsLast" !== this.dataFormat && (t = _u(t, [0, 2, 3, 1]));
                    let d = ao(t, this.kernel.read(), p, this.strides, this.padding);
                    return "channelsLast" !== this.dataFormat && (d = _u(d, [0, 3, 1, 2])), null != this.bias && (d = lm(d, this.bias.read(), this.dataFormat)), null != this.activation && (d = this.activation.apply(d)), d
                }))
            }
            computeOutputShape(e) {
                const t = (e = Lm(e)).slice();
                let n, s, r;
                "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3) : (n = 3, s = 1, r = 2);
                const a = this.kernelSize[0],
                    i = this.kernelSize[1],
                    o = this.strides[0],
                    u = this.strides[1];
                return t[n] = this.filters, t[s] = ob(t[s], o, a, this.padding), t[r] = ob(t[r], u, i, this.padding), t
            }
            getConfig() {
                const e = super.getConfig();
                return delete e.dilationRate, e
            }
        }
        yb.className = "Conv2DTranspose", fi(yb);
        class bb extends gb {
            constructor(e) {
                if (super(e), this.inputSpec = [new Vm({
                        ndim: 5
                    })], "same" !== this.padding && "valid" !== this.padding) throw new tf(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)
            }
            build(e) {
                if (5 !== (e = Lm(e)).length) throw new tf("Input should have rank 5; Received input shape: " + JSON.stringify(e));
                const t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t]) throw new tf("The channel dimension of the inputs should be defined. Found `None`.");
                const n = e[t],
                    s = this.kernelSize.concat([this.filters, n]);
                this.kernel = this.addWeight("kernel", s, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new Vm({
                    ndim: 5,
                    axes: {
                        [t]: n
                    }
                })], this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    let t = Mm(e);
                    if (5 !== t.shape.length) throw new tf(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);
                    const n = t.shape,
                        s = n[0];
                    let r, a, i;
                    "channelsFirst" === this.dataFormat ? (i = 2, r = 3, a = 4) : (i = 1, r = 2, a = 3);
                    const o = n[i],
                        u = n[r],
                        l = n[a],
                        c = this.kernelSize[0],
                        h = this.kernelSize[1],
                        p = this.kernelSize[2],
                        d = this.strides[0],
                        f = this.strides[1],
                        m = this.strides[2],
                        g = [s, ob(o, d, c, this.padding), ob(u, f, h, this.padding), ob(l, m, p, this.padding), this.filters];
                    "channelsLast" !== this.dataFormat && (t = _u(t, [0, 2, 3, 4, 1]));
                    let y = uo(t, this.kernel.read(), g, this.strides, this.padding);
                    return "channelsLast" !== this.dataFormat && (y = _u(y, [0, 4, 1, 2, 3])), null !== this.bias && (y = lm(y, this.bias.read(), this.dataFormat)), null !== this.activation && (y = this.activation.apply(y)), y
                }))
            }
            computeOutputShape(e) {
                const t = (e = Lm(e)).slice();
                let n, s, r, a;
                "channelsFirst" === this.dataFormat ? (n = 1, s = 2, r = 3, a = 4) : (n = 4, s = 1, r = 2, a = 3);
                const i = this.kernelSize[0],
                    o = this.kernelSize[1],
                    u = this.kernelSize[2],
                    l = this.strides[0],
                    c = this.strides[1],
                    h = this.strides[2];
                return t[n] = this.filters, t[s] = ob(t[s], l, i, this.padding), t[r] = ob(t[r], c, o, this.padding), t[a] = ob(t[a], h, u, this.padding), t
            }
            getConfig() {
                const e = super.getConfig();
                return delete e.dilationRate, e
            }
        }
        bb.className = "Conv3DTranspose", fi(bb);
        class xb extends fb {
            constructor(e, t) {
                if (super(e, t), this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", this.depthwiseKernel = null, this.pointwiseKernel = null, null == t.filters) throw new tf("The `filters` configuration field is required by SeparableConv, but is unspecified.");
                if (null != t.kernelInitializer || null != t.kernelRegularizer || null != t.kernelConstraint) throw new tf("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
                if (null != t.padding && "same" !== t.padding && "valid" !== t.padding) throw new tf(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);
                this.depthMultiplier = null == t.depthMultiplier ? 1 : t.depthMultiplier, this.depthwiseInitializer = Dm(t.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER), this.depthwiseRegularizer = Zy(t.depthwiseRegularizer), this.depthwiseConstraint = dg(t.depthwiseConstraint), this.pointwiseInitializer = Dm(t.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER), this.pointwiseRegularizer = Zy(t.pointwiseRegularizer), this.pointwiseConstraint = dg(t.pointwiseConstraint)
            }
            build(e) {
                if ((e = Lm(e)).length < this.rank + 2) throw new tf(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);
                const t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t] || e[t] < 0) throw new tf(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);
                const n = e[t],
                    s = this.kernelSize.concat([n, this.depthMultiplier]),
                    r = [];
                for (let e = 0; e < this.rank; ++e) r.push(1);
                r.push(n * this.depthMultiplier, this.filters);
                const a = !0;
                this.depthwiseKernel = this.addWeight("depthwise_kernel", s, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, a, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", r, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, a, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, a, this.biasConstraint) : this.bias = null, this.inputSpec = [new Vm({
                    ndim: this.rank + 2,
                    axes: {
                        [t]: n
                    }
                })], this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    let t;
                    if (e = Mm(e), 1 === this.rank) throw new nf("1D separable convolution is not implemented yet.");
                    return 2 === this.rank && ("channelsFirst" === this.dataFormat && (e = _u(e, [0, 2, 3, 1])), t = hu(e, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC")), this.useBias && (t = lm(t, this.bias.read(), this.dataFormat)), null != this.activation && (t = this.activation.apply(t)), "channelsFirst" === this.dataFormat && (t = _u(t, [0, 3, 1, 2])), t
                }))
            }
            getConfig() {
                const e = super.getConfig();
                return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = Fm(this.depthwiseInitializer), e.pointwiseInitializer = Fm(this.pointwiseInitializer), e.depthwiseRegularizer = Yy(this.depthwiseRegularizer), e.pointwiseRegularizer = Yy(this.pointwiseRegularizer), e.depthwiseConstraint = hg(this.depthwiseConstraint), e.pointwiseConstraint = hg(this.pointwiseConstraint), e
            }
        }
        xb.className = "SeparableConv";
        class wb extends xb {
            constructor(e) {
                super(2, e)
            }
        }
        wb.className = "SeparableConv2D", fi(wb);
        class kb extends fb {
            constructor(e) {
                super(1, e), kb.verifyArgs(e), this.inputSpec = [{
                    ndim: 3
                }]
            }
            getConfig() {
                const e = super.getConfig();
                return delete e.rank, delete e.dataFormat, e
            }
            static verifyArgs(e) {
                if ("number" != typeof e.kernelSize && !kf(e.kernelSize, "number", 1, 1)) throw new tf(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)
            }
        }
        kb.className = "Conv1D", fi(kb);
        class vb extends Km {
            constructor(e) {
                super(e), "number" == typeof e.cropping ? this.cropping = [
                    [e.cropping, e.cropping],
                    [e.cropping, e.cropping]
                ] : "number" == typeof e.cropping[0] ? this.cropping = [
                    [e.cropping[0], e.cropping[0]],
                    [e.cropping[1], e.cropping[1]]
                ] : this.cropping = e.cropping, this.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, this.inputSpec = [{
                    ndim: 4
                }]
            }
            computeOutputShape(e) {
                return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]]
            }
            call(e, t) {
                return yi((() => {
                    if (e = Mm(e), "channelsLast" === this.dataFormat) {
                        const t = em(e, this.cropping[0][0], e.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
                        return em(t, this.cropping[1][0], e.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3)
                    } {
                        const t = em(e, this.cropping[0][0], e.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
                        return em(t, this.cropping[1][0], e.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4)
                    }
                }))
            }
            getConfig() {
                const e = {
                        cropping: this.cropping,
                        dataFormat: this.dataFormat
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        vb.className = "Cropping2D", fi(vb);
        class Ib extends Km {
            constructor(e) {
                var t;
                super(e), this.DEFAULT_SIZE = [2, 2], this.inputSpec = [{
                    ndim: 4
                }], this.size = null == e.size ? this.DEFAULT_SIZE : e.size, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, Of(this.dataFormat), this.interpolation = null == e.interpolation ? "nearest" : e.interpolation, t = this.interpolation, wf(Af, "InterpolationFormat", t)
            }
            computeOutputShape(e) {
                if ("channelsFirst" === this.dataFormat) {
                    const t = null == e[2] ? null : this.size[0] * e[2],
                        n = null == e[3] ? null : this.size[1] * e[3];
                    return [e[0], e[1], t, n]
                } {
                    const t = null == e[1] ? null : this.size[0] * e[1],
                        n = null == e[2] ? null : this.size[1] * e[2];
                    return [e[0], t, n, e[3]]
                }
            }
            call(e, t) {
                return yi((() => {
                    let t = Mm(e);
                    const n = t.shape;
                    if ("channelsFirst" === this.dataFormat) {
                        t = _u(t, [0, 2, 3, 1]);
                        const e = this.size[0] * n[2],
                            s = this.size[1] * n[3],
                            r = "nearest" === this.interpolation ? Jl.resizeNearestNeighbor(t, [e, s]) : Jl.resizeBilinear(t, [e, s]);
                        return _u(r, [0, 3, 1, 2])
                    } {
                        const e = this.size[0] * n[1],
                            s = this.size[1] * n[2];
                        return "nearest" === this.interpolation ? Jl.resizeNearestNeighbor(t, [e, s]) : Jl.resizeBilinear(t, [e, s])
                    }
                }))
            }
            getConfig() {
                const e = {
                        size: this.size,
                        dataFormat: this.dataFormat,
                        interpolation: this.interpolation
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Ib.className = "UpSampling2D", fi(Ib);
        class Nb extends db {
            constructor(e) {
                super(2, e), this.depthwiseKernel = null, this.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, this.depthwiseInitializer = Dm(e.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.depthwiseConstraint = dg(e.depthwiseConstraint), this.depthwiseRegularizer = Zy(e.depthwiseRegularizer)
            }
            build(e) {
                if ((e = Lm(e)).length < 4) throw new tf(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);
                const t = "channelsFirst" === this.dataFormat ? 1 : 3;
                if (null == e[t] || e[t] < 0) throw new tf(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);
                const n = e[t],
                    s = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
                this.depthwiseKernel = this.addWeight("depthwise_kernel", s, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    let t = function(e, t, n = [1, 1], s = "valid", r, a) {
                        return yi((() => {
                            null == r && (r = "channelsLast"), Of(r);
                            let i = ub(e, r);
                            if (4 !== e.rank) throw new tf(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);
                            if (4 !== t.rank) throw new tf(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);
                            return i = lo(i, t, n, "same" === s ? "same" : "valid", "NHWC", a), "channelsFirst" === r && (i = _u(i, [0, 3, 1, 2])), i
                        }))
                    }(e = Mm(e), this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
                    return this.useBias && (t = lm(t, this.bias.read(), this.dataFormat)), null != this.activation && (t = this.activation.apply(t)), t
                }))
            }
            computeOutputShape(e) {
                e = Lm(e);
                const t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                    n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
                    s = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
                    r = ib(t, this.kernelSize[0], this.padding, this.strides[0]),
                    a = ib(n, this.kernelSize[1], this.padding, this.strides[1]);
                return "channelsFirst" === this.dataFormat ? [e[0], s, r, a] : [e[0], r, a, s]
            }
            getConfig() {
                const e = super.getConfig();
                return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = Fm(this.depthwiseInitializer), e.depthwiseRegularizer = Yy(this.depthwiseRegularizer), e.depthwiseConstraint = hg(this.depthwiseRegularizer), e
            }
        }

        function Sb(e, t, n, s) {
            if (Array.isArray(e)) {
                if (null != t || null != n) throw new tf("When inputs is an array, neither initialState or constants should be provided");
                null != s && (n = e.slice(e.length - s, e.length), e = e.slice(0, e.length - s)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0]
            }

            function r(e) {
                return null == e || Array.isArray(e) ? e : [e]
            }
            return {
                inputs: e,
                initialState: t = r(t),
                constants: n = r(n)
            }
        }

        function Tb(e, t, n, s = !1, r, a, i = !1, o = !1) {
            return yi((() => {
                const u = t.shape.length;
                if (u < 3) throw new tf(`Input should be at least 3D, but is ${u}D.`);
                const l = [1, 0].concat(qf(2, u));
                if (t = _u(t, l), null != a) throw new nf("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
                i && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != r && ((r = Ra(Ra(r, "bool"), "float32")).rank === u - 1 && (r = go(r, -1)), r = _u(r, l)), s && (t = lu(t, 0), null != r && (r = lu(r, 0)));
                const c = [];
                let h, p = n;
                const d = t.shape[0],
                    f = Cu(t);
                let m, g;
                null != r && (m = Cu(r));
                for (let t = 0; t < d; ++t) {
                    const n = f[t],
                        s = yi((() => e(n, p)));
                    if (null == r) h = s[0], p = s[1];
                    else {
                        const e = yi((() => {
                            const e = m[t],
                                n = Eo(eu(e), e);
                            return {
                                output: Si(Co(s[0], e), Co(p[0], n)),
                                newStates: p.map(((t, r) => Si(Co(s[1][r], e), Co(t, n))))
                            }
                        }));
                        h = e.output, p = e.newStates
                    }
                    o && c.push(h)
                }
                if (o) {
                    g = Iu(c, 1)
                }
                return [h, g, p]
            }))
        }
        Nb.className = "DepthwiseConv2D", fi(Nb);
        class $b extends Km {
            constructor(e) {
                let t;
                if (super(e), null == e.cell) throw new tf("cell property is missing for the constructor of RNN.");
                if (t = Array.isArray(e.cell) ? new Ob({
                        cells: e.cell
                    }) : e.cell, null == t.stateSize) throw new tf("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
                this.cell = t, this.returnSequences = null != e.returnSequences && e.returnSequences, this.returnState = null != e.returnState && e.returnState, this.goBackwards = null != e.goBackwards && e.goBackwards, this._stateful = null != e.stateful && e.stateful, this.unroll = null != e.unroll && e.unroll, this.supportsMasking = !0, this.inputSpec = [new Vm({
                    ndim: 3
                })], this.stateSpec = null, this.states_ = null, this.numConstants = null, this.keptStates = []
            }
            getStates() {
                if (null == this.states_) {
                    return qf(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map((e => null))
                }
                return this.states_
            }
            setStates(e) {
                this.states_ = e
            }
            computeOutputShape(e) {
                _m(e) && (e = e[0]);
                let t = this.cell.stateSize;
                Array.isArray(t) || (t = [t]);
                const n = t[0];
                let s;
                if (s = this.returnSequences ? [e[0], e[1], n] : [e[0], n], this.returnState) {
                    const n = [];
                    for (const s of t) n.push([e[0], s]);
                    return [s].concat(n)
                }
                return s
            }
            computeMask(e, t) {
                return yi((() => {
                    Array.isArray(t) && (t = t[0]);
                    const e = this.returnSequences ? t : null;
                    if (this.returnState) {
                        const t = this.states.map((e => null));
                        return [e].concat(t)
                    }
                    return e
                }))
            }
            get states() {
                if (null == this.states_) {
                    const e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1,
                        t = [];
                    for (let n = 0; n < e; ++n) t.push(null);
                    return t
                }
                return this.states_
            }
            set states(e) {
                this.states_ = e
            }
            build(e) {
                if (null != this.numConstants) throw new nf("Constants support is not implemented in RNN yet.");
                _m(e) && (e = e[0]);
                const t = this.stateful ? e[0] : null,
                    n = e.slice(2);
                this.inputSpec[0] = new Vm({
                    shape: [t, null, ...n]
                });
                const s = [e[0]].concat(e.slice(2));
                let r;
                if (this.cell.build(s), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
                    if (!M(this.stateSpec.map((e => e.shape[e.shape.length - 1])), r)) throw new tf(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)
                } else this.stateSpec = r.map((e => new Vm({
                    shape: [null, e]
                })));
                this.stateful && this.resetStates()
            }
            resetStates(e, t = !1) {
                yi((() => {
                    if (!this.stateful) throw new Qd("Cannot call resetStates() on an RNN Layer that is not stateful.");
                    const n = this.inputSpec[0].shape[0];
                    if (null == n) throw new tf("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                    if (null == this.states_) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((e => Zo([n, e]))) : this.states_ = [Zo([n, this.cell.stateSize])];
                    else if (null == e) bi(this.states_), null != this.keptStates && (bi(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((e => Zo([n, e]))) : this.states_[0] = Zo([n, this.cell.stateSize]);
                    else {
                        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length) throw new tf(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
                        !0 === t ? this.keptStates.push(this.states_.slice()) : bi(this.states_);
                        for (let t = 0; t < this.states_.length; ++t) {
                            const s = e[t],
                                r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[t] : this.cell.stateSize,
                                a = [n, r];
                            if (!M(s.shape, a)) throw new tf(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);
                            this.states_[t] = s
                        }
                    }
                    this.states_ = this.states_.map((e => xi(e.clone())))
                }))
            }
            apply(e, t) {
                let n = null == t ? null : t.initialState,
                    s = null == t ? null : t.constants;
                null == t && (t = {});
                const r = Sb(e, n, s, this.numConstants);
                e = r.inputs, n = r.initialState, s = r.constants;
                let a = [],
                    i = [];
                if (null != n) {
                    t.initialState = n, a = a.concat(n), this.stateSpec = [];
                    for (const e of n) this.stateSpec.push(new Vm({
                        shape: e.shape
                    }));
                    i = i.concat(this.stateSpec)
                }
                null != s && (t.constants = s, a = a.concat(s), this.numConstants = s.length);
                if (a[0] instanceof Gm) {
                    const n = [e].concat(a),
                        s = this.inputSpec.concat(i),
                        r = this.inputSpec;
                    this.inputSpec = s;
                    const o = super.apply(n, t);
                    return this.inputSpec = r, o
                }
                return super.apply(e, t)
            }
            call(e, t) {
                return yi((() => {
                    const n = null == t ? null : t.mask,
                        s = null == t ? null : t.training;
                    let r = null == t ? null : t.initialState;
                    e = Mm(e), null == r && (r = this.stateful ? this.states_ : this.getInitialState(e));
                    const a = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
                    if (r.length !== a) throw new tf(`RNN Layer has ${a} state(s) but was passed ${r.length} initial state(s).`);
                    this.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
                    const i = {
                            training: s
                        },
                        o = Tb(((e, t) => {
                            const n = this.cell.call([e].concat(t), i);
                            return [n[0], n.slice(1)]
                        }), e, r, this.goBackwards, n, null, this.unroll, this.returnSequences),
                        u = o[0],
                        l = o[1],
                        c = o[2];
                    this.stateful && this.resetStates(c, s);
                    const h = this.returnSequences ? l : u;
                    return this.returnState ? [h].concat(c) : h
                }))
            }
            getInitialState(e) {
                return yi((() => {
                    let t = Zo(e.shape);
                    return t = Ao(t, [1, 2]), t = Jf(t), Array.isArray(this.cell.stateSize) ? this.cell.stateSize.map((e => e > 1 ? sm(t, [1, e]) : t)) : this.cell.stateSize > 1 ? [sm(t, [1, this.cell.stateSize])] : [t]
                }))
            }
            get trainableWeights() {
                return this.trainable ? this.cell.trainableWeights : []
            }
            get nonTrainableWeights() {
                return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights
            }
            setFastWeightInitDuringBuild(e) {
                super.setFastWeightInitDuringBuild(e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e)
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        returnSequences: this.returnSequences,
                        returnState: this.returnState,
                        goBackwards: this.goBackwards,
                        stateful: this.stateful,
                        unroll: this.unroll
                    };
                null != this.numConstants && (t.numConstants = this.numConstants);
                const n = this.cell.getConfig();
                return this.getClassName() === $b.className && (t.cell = {
                    className: this.cell.getClassName(),
                    config: n
                }), Object.assign({}, n, e, t)
            }
            static fromConfig(e, t, n = {}) {
                const s = Sg(t.cell, n);
                return new e(Object.assign(t, {
                    cell: s
                }))
            }
        }
        $b.className = "RNN", fi($b);
        class Cb extends Km {}
        class Eb extends Cb {
            constructor(e) {
                super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, vf(this.units, "units"), this.activation = Hy(null == e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Dm(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Dm(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Dm(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Zy(e.kernelRegularizer), this.recurrentRegularizer = Zy(e.recurrentRegularizer), this.biasRegularizer = Zy(e.biasRegularizer), this.kernelConstraint = dg(e.kernelConstraint), this.recurrentConstraint = dg(e.recurrentConstraint), this.biasConstraint = dg(e.biasConstraint), this.dropout = Hf([1, jf([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = Hf([1, jf([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.dropoutFunc = e.dropoutFunc, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null
            }
            build(e) {
                e = Lm(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    if (2 !== e.length) throw new tf(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);
                    let n = e[1];
                    e = e[0];
                    const s = null != t.training && t.training;
                    let r;
                    0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mb({
                        ones: () => eu(e),
                        rate: this.dropout,
                        training: s,
                        dropoutFunc: this.dropoutFunc
                    })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mb({
                        ones: () => eu(n),
                        rate: this.recurrentDropout,
                        training: s,
                        dropoutFunc: this.dropoutFunc
                    }));
                    const a = this.dropoutMask,
                        i = this.recurrentDropoutMask;
                    r = am(null != a ? Co(e, a) : e, this.kernel.read()), null != this.bias && (r = lm(r, this.bias.read())), null != i && (n = Co(n, i));
                    let o = Si(r, am(n, this.recurrentKernel.read()));
                    return null != this.activation && (o = this.activation.apply(o)), [o, o]
                }))
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        units: this.units,
                        activation: Vy(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: Fm(this.kernelInitializer),
                        recurrentInitializer: Fm(this.recurrentInitializer),
                        biasInitializer: Fm(this.biasInitializer),
                        kernelRegularizer: Yy(this.kernelRegularizer),
                        recurrentRegularizer: Yy(this.recurrentRegularizer),
                        biasRegularizer: Yy(this.biasRegularizer),
                        activityRegularizer: Yy(this.activityRegularizer),
                        kernelConstraint: hg(this.kernelConstraint),
                        recurrentConstraint: hg(this.recurrentConstraint),
                        biasConstraint: hg(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout
                    };
                return Object.assign({}, e, t)
            }
        }
        Eb.className = "SimpleRNNCell", fi(Eb);
        class Ab extends $b {
            constructor(e) {
                e.cell = new Eb(e), super(e)
            }
            call(e, t) {
                return yi((() => {
                    null != this.cell.dropoutMask && (bi(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (bi(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
                    const n = null == t ? null : t.mask,
                        s = null == t ? null : t.training,
                        r = null == t ? null : t.initialState;
                    return super.call(e, {
                        mask: n,
                        training: s,
                        initialState: r
                    })
                }))
            }
            static fromConfig(e, t) {
                return new e(t)
            }
        }
        Ab.className = "SimpleRNN", fi(Ab);
        class Rb extends Cb {
            constructor(e) {
                if (super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter) throw new tf("GRUCell does not support reset_after parameter set to true.");
                this.units = e.units, vf(this.units, "units"), this.activation = Hy(void 0 === e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = Hy(void 0 === e.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Dm(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Dm(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Dm(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelRegularizer = Zy(e.kernelRegularizer), this.recurrentRegularizer = Zy(e.recurrentRegularizer), this.biasRegularizer = Zy(e.biasRegularizer), this.kernelConstraint = dg(e.kernelConstraint), this.recurrentConstraint = dg(e.recurrentConstraint), this.biasConstraint = dg(e.biasConstraint), this.dropout = Hf([1, jf([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = Hf([1, jf([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = this.units, this.dropoutMask = null, this.recurrentDropoutMask = null
            }
            build(e) {
                const t = (e = Lm(e))[e.length - 1];
                this.kernel = this.addWeight("kernel", [t, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    if (2 !== e.length) throw new tf(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);
                    const n = null != t.training && t.training;
                    let s = e[1];
                    e = e[0], 0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mb({
                        ones: () => eu(e),
                        rate: this.dropout,
                        training: n,
                        count: 3,
                        dropoutFunc: this.dropoutFunc
                    })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mb({
                        ones: () => eu(s),
                        rate: this.recurrentDropout,
                        training: n,
                        count: 3,
                        dropoutFunc: this.dropoutFunc
                    }));
                    const r = this.dropoutMask,
                        a = this.recurrentDropoutMask;
                    let i, o, u;
                    0 < this.dropout && this.dropout < 1 && (e = Co(e, r[0]));
                    let l = am(e, this.kernel.read());
                    this.useBias && (l = lm(l, this.bias.read())), 0 < this.recurrentDropout && this.recurrentDropout < 1 && (s = Co(s, a[0]));
                    const c = this.recurrentKernel.read(),
                        [h, p] = wu(c, [2 * this.units, this.units], c.rank - 1),
                        d = am(s, h),
                        [f, m, g] = wu(l, 3, l.rank - 1),
                        [y, b] = wu(d, 2, d.rank - 1);
                    i = this.recurrentActivation.apply(Si(f, y)), o = this.recurrentActivation.apply(Si(m, b));
                    const x = am(Co(o, s), p);
                    u = this.activation.apply(Si(g, x));
                    const w = Si(Co(i, s), Co(Si(1, Xo(i)), u));
                    return [w, w]
                }))
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        units: this.units,
                        activation: Vy(this.activation),
                        recurrentActivation: Vy(this.recurrentActivation),
                        useBias: this.useBias,
                        kernelInitializer: Fm(this.kernelInitializer),
                        recurrentInitializer: Fm(this.recurrentInitializer),
                        biasInitializer: Fm(this.biasInitializer),
                        kernelRegularizer: Yy(this.kernelRegularizer),
                        recurrentRegularizer: Yy(this.recurrentRegularizer),
                        biasRegularizer: Yy(this.biasRegularizer),
                        activityRegularizer: Yy(this.activityRegularizer),
                        kernelConstraint: hg(this.kernelConstraint),
                        recurrentConstraint: hg(this.recurrentConstraint),
                        biasConstraint: hg(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation,
                        resetAfter: !1
                    };
                return Object.assign({}, e, t)
            }
        }
        Rb.className = "GRUCell", fi(Rb);
        class Fb extends $b {
            constructor(e) {
                0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Rb(e), super(e)
            }
            call(e, t) {
                return yi((() => {
                    null != this.cell.dropoutMask && (bi(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (bi(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
                    const n = null == t ? null : t.mask,
                        s = null == t ? null : t.training,
                        r = null == t ? null : t.initialState;
                    return super.call(e, {
                        mask: n,
                        training: s,
                        initialState: r
                    })
                }))
            }
            static fromConfig(e, t) {
                return 0 === t.implmentation && (t.implementation = 1), new e(t)
            }
        }
        Fb.className = "GRU", fi(Fb);
        class Db extends Cb {
            constructor(e) {
                super(e), this.DEFAULT_ACTIVATION = "tanh", this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", this.DEFAULT_BIAS_INITIALIZER = "zeros", this.units = e.units, vf(this.units, "units"), this.activation = Hy(void 0 === e.activation ? this.DEFAULT_ACTIVATION : e.activation), this.recurrentActivation = Hy(void 0 === e.recurrentActivation ? this.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), this.useBias = null == e.useBias || e.useBias, this.kernelInitializer = Dm(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.recurrentInitializer = Dm(e.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER), this.biasInitializer = Dm(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.unitForgetBias = e.unitForgetBias, this.kernelRegularizer = Zy(e.kernelRegularizer), this.recurrentRegularizer = Zy(e.recurrentRegularizer), this.biasRegularizer = Zy(e.biasRegularizer), this.kernelConstraint = dg(e.kernelConstraint), this.recurrentConstraint = dg(e.recurrentConstraint), this.biasConstraint = dg(e.biasConstraint), this.dropout = Hf([1, jf([0, null == e.dropout ? 0 : e.dropout])]), this.recurrentDropout = Hf([1, jf([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), this.dropoutFunc = e.dropoutFunc, this.implementation = e.implementation, this.stateSize = [this.units, this.units], this.dropoutMask = null, this.recurrentDropoutMask = null
            }
            build(e) {
                var t;
                const n = (e = Lm(e))[e.length - 1];
                let s;
                if (this.kernel = this.addWeight("kernel", [n, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
                    if (this.unitForgetBias) {
                        const e = this.biasInitializer,
                            n = this.units;
                        s = new((t = class extends fm {
                            apply(t, s) {
                                const r = e.apply([n]),
                                    a = (new gm).apply([n]),
                                    i = e.apply([2 * n]);
                                return nm(nm(r, a), i)
                            }
                        }).className = "CustomInit", t)
                    } else s = this.biasInitializer;
                    this.bias = this.addWeight("bias", [4 * this.units], null, s, this.biasRegularizer, !0, this.biasConstraint)
                } else this.bias = null;
                this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    const n = null != t.training && t.training;
                    if (3 !== e.length) throw new tf(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
                    let s = e[1];
                    const r = e[2];
                    e = e[0], 0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mb({
                        ones: () => eu(e),
                        rate: this.dropout,
                        training: n,
                        count: 4,
                        dropoutFunc: this.dropoutFunc
                    })), 0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mb({
                        ones: () => eu(s),
                        rate: this.recurrentDropout,
                        training: n,
                        count: 4,
                        dropoutFunc: this.dropoutFunc
                    }));
                    const a = this.dropoutMask,
                        i = this.recurrentDropoutMask;
                    let o, u, l, c;
                    0 < this.dropout && this.dropout < 1 && (e = Co(e, a[0]));
                    let h = am(e, this.kernel.read());
                    0 < this.recurrentDropout && this.recurrentDropout < 1 && (s = Co(s, i[0])), h = Si(h, am(s, this.recurrentKernel.read())), this.useBias && (h = lm(h, this.bias.read()));
                    const [p, d, f, m] = wu(h, 4, h.rank - 1);
                    o = this.recurrentActivation.apply(p), u = this.recurrentActivation.apply(d), l = Si(Co(u, r), Co(o, this.activation.apply(f))), c = this.recurrentActivation.apply(m);
                    const g = Co(c, this.activation.apply(l));
                    return [g, g, l]
                }))
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        units: this.units,
                        activation: Vy(this.activation),
                        recurrentActivation: Vy(this.recurrentActivation),
                        useBias: this.useBias,
                        kernelInitializer: Fm(this.kernelInitializer),
                        recurrentInitializer: Fm(this.recurrentInitializer),
                        biasInitializer: Fm(this.biasInitializer),
                        unitForgetBias: this.unitForgetBias,
                        kernelRegularizer: Yy(this.kernelRegularizer),
                        recurrentRegularizer: Yy(this.recurrentRegularizer),
                        biasRegularizer: Yy(this.biasRegularizer),
                        activityRegularizer: Yy(this.activityRegularizer),
                        kernelConstraint: hg(this.kernelConstraint),
                        recurrentConstraint: hg(this.recurrentConstraint),
                        biasConstraint: hg(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation
                    };
                return Object.assign({}, e, t)
            }
        }
        Db.className = "LSTMCell", fi(Db);
        class _b extends $b {
            constructor(e) {
                0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Db(e), super(e)
            }
            call(e, t) {
                return yi((() => {
                    null != this.cell.dropoutMask && (bi(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (bi(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null);
                    const n = null == t ? null : t.mask,
                        s = null == t ? null : t.training,
                        r = null == t ? null : t.initialState;
                    return super.call(e, {
                        mask: n,
                        training: s,
                        initialState: r
                    })
                }))
            }
            static fromConfig(e, t) {
                return 0 === t.implmentation && (t.implementation = 1), new e(t)
            }
        }
        _b.className = "LSTM", fi(_b);
        class Ob extends Cb {
            constructor(e) {
                super(e), this.cells = e.cells
            }
            get stateSize() {
                const e = [];
                for (const t of this.cells.slice().reverse()) Array.isArray(t.stateSize) ? e.push(...t.stateSize) : e.push(t.stateSize);
                return e
            }
            call(e, t) {
                return yi((() => {
                    let n = e.slice(1);
                    const s = [];
                    for (const e of this.cells.slice().reverse()) Array.isArray(e.stateSize) ? s.push(n.splice(0, e.stateSize.length)) : s.push(n.splice(0, 1));
                    s.reverse();
                    const r = [];
                    let a;
                    for (let i = 0; i < this.cells.length; ++i) {
                        const o = this.cells[i];
                        n = s[i], a = 0 === i ? [e[0]].concat(n) : [a[0]].concat(n), a = o.call(a, t), r.push(a.slice(1))
                    }
                    n = [];
                    for (const e of r.slice().reverse()) n.push(...e);
                    return [a[0]].concat(n)
                }))
            }
            build(e) {
                let t;
                _m(e) && (e = e[0]), this.cells.forEach(((n, s) => {
                    Bf(`RNNCell_${s}`, (() => {
                        n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t]
                    }))
                })), this.built = !0
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        cells: this.cells.map((e => ({
                            className: e.getClassName(),
                            config: e.getConfig()
                        })))
                    };
                return Object.assign({}, e, t)
            }
            static fromConfig(e, t, n = {}) {
                const s = [];
                for (const e of t.cells) s.push(Sg(e, n));
                return new e({
                    cells: s
                })
            }
            get trainableWeights() {
                if (!this.trainable) return [];
                const e = [];
                for (const t of this.cells) e.push(...t.trainableWeights);
                return e
            }
            get nonTrainableWeights() {
                const e = [];
                for (const t of this.cells) e.push(...t.nonTrainableWeights);
                if (!this.trainable) {
                    const t = [];
                    for (const e of this.cells) t.push(...e.trainableWeights);
                    return t.concat(e)
                }
                return e
            }
            getWeights() {
                const e = [];
                for (const t of this.cells) e.push(...t.weights);
                return Um(e)
            }
            setWeights(e) {
                const t = [];
                for (const n of this.cells) {
                    const s = n.weights.length,
                        r = e.splice(s);
                    for (let e = 0; e < n.weights.length; ++e) t.push([n.weights[e], r[e]])
                }
                Wm(t)
            }
        }

        function Mb(e) {
            const {
                ones: t,
                rate: n,
                training: s = !1,
                count: r = 1,
                dropoutFunc: a
            } = e, i = () => null != a ? a(t(), n) : cm(t(), n), o = () => hm(i, t, s);
            if (!r || r <= 1) return xi(o().clone());
            return Array(r).fill(void 0).map(o).map((e => xi(e.clone())))
        }
        Ob.className = "StackedRNNCells", fi(Ob);
        var Lb = function(e, t) {
            var n = {};
            for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (n[s] = e[s]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                var r = 0;
                for (s = Object.getOwnPropertySymbols(e); r < s.length; r++) t.indexOf(s[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[r]) && (n[s[r]] = e[s[r]])
            }
            return n
        };
        class zb extends $b {
            constructor(e) {
                if (e.unroll) throw new nf("Unrolling is not possible with convolutional RNNs.");
                if (Array.isArray(e.cell)) throw new nf("It is not possible at the moment to stack convolutional cells.");
                super(e), this.inputSpec = [new Vm({
                    ndim: 5
                })]
            }
            call(e, t) {
                return yi((() => {
                    if (null != this.cell.dropoutMask && (bi(this.cell.dropoutMask), this.cell.dropoutMask = null), null != this.cell.recurrentDropoutMask && (bi(this.cell.recurrentDropoutMask), this.cell.recurrentDropoutMask = null), t && t.constants) throw new tf("ConvRNN2D cell does not support constants");
                    const n = null == t ? null : t.mask,
                        s = null == t ? null : t.training,
                        r = null == t ? null : t.initialState;
                    return super.call(e, {
                        mask: n,
                        training: s,
                        initialState: r
                    })
                }))
            }
            computeOutputShape(e) {
                let t = this.computeSingleOutputShape(e);
                return this.returnSequences || (t = [t[0], ...t.slice(2)]), this.returnState && (t = [t, ...Array(2).fill([e[0], ...t.slice(-3)])]), t
            }
            getInitialState(e) {
                return yi((() => {
                    const {
                        stateSize: t
                    } = this.cell, n = e.shape, s = this.computeSingleOutputShape(n), r = Zo([s[0], ...s.slice(2)]);
                    return Array.isArray(t) ? Array(t.length).fill(r) : [r]
                }))
            }
            resetStates(e, t = !1) {
                yi((() => {
                    if (!this.stateful) throw new Qd("Cannot call resetStates() on an RNN Layer that is not stateful.");
                    const n = this.inputSpec[0].shape,
                        s = this.computeSingleOutputShape(n),
                        r = [s[0], ...s.slice(2)];
                    if (null == n[0]) throw new tf("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                    if (null == this.getStates()) Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((() => Zo(r))) : this.states_ = [Zo(r)];
                    else if (null == e) bi(this.states_), null != this.keptStates && (bi(this.keptStates), this.keptStates = []), Array.isArray(this.cell.stateSize) ? this.states_ = this.cell.stateSize.map((() => Zo(r))) : this.states_[0] = Zo(r);
                    else {
                        if (Array.isArray(e) || (e = [e]), e.length !== this.states_.length) throw new tf(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);
                        t ? this.keptStates.push(this.states_.slice()) : bi(this.states_);
                        for (let t = 0; t < this.states_.length; ++t) {
                            const n = e[t],
                                s = r;
                            if (!M(n.shape, s)) throw new tf(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${n.shape}`);
                            this.states_[t] = n
                        }
                    }
                    this.states_ = this.states_.map((e => xi(e.clone())))
                }))
            }
            computeSingleOutputShape(e) {
                const {
                    dataFormat: t,
                    filters: n,
                    kernelSize: s,
                    padding: r,
                    strides: a,
                    dilationRate: i
                } = this.cell, o = "channelsFirst" === t, u = e[o ? 3 : 2], l = e[o ? 4 : 3], c = ib(u, s[0], r, a[0], i[0]), h = ib(l, s[1], r, a[1], i[1]);
                return [...e.slice(0, 2), ...o ? [n, c, h] : [c, h, n]]
            }
        }
        zb.className = "ConvRNN2D";
        class Bb extends Db {
            constructor(e) {
                const {
                    filters: t,
                    kernelSize: n,
                    strides: s,
                    padding: r,
                    dataFormat: a,
                    dilationRate: i
                } = e;
                super(Object.assign({}, e, {
                    units: t
                })), this.filters = t, vf(this.filters, "filters"), this.kernelSize = ab(n, 2, "kernelSize"), this.kernelSize.forEach((e => vf(e, "kernelSize"))), this.strides = ab(s || 1, 2, "strides"), this.strides.forEach((e => vf(e, "strides"))), this.padding = r || "valid", Mf(this.padding), this.dataFormat = a || "channelsLast", Of(this.dataFormat), this.dilationRate = ab(i || 1, 2, "dilationRate"), this.dilationRate.forEach((e => vf(e, "dilationRate")))
            }
            build(e) {
                var t;
                e = Lm(e);
                const n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[n]) throw new tf(`The channel dimension of the input should be defined. Found ${e[n]}`);
                const s = e[n],
                    r = this.kernelSize.concat([s, 4 * this.filters]);
                this.kernel = this.addWeight("kernel", r, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
                const a = this.kernelSize.concat([this.filters, 4 * this.filters]);
                if (this.recurrentKernel = this.addWeight("recurrent_kernel", a, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
                    let e;
                    if (this.unitForgetBias) {
                        const n = this.biasInitializer,
                            s = this.filters;
                        e = new((t = class extends fm {
                            apply(e, t) {
                                return tm([n.apply([s]), Qo([s]), n.apply([2 * s])])
                            }
                        }).className = "CustomInit", t)
                    } else e = this.biasInitializer;
                    this.bias = this.addWeight("bias", [4 * this.filters], null, e, this.biasRegularizer, !0, this.biasConstraint)
                }
                this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    if (3 !== e.length) throw new tf(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);
                    const n = t.training || !1,
                        s = e[0],
                        r = e[1],
                        a = e[2];
                    0 < this.dropout && this.dropout < 1 && null == this.dropoutMask && (this.dropoutMask = Mb({
                        ones: () => eu(s),
                        rate: this.dropout,
                        training: n,
                        count: 4,
                        dropoutFunc: this.dropoutFunc
                    }));
                    const i = this.dropoutMask,
                        o = (e, t, n) => t && t[n] ? Co(t[n], e) : e;
                    let u = o(s, i, 0),
                        l = o(s, i, 1),
                        c = o(s, i, 2),
                        h = o(s, i, 3);
                    0 < this.recurrentDropout && this.recurrentDropout < 1 && null == this.recurrentDropoutMask && (this.recurrentDropoutMask = Mb({
                        ones: () => eu(r),
                        rate: this.recurrentDropout,
                        training: n,
                        count: 4,
                        dropoutFunc: this.dropoutFunc
                    }));
                    const p = this.recurrentDropoutMask;
                    let d = o(r, p, 0),
                        f = o(r, p, 1),
                        m = o(r, p, 2),
                        g = o(r, p, 3);
                    const [y, b, x, w] = wu(this.kernel.read(), 4, 3), [k, v, I, N] = this.useBias ? wu(this.bias.read(), 4) : [null, null, null, null];
                    u = this.inputConv(u, y, k, this.padding), l = this.inputConv(l, b, v, this.padding), c = this.inputConv(c, x, I, this.padding), h = this.inputConv(h, w, N, this.padding);
                    const [S, T, $, C] = wu(this.recurrentKernel.read(), 4, 3);
                    d = this.recurrentConv(d, S), f = this.recurrentConv(f, T), m = this.recurrentConv(m, $), g = this.recurrentConv(g, C);
                    const E = this.recurrentActivation.apply(Si(u, d)),
                        A = this.recurrentActivation.apply(Si(l, f)),
                        R = Si(Co(A, a), Co(E, this.activation.apply(Si(c, m)))),
                        F = Co(this.recurrentActivation.apply(Si(h, g)), this.activation.apply(R));
                    return [F, F, R]
                }))
            }
            getConfig() {
                const e = super.getConfig(),
                    {
                        units: t
                    } = e,
                    n = Lb(e, ["units"]),
                    s = {
                        filters: this.filters,
                        kernelSize: this.kernelSize,
                        padding: this.padding,
                        dataFormat: this.dataFormat,
                        dilationRate: this.dilationRate,
                        strides: this.strides
                    };
                return Object.assign({}, n, s)
            }
            inputConv(e, t, n, s) {
                const r = no(e, t, this.strides, s || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
                return n ? lm(r, n, this.dataFormat) : r
            }
            recurrentConv(e, t) {
                return no(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC")
            }
        }
        Bb.className = "ConvLSTM2DCell", fi(Bb);
        class Pb extends zb {
            constructor(e) {
                const t = new Bb(e);
                super(Object.assign({}, e, {
                    cell: t
                }))
            }
            static fromConfig(e, t) {
                return new e(t)
            }
        }
        Pb.className = "ConvLSTM2D", fi(Pb);
        class Ub extends Km {
            constructor(e) {
                super(e), this.rate = Math.max(Math.min(e.rate, 1), 0), this.noiseShape = e.noiseShape, this.seed = e.seed, this.supportsMasking = !0
            }
            getNoiseShape(e) {
                if (null == this.noiseShape) return this.noiseShape;
                const t = e.shape,
                    n = [];
                for (let e = 0; e < this.noiseShape.length; ++e) n.push(null == this.noiseShape[e] ? t[e] : this.noiseShape[e]);
                return n
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e);
                    if (0 < this.rate && this.rate < 1) {
                        const e = null != t.training && t.training,
                            s = this.getNoiseShape(n);
                        return hm((() => cm(n, this.rate, s, this.seed)), (() => n), e)
                    }
                    return e
                }))
            }
            getConfig() {
                const e = {
                        rate: this.rate,
                        noiseShape: this.noiseShape,
                        seed: this.seed
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
            dispose() {
                return super.dispose()
            }
        }
        Ub.className = "Dropout", fi(Ub);
        class Wb extends Ub {
            constructor(e) {
                super(e), this.inputSpec = [{
                    ndim: 3
                }]
            }
            getNoiseShape(e) {
                const t = e.shape;
                return [t[0], 1, t[2]]
            }
        }
        Wb.className = "SpatialDropout1D", fi(Wb);
        class Vb extends Km {
            constructor(e) {
                if (super(e), this.activation = null, this.useBias = !0, this.kernel = null, this.bias = null, this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", this.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
                    let t = null;
                    null != e.batchSize && (t = e.batchSize), this.batchInputShape = [t, e.inputDim]
                }
                this.units = e.units, vf(this.units, "units"), this.activation = Hy(e.activation), null != e.useBias && (this.useBias = e.useBias), this.kernelInitializer = Dm(e.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER), this.biasInitializer = Dm(e.biasInitializer || this.DEFAULT_BIAS_INITIALIZER), this.kernelConstraint = dg(e.kernelConstraint), this.biasConstraint = dg(e.biasConstraint), this.kernelRegularizer = Zy(e.kernelRegularizer), this.biasRegularizer = Zy(e.biasRegularizer), this.activityRegularizer = Zy(e.activityRegularizer), this.supportsMasking = !0, this.inputSpec = [{
                    minNDim: 2
                }]
            }
            build(e) {
                const t = (e = Lm(e))[e.length - 1];
                null == this.kernel && (this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
                    minNDim: 2,
                    axes: {
                        [-1]: t
                    }
                }], this.built = !0
            }
            computeOutputShape(e) {
                const t = (e = Lm(e)).slice();
                return t[t.length - 1] = this.units, t
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e),
                        s = Nf(this.activation.getClassName());
                    let r;
                    return null != s ? r = am(n, this.kernel.read(), s, this.bias ? this.bias.read() : null) : (r = am(n, this.kernel.read()), null != this.bias && (r = lm(r, this.bias.read())), null != this.activation && (r = this.activation.apply(r))), r
                }))
            }
            getConfig() {
                const e = {
                        units: this.units,
                        activation: Vy(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: Fm(this.kernelInitializer),
                        biasInitializer: Fm(this.biasInitializer),
                        kernelRegularizer: Yy(this.kernelRegularizer),
                        biasRegularizer: Yy(this.biasRegularizer),
                        activityRegularizer: Yy(this.activityRegularizer),
                        kernelConstraint: hg(this.kernelConstraint),
                        biasConstraint: hg(this.biasConstraint)
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Vb.className = "Dense", fi(Vb);
        class Gb extends Km {
            constructor(e) {
                super(e = e || {}), this.inputSpec = [{
                    minNDim: 3
                }], this.dataFormat = e.dataFormat
            }
            computeOutputShape(e) {
                e = Lm(e);
                for (const t of e.slice(1))
                    if (null == t) throw new tf(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
                return [e[0], Gf(e, 1)]
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    let n = Mm(e);
                    if ("channelsFirst" === this.dataFormat && n.rank > 1) {
                        const e = [0];
                        for (let t = 2; t < n.rank; ++t) e.push(t);
                        e.push(1), n = _u(n, e)
                    }
                    return function(e) {
                        if (e.rank <= 1) throw new tf(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);
                        const t = [e.shape[0], Gf(e.shape, 1)];
                        return Vi(e, t)
                    }(n)
                }))
            }
            getConfig() {
                const e = {};
                null != this.dataFormat && (e.dataFormat = this.dataFormat);
                const t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Gb.className = "Flatten", fi(Gb);
        class Hb extends Km {
            constructor(e) {
                super(e), this.supportsMasking = !0, this.activation = Hy(e.activation)
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e);
                    return this.activation.apply(n)
                }))
            }
            getConfig() {
                const e = {
                        activation: Vy(this.activation)
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Hb.className = "Activation", fi(Hb);
        class jb extends Km {
            constructor(e) {
                super(e), this.n = e.n, this.inputSpec = [{
                    ndim: 2
                }]
            }
            computeOutputShape(e) {
                return [e[0], this.n, e[1]]
            }
            call(e, t) {
                return yi((() => {
                    return e = Mm(e), t = e, n = this.n, yi((() => {
                        if (2 !== t.shape.length) throw new tf(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);
                        return sm(Jf(t, 1), [1, n, 1])
                    }));
                    var t, n
                }))
            }
            getConfig() {
                const e = {
                        n: this.n
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        jb.className = "RepeatVector", fi(jb);
        class qb extends Km {
            constructor(e) {
                super(e), this.targetShape = e.targetShape;
                for (let e = 0; e < this.targetShape.length; ++e) this.isUnknown(this.targetShape[e]) && (this.targetShape[e] = null)
            }
            isUnknown(e) {
                return e < 0 || null == e
            }
            fixUnknownDimension(e, t) {
                const n = "Total size of new array must be unchanged.",
                    s = t.slice();
                let r = 1,
                    a = null;
                for (let e = 0; e < s.length; ++e) {
                    const t = s[e];
                    if (this.isUnknown(t)) {
                        if (null !== a) throw new tf("Can only specifiy one unknown dimension.");
                        a = e
                    } else r *= t
                }
                const i = Gf(e);
                if (null !== a) {
                    if (0 === r || i % r != 0) throw new tf(n);
                    s[a] = i / r
                } else if (i !== r) throw new tf(n);
                return s
            }
            computeOutputShape(e) {
                let t = !1;
                for (let n = 0; n < e.length; ++n)
                    if (this.isUnknown(e[n])) {
                        t = !0;
                        break
                    } return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape))
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e),
                        s = n.shape,
                        r = s.slice(0, 1).concat(this.fixUnknownDimension(s.slice(1), this.targetShape));
                    return Vi(n, r)
                }))
            }
            getConfig() {
                const e = {
                        targetShape: this.targetShape
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        qb.className = "Reshape", fi(qb);
        class Kb extends Km {
            constructor(e) {
                if (super(e), null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
                if (!Array.isArray(e.dims)) throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);
                const t = qf(1, e.dims.length + 1);
                if (!M(e.dims.slice().sort(), t)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
                this.dims = e.dims, this.dimsIncludingBatch = [0].concat(this.dims), this.inputSpec = [new Vm({
                    ndim: this.dims.length + 1
                })]
            }
            computeOutputShape(e) {
                const t = (e = Lm(e)).slice();
                return this.dims.forEach(((n, s) => {
                    t[s + 1] = e[n]
                })), t
            }
            call(e, t) {
                return _u(Mm(e), this.dimsIncludingBatch)
            }
            getConfig() {
                const e = {
                        dims: this.dims
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Kb.className = "Permute", fi(Kb);
        class Xb extends Km {
            constructor(e) {
                super(null == e ? {} : e), this.supportsMasking = !0, this.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        maskValue: this.maskValue
                    };
                return Object.assign(t, e), t
            }
            computeMask(e, t) {
                const n = Mm(e);
                return $i(Yo(n, this.maskValue), -1)
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e),
                        s = $i(Yo(n, this.maskValue), -1, !0);
                    return Co(n, Ra(s, n.dtype))
                }))
            }
        }
        Xb.className = "Masking", fi(Xb);
        class Yb extends Km {
            constructor(e) {
                if (super(e), this.embeddings = null, this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
                    let t = null;
                    null != e.batchSize && (t = e.batchSize), null == e.inputLength ? this.batchInputShape = [t, null] : this.batchInputShape = [t].concat(cf(e.inputLength))
                }
                this.inputDim = e.inputDim, vf(this.inputDim, "inputDim"), this.outputDim = e.outputDim, vf(this.outputDim, "outputDim"), this.embeddingsInitializer = Dm(e.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER), this.embeddingsRegularizer = Zy(e.embeddingsRegularizer), this.activityRegularizer = Zy(e.activityRegularizer), this.embeddingsConstraint = dg(e.embeddingsConstraint), this.maskZero = e.maskZero, this.supportsMasking = e.maskZero, this.inputLength = e.inputLength
            }
            build(e) {
                this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0
            }
            warnOnIncompatibleInputShape(e) {}
            computeMask(e, t) {
                return yi((() => this.maskZero ? (e = Mm(e), Yo(e, Ru(e))) : null))
            }
            computeOutputShape(e) {
                if (e = Lm(e), null == this.inputLength) return [...e, this.outputDim];
                const t = cf(this.inputLength);
                if (t.length !== e.length - 1) throw new tf(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
                {
                    let n = 0;
                    for (let s = 0; s < t.length; ++s) {
                        const r = t[s],
                            a = e[s + 1];
                        if (null != r && null != a && r !== a) throw new tf(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);
                        null == r && (t[n] = a), n++
                    }
                }
                return [e[0], ...t, this.outputDim]
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    let n = Mm(e);
                    "int32" !== n.dtype && (n = Yf(n, "int32"));
                    const s = im(this.embeddings.read(), Vi(n, [n.size]));
                    return Vi(s, Lm(this.computeOutputShape(n.shape)))
                }))
            }
            getConfig() {
                const e = {
                        inputDim: this.inputDim,
                        outputDim: this.outputDim,
                        embeddingsInitializer: Fm(this.embeddingsInitializer),
                        embeddingsRegularizer: Yy(this.embeddingsRegularizer),
                        activityRegularizer: Yy(this.activityRegularizer),
                        embeddingsConstraint: hg(this.embeddingsConstraint),
                        maskZero: this.maskZero,
                        inputLength: this.inputLength
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        Yb.className = "Embedding", fi(Yb);
        class Jb extends Km {
            constructor(e) {
                super(e || {}), this.supportsMasking = !0
            }
            mergeFunction(e) {
                throw new nf
            }
            computeElementwiseOpOutputShape(e, t) {
                if (null == e || null == t) return null;
                if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
                if (0 === t.length) return e;
                const n = e.slice(0, e.length - t.length);
                for (let s = 0; s < t.length; ++s) {
                    const r = e[e.length - t.length + s],
                        a = t[s];
                    if (null == r || null == a || r < 0 || a < 0) n.push(null);
                    else if (1 === r) n.push(a);
                    else if (1 === a) n.push(r);
                    else {
                        if (r !== a) throw new tf("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
                        n.push(r)
                    }
                }
                return n
            }
            build(e) {
                if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [Lm(e)]), e.length < 2) throw new tf(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);
                let t = [];
                for (const n of e) null != n && null !== n[0] && t.push(n[0]);
                if (t = bf(t), t.length > 1) throw new tf(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);
                let n = null == e[0] ? null : e[0].slice(1);
                for (let t = 1; t < e.length; ++t) {
                    const s = null == e[t] ? null : e[t].slice(1);
                    n = this.computeElementwiseOpOutputShape(n, s)
                }
                const s = e.map((e => e.length)); - 1 === e.indexOf(null) && 1 === bf(s).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0
            }
            call(e, t) {
                return yi((() => {
                    if (this.reshapeRequired) {
                        const t = [],
                            n = e.map((e => e.rank));
                        if (-1 === n.indexOf(null)) {
                            const s = jf(n);
                            for (let n of e) {
                                const e = n.rank;
                                for (let t = 0; t < s - e; ++t) n = Jf(n, 1);
                                t.push(n)
                            }
                            return this.mergeFunction(t)
                        } {
                            let n = !1;
                            for (const s of e) {
                                const e = s.rank;
                                if (null == e) {
                                    const e = s.shape,
                                        r = e[0],
                                        a = e.slice(1).concat([r]);
                                    let i = Vi(s, [r].concat(Gf(e.slice(1))));
                                    i = _u(i, [1, 0]), i = Vi(i, a), t.push(i), n = !0
                                } else if (e > 1) {
                                    const r = qf(1, e).concat([0]);
                                    t.push(_u(s, r)), n = !0
                                } else t.push(s)
                            }
                            let s = this.mergeFunction(t);
                            const r = s.rank;
                            if (n)
                                if (null == r) {
                                    const e = s.shape,
                                        t = e[e.length - 1],
                                        n = [t].concat(e.slice(0, e.length - 1));
                                    s = Vi(_u(Vi(s, [-1, t]), [1, 0]), n)
                                } else if (r > 1) {
                                const e = [r - 1].concat(qf(0, r - 1));
                                s = _u(s, e)
                            }
                            return s
                        }
                    }
                    return this.mergeFunction(e)
                }))
            }
            computeOutputShape(e) {
                let t;
                t = null == e[0] ? null : e[0].slice(1);
                for (let n = 1; n < e.length; ++n) {
                    const s = null == e[n] ? null : e[n].slice(1);
                    t = this.computeElementwiseOpOutputShape(t, s)
                }
                let n = [];
                for (const t of e) null != t && null !== t[0] && n.push(t[0]);
                return n = bf(n), t = 1 === n.length ? n.concat(t) : [null].concat(t), t
            }
            computeMask(e, t) {
                return yi((() => {
                    if (null == t) return null;
                    if (!Array.isArray(t)) throw new tf("`mask` should be an Array");
                    if (!Array.isArray(e)) throw new tf("`inputs` should be an Array");
                    if (t.length !== e.length) throw new tf(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);
                    if (t.every((e => null == e))) return null;
                    let n = (t = t.map((e => null == e ? e : go(e, 0))))[0];
                    for (let e = 1; e < t.length - 1; ++e) n = Fo(n, t[e]);
                    return n
                }))
            }
        }
        class Zb extends Jb {
            constructor(e) {
                super(e)
            }
            mergeFunction(e) {
                return yi((() => {
                    let t = e[0].clone();
                    for (let n = 1; n < e.length; ++n) t = Si(t, e[n]);
                    return t
                }))
            }
        }
        Zb.className = "Add", fi(Zb);
        class Qb extends Jb {
            constructor(e) {
                super(e)
            }
            mergeFunction(e) {
                return yi((() => {
                    let t = e[0].clone();
                    for (let n = 1; n < e.length; ++n) t = Co(t, e[n]);
                    return t
                }))
            }
        }
        Qb.className = "Multiply", fi(Qb);
        class ex extends Jb {
            constructor(e) {
                super(e)
            }
            mergeFunction(e) {
                return yi((() => {
                    let t = e[0].clone();
                    for (let n = 1; n < e.length; ++n) t = Si(t, e[n]);
                    return Co(1 / e.length, t)
                }))
            }
        }
        ex.className = "Average", fi(ex);
        class tx extends Jb {
            constructor(e) {
                super(e)
            }
            mergeFunction(e) {
                return yi((() => {
                    let t = e[0];
                    for (let n = 1; n < e.length; ++n) t = Mo(t, e[n]);
                    return t
                }))
            }
        }
        tx.className = "Maximum", fi(tx);
        class nx extends Jb {
            constructor(e) {
                super(e)
            }
            mergeFunction(e) {
                return yi((() => {
                    let t = e[0];
                    for (let n = 1; n < e.length; ++n) t = zo(t, e[n]);
                    return t
                }))
            }
        }
        nx.className = "Minimum", fi(nx);
        class sx extends Jb {
            constructor(e) {
                super(e), this.DEFAULT_AXIS = -1, null == e && (e = {}), this.axis = null == e.axis ? this.DEFAULT_AXIS : e.axis, this.supportsMasking = !0, this.reshapeRequired = !1
            }
            build(e) {
                if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new tf("A `Concatenate` layer should be called on a list of at least 2 inputs");
                let t = !0;
                for (const n of e)
                    if (null != n) {
                        t = !1;
                        break
                    } if (t) return;
                const n = [];
                for (let t = 0; t < e.length; ++t) {
                    const s = e[t].slice();
                    s.splice(this.axis, 1);
                    let r = !1;
                    for (const e of n)
                        if (M(e, s)) {
                            r = !0;
                            break
                        } r || n.push(s)
                }
                if (n.length > 1) throw new tf("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e))
            }
            mergeFunction(e) {
                return yi((() => tm(e, this.axis)))
            }
            computeOutputShape(e) {
                if (!Array.isArray(e) || !Array.isArray(e[0])) throw new tf("A `Concatenate` layer should be called on a list of inputs.");
                const t = e,
                    n = t[0].slice(),
                    s = this.axis < 0 ? n.length + this.axis : this.axis;
                for (const e of t.slice(1)) {
                    if (null == n[s] || null == e[s]) {
                        n[s] = null;
                        break
                    }
                    n[s] += e[s]
                }
                return n
            }
            computeMask(e, t) {
                if (null == t) return null;
                if (!Array.isArray(t)) throw new tf("`mask` should be an array for Concatenate");
                if (!Array.isArray(e)) throw new tf("`inputs` should be an array for Concatenate");
                if (t.length !== e.length) throw new tf(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);
                return yi((() => {
                    let n = !0;
                    if (t.forEach((e => {
                            null == e || (n = !1)
                        })), n) return null;
                    const s = [];
                    for (let n = 0; n < e.length; ++n) null == t[n] ? s.push(Ra(eu(e[n]), "bool")) : t[n].rank < e[n].rank ? s.push(go(t[n], -1)) : s.push(t[n]);
                    const r = Ji(s, this.axis);
                    return Ti(r, -1, !1)
                }))
            }
            getConfig() {
                const e = {
                        axis: this.axis
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }

        function rx(e, t) {
            for (; e < 0;) e += t;
            return e
        }
        sx.className = "Concatenate", fi(sx);
        class ax extends Jb {
            constructor(e) {
                super(e), this.axes = e.axes, this.normalize = null != e.normalize && e.normalize, this.supportsMasking = !0, this.reshapeRequired = !1
            }
            build(e) {
                R(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), (() => "A `Dot` layer should be called on a list of exactly 2 inputs."));
                const t = e[0],
                    n = e[1];
                if (t.length > 3 || n.length > 3) throw new nf("Dot layer does not support tensors of 4D or higher rank yet.");
                const s = this.interpretAxes(t, n);
                if (t[s[0]] !== n[s[1]]) throw new tf(`Dimension incompatibility: ${t[s[0]]} !== ${n[s[1]]}`)
            }
            mergeFunction(e) {
                if (2 !== e.length) throw new tf(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);
                let t, n = e[0],
                    s = e[1];
                return t = Array.isArray(this.axes) ? this.axes.map(((t, n) => rx(t, e[n].shape.length))) : [rx(this.axes, n.shape.length), rx(this.axes, s.shape.length)], this.normalize && (n = Tg(n, t[0]), s = Tg(s, t[1])),
                    function(e, t, n) {
                        if (e.shape.length > 3 || t.shape.length > 3) throw new nf("batchDot is not implemented for tensors of 4D or higher rank yet");
                        if (R(e.shape.length >= 2, (() => `batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)), R(e.shape.length >= 2, (() => `batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new nf("batchDot is not implemented for complex64-type Tensors yet.");
                        const s = e.shape.length,
                            r = t.shape.length;
                        null == n && (n = [s - 1, r - 2]);
                        const a = n;
                        return yi((() => {
                            let n, i;
                            if (s > r) {
                                n = s - r;
                                const e = [];
                                for (let t = 0; t < n; ++t) e.push(1);
                                t = Vi(t, t.shape.concat(e))
                            } else if (r > s) {
                                n = r - s;
                                const t = [];
                                for (let e = 0; e < n; ++e) t.push(1);
                                e = Vi(e, e.shape.concat(t))
                            } else n = 0;
                            if (2 === e.shape.length && 2 === t.shape.length) i = a[0] === a[1] ? Ao(Co(e, t), a[0]) : Ao(Co(_u(e, [1, 0]), t), a[1]);
                            else {
                                const n = a[0] !== e.shape.length - 1,
                                    s = a[1] === t.shape.length - 1;
                                i = Do(e, t, n, s)
                            }
                            if (n > 0) {
                                let e;
                                e = s > r ? s + r - 3 : s - 1;
                                const t = [];
                                for (let s = e; s < e + n; ++s) t.push(s);
                                i = vu(i, t)
                            }
                            return 1 === i.shape.length && (i = go(i, 1)), i
                        }))
                    }(n, s, t)
            }
            interpretAxes(e, t) {
                let n;
                return n = Array.isArray(this.axes) ? this.axes : [rx(this.axes, e.length), rx(this.axes, t.length)], n
            }
            computeOutputShape(e) {
                R(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), (() => "A `Dot` layer should be called on a list of exactly 2 inputs."));
                const t = e[0].slice(),
                    n = e[1].slice();
                if (t.length > 3 || n.length > 3) throw new nf("Dot layer does not support tensors of 4D or higher rank yet.");
                const s = this.interpretAxes(t, n);
                t.splice(s[0], 1), n.splice(s[1], 1), n.splice(0, 1);
                const r = t.concat(n);
                return 1 === r.length && r.push(1), r
            }
            computeMask(e, t) {
                return null
            }
            getConfig() {
                const e = {
                        axes: this.axes,
                        normalize: this.normalize
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        ax.className = "Dot", fi(ax);
        class ix extends Km {
            constructor(e) {
                super(e), this.supportsMasking = !0, this.stddev = e.stddev
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        stddev: this.stddev
                    };
                return Object.assign(t, e), t
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e);
                    return hm((() => Si(rm(n.shape, 0, this.stddev), n)), (() => n), t.training || !1)
                }))
            }
        }
        ix.className = "GaussianNoise", fi(ix);
        class ox extends Km {
            constructor(e) {
                super(e), this.supportsMasking = !0, this.rate = e.rate
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        rate: this.rate
                    };
                return Object.assign(t, e), t
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t);
                    const n = Mm(e);
                    if (this.rate > 0 && this.rate < 1) {
                        return hm((() => {
                            const e = Math.sqrt(this.rate / (1 - this.rate));
                            return Co(n, rm(n.shape, 1, e))
                        }), (() => n), t.training || !1)
                    }
                    return n
                }))
            }
        }
        ox.className = "GaussianDropout", fi(ox);
        class ux extends Km {
            constructor(e) {
                super(e), this.supportsMasking = !0, this.rate = e.rate, this.noiseShape = e.noiseShape
            }
            _getNoiseShape(e) {
                return this.noiseShape || Mm(e).shape
            }
            computeOutputShape(e) {
                return e
            }
            getConfig() {
                const e = super.getConfig(),
                    t = {
                        rate: this.rate
                    };
                return Object.assign(t, e), t
            }
            call(e, t) {
                return yi((() => {
                    if (this.rate < 1 && this.rate > 0) {
                        const n = this._getNoiseShape(e),
                            s = () => {
                                const t = Mm(e),
                                    s = -1.7580993408473766;
                                let r = Io(ou(n), this.rate);
                                r = Yf(r, "float32");
                                const a = ((1 - this.rate) * (1 + this.rate * s ** 2)) ** -.5,
                                    i = -a * s * this.rate,
                                    o = Si(Co(t, r), Co(Si(r, -1), s));
                                return Si(Co(o, a), i)
                            };
                        return hm(s, (() => Mm(e)), t.training || !1)
                    }
                    return e
                }))
            }
        }

        function lx(e, t, n, s, r, a = .001) {
            let i;
            if (2 === e.rank) i = qi(e, t, n, s, r, a);
            else if (3 === e.rank) i = Ki(e, t, n, s, r, a);
            else {
                if (4 !== e.rank) throw new nf(`batchNormalization is not implemented for array of rank ${e.rank} yet`);
                i = Xi(e, t, n, s, r, a)
            }
            return i
        }

        function cx(e, t, n, s, r = .001) {
            return M(s.slice().sort(), qf(0, e.rank - 1)) ? function(e, t, n, s, r = .001) {
                return yi((() => {
                    const a = Ko(e, s),
                        i = a.mean,
                        o = a.variance;
                    return [lx(e, i, o, n, t, r), i, o]
                }))
            }(e, t, n, s, r) : function(e, t, n, s, r = .001) {
                return yi((() => {
                    const a = Ko(e, s),
                        i = a.mean,
                        o = a.variance,
                        u = [];
                    for (const t of qf(0, e.rank)) - 1 !== s.indexOf(t) ? u.push(1) : u.push(e.shape[t]);
                    const l = Vi(i, u),
                        c = Vi(o, u),
                        h = null == t ? null : Vi(t, u),
                        p = null == n ? null : Vi(n, u);
                    return [lx(e, l, c, p, h, r), i, o]
                }))
            }(e, t, n, s, r)
        }
        ux.className = "AlphaDropout", fi(ux);
        class hx extends Km {
            constructor(e) {
                null == e && (e = {}), super(e), this.supportsMasking = !0, this.axis = null == e.axis ? -1 : e.axis, this.momentum = null == e.momentum ? .99 : e.momentum, this.epsilon = null == e.epsilon ? .001 : e.epsilon, this.center = null == e.center || e.center, this.scale = null == e.scale || e.scale, this.betaInitializer = Dm(e.betaInitializer || "zeros"), this.gammaInitializer = Dm(e.gammaInitializer || "ones"), this.movingMeanInitializer = Dm(e.movingMeanInitializer || "zeros"), this.movingVarianceInitializer = Dm(e.movingVarianceInitializer || "ones"), this.betaConstraint = dg(e.betaConstraint), this.gammaConstraint = dg(e.gammaConstraint), this.betaRegularizer = Zy(e.betaRegularizer), this.gammaRegularizer = Zy(e.gammaRegularizer)
            }
            build(e) {
                e = Lm(e);
                const t = this.axis >= 0 ? this.axis : this.axis + e.length,
                    n = e[t];
                if (null == n) throw new tf(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);
                this.inputSpec = [new Vm({
                    ndim: e.length,
                    axes: {
                        [t]: n
                    }
                })];
                const s = [n];
                this.scale && (this.gamma = this.addWeight("gamma", s, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", s, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", s, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", s, null, this.movingVarianceInitializer, null, !1), this.built = !0
            }
            call(e, t) {
                return yi((() => {
                    const n = null != t.training && t.training,
                        s = Mm(e),
                        r = s.shape,
                        a = r.length,
                        i = qf(0, a),
                        o = this.axis >= 0 ? this.axis : this.axis + a;
                    i.splice(o, 1);
                    const u = af(1, a);
                    u[o] = r[o];
                    const l = i.slice();
                    l.sort();
                    const c = !M(l, qf(0, a).slice(0, a - 1));
                    if (!n) return (() => {
                        if (c) {
                            const e = Vi(this.movingMean.read(), u),
                                t = Vi(this.movingVariance.read(), u),
                                n = this.center ? Vi(this.beta.read(), u) : null,
                                r = this.scale ? Vi(this.gamma.read(), u) : null;
                            return lx(s, e, t, n, r, this.epsilon)
                        }
                        return lx(s, this.movingMean.read(), this.movingVariance.read(), null == this.beta ? null : this.beta.read(), null == this.gamma ? null : this.gamma.read(), this.epsilon)
                    })();
                    const [h, p, d] = cx(s, this.gamma.read(), this.beta.read(), i, this.epsilon), f = (e, t, n) => {
                        yi((() => {
                            const s = 1 - n,
                                r = e.read(),
                                a = Co(Eo(r, t), s);
                            e.write(Eo(r, a))
                        }))
                    };
                    return (() => {
                        f(this.movingMean, p, this.momentum), f(this.movingVariance, d, this.momentum)
                    })(), h
                }))
            }
            getConfig() {
                const e = {
                        axis: this.axis,
                        momentum: this.momentum,
                        epsilon: this.epsilon,
                        center: this.center,
                        scale: this.scale,
                        betaInitializer: Fm(this.betaInitializer),
                        gammaInitializer: Fm(this.gammaInitializer),
                        movingMeanInitializer: Fm(this.movingMeanInitializer),
                        movingVarianceInitializer: Fm(this.movingVarianceInitializer),
                        betaRegularizer: Yy(this.betaRegularizer),
                        gammaRegularizer: Yy(this.gammaRegularizer),
                        betaConstraint: hg(this.betaConstraint),
                        gammaConstraint: hg(this.gammaConstraint)
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        hx.className = "BatchNormalization", fi(hx);
        class px extends Km {
            constructor(e) {
                if (null == e && (e = {}), super(e), this.axis = null == e.axis ? -1 : e.axis, "number" == typeof this.axis) {
                    if (!Number.isInteger(this.axis)) throw new Error(`Expected axis to be an integer, but received ${this.axis}`)
                } else {
                    if (!Array.isArray(this.axis)) throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
                    for (const e of this.axis)
                        if (!Number.isInteger(e)) throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)
                }
                this.epsilon = null == e.epsilon ? .001 : e.epsilon, this.center = null == e.center || e.center, this.scale = null == e.scale || e.scale, this.betaInitializer = Dm(e.betaInitializer || "zeros"), this.gammaInitializer = Dm(e.gammaInitializer || "ones"), this.betaRegularizer = Zy(e.betaRegularizer), this.gammaRegularizer = Zy(e.gammaRegularizer), this.supportsMasking = !0
            }
            build(e) {
                const t = (e = Lm(e)).length;
                "number" == typeof this.axis && (this.axis = [this.axis]);
                for (let e = 0; e < this.axis.length; ++e) this.axis[e] < 0 && (this.axis[e] += t);
                for (const e of this.axis)
                    if (e < 0 || e >= t) throw new Error(`Invalid axis: ${e}`);
                if (this.axis.length !== bf(this.axis).length) throw new Error(`Found duplicate axes in: ${this.axis}`);
                const n = this.axis.map((t => e[t])),
                    s = !0;
                this.scale ? this.gamma = this.addWeight("gamma", n, "float32", this.gammaInitializer, this.gammaRegularizer, s) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", n, "float32", this.betaInitializer, this.betaRegularizer, s) : this.beta = null, this.built = !0
            }
            call(e, t) {
                const n = Mm(e),
                    s = n.shape,
                    r = s.length;
                return yi((() => {
                    let {
                        mean: e,
                        variance: t
                    } = Ko(n, this.axis, !0);
                    const a = af(1, r);
                    for (const e of this.axis) a[e] = s[e];
                    const i = e => null != e && e.shape.length !== r ? Vi(e, a) : e;
                    let o = this.scale ? i(this.gamma.read()) : null,
                        u = this.center ? i(this.beta.read()) : null;
                    const l = [],
                        c = [];
                    for (let e = 0; e < r; ++e) - 1 !== this.axis.indexOf(e) ? (l.push(s[e]), c.push(1)) : (l.push(1), c.push(s[e]));
                    return e = yo(e, l), t = yo(t, l), null != o && (o = yo(o, c)), null != u && (u = yo(u, c)), lx(n, e, t, u, o, this.epsilon)
                }))
            }
            getConfig() {
                const e = {
                        axis: this.axis,
                        epsilon: this.epsilon,
                        center: this.center,
                        scale: this.scale,
                        betaInitializer: Fm(this.betaInitializer),
                        gammaInitializer: Fm(this.gammaInitializer),
                        betaRegularizer: Yy(this.betaRegularizer),
                        gammaRegularizer: Yy(this.gammaRegularizer)
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        px.className = "LayerNormalization", fi(px);
        class dx extends Km {
            constructor(e) {
                if (null == e && (e = {}), super(e), this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, null == e.padding) this.padding = [
                    [1, 1],
                    [1, 1]
                ];
                else if ("number" == typeof e.padding) this.padding = [
                    [e.padding, e.padding],
                    [e.padding, e.padding]
                ];
                else {
                    if (e.padding = e.padding, 2 !== e.padding.length) throw new tf(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);
                    let t, n;
                    if ("number" == typeof e.padding[0]) t = [e.padding[0], e.padding[0]], n = [e.padding[1], e.padding[1]];
                    else {
                        if (e.padding = e.padding, 2 !== e.padding[0].length) throw new tf(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);
                        if (t = e.padding[0], 2 !== e.padding[1].length) throw new tf(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);
                        n = e.padding[1]
                    }
                    this.padding = [t, n]
                }
                this.inputSpec = [new Vm({
                    ndim: 4
                })]
            }
            computeOutputShape(e) {
                let t, n;
                return e = Lm(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]])
            }
            call(e, t) {
                return yi((() => {
                    return t = Mm(e), n = this.padding, s = this.dataFormat, yi((() => {
                        if (4 !== t.rank) throw new tf(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);
                        if (null == n && (n = [
                                [1, 1],
                                [1, 1]
                            ]), 2 !== n.length || 2 !== n[0].length || 2 !== n[1].length) throw new tf("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
                        if (null == s && (s = "channelsLast"), "channelsLast" !== s && "channelsFirst" !== s) throw new tf(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
                        let e;
                        return e = "channelsFirst" === s ? [
                            [0, 0],
                            [0, 0], n[0], n[1]
                        ] : [
                            [0, 0], n[0], n[1],
                            [0, 0]
                        ], tu(t, e)
                    }));
                    var t, n, s
                }))
            }
            getConfig() {
                const e = {
                        padding: this.padding,
                        dataFormat: this.dataFormat
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }

        function fx(e, t, n, s, r, a) {
            return yi((() => {
                let i;
                Of(r), Lf(a), Mf(s), null == n && (n = [1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = ub(e, r);
                const o = "same" === s ? "same" : "valid";
                return i = "max" === a ? _o(e, t, n, o) : Gi(e, t, n, o), "channelsFirst" === r && (i = _u(i, [0, 3, 1, 2])), i
            }))
        }

        function mx(e, t, n, s, r, a) {
            return yi((() => {
                let i;
                Of(r), Lf(a), Mf(s), null == n && (n = [1, 1, 1]), null == s && (s = "valid"), null == r && (r = "channelsLast"), null == a && (a = "max"), e = lb(e, r);
                const o = "same" === s ? "same" : "valid";
                return i = "max" === a ? Oo(e, t, n, o) : Hi(e, t, n, o), "channelsFirst" === r && (i = _u(i, [0, 4, 1, 2, 3])), i
            }))
        }
        dx.className = "ZeroPadding2D", fi(dx);
        class gx extends Km {
            constructor(e) {
                if (null == e.poolSize && (e.poolSize = 2), super(e), "number" == typeof e.poolSize) this.poolSize = [e.poolSize];
                else {
                    if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new tf(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);
                    this.poolSize = e.poolSize
                }
                if (vf(this.poolSize, "poolSize"), null == e.strides) this.strides = this.poolSize;
                else if ("number" == typeof e.strides) this.strides = [e.strides];
                else {
                    if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new tf(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);
                    this.strides = e.strides
                }
                vf(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, Mf(this.padding), this.inputSpec = [new Vm({
                    ndim: 3
                })]
            }
            computeOutputShape(e) {
                const t = ib((e = Lm(e))[1], this.poolSize[0], this.padding, this.strides[0]);
                return [e[0], t, e[2]]
            }
            call(e, t) {
                return yi((() => {
                    this.invokeCallHook(e, t), e = Jf(Mm(e), 2);
                    const n = this.poolingFunction(Mm(e), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
                    return vu(n, [2])
                }))
            }
            getConfig() {
                const e = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        class yx extends gx {
            constructor(e) {
                super(e)
            }
            poolingFunction(e, t, n, s, r) {
                return Of(r), Mf(s), fx(e, t, n, s, r, "max")
            }
        }
        yx.className = "MaxPooling1D", fi(yx);
        class bx extends gx {
            constructor(e) {
                super(e)
            }
            poolingFunction(e, t, n, s, r) {
                return Of(r), Mf(s), fx(e, t, n, s, r, "avg")
            }
        }
        bx.className = "AveragePooling1D", fi(bx);
        class xx extends Km {
            constructor(e) {
                if (null == e.poolSize && (e.poolSize = [2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) this.strides = this.poolSize;
                else if (Array.isArray(e.strides)) {
                    if (2 !== e.strides.length) throw new tf(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);
                    this.strides = e.strides
                } else this.strides = [e.strides, e.strides];
                vf(this.poolSize, "poolSize"), vf(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, Of(this.dataFormat), Mf(this.padding), this.inputSpec = [new Vm({
                    ndim: 4
                })]
            }
            computeOutputShape(e) {
                e = Lm(e);
                let t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                    n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
                return t = ib(t, this.poolSize[0], this.padding, this.strides[0]), n = ib(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]]
            }
            call(e, t) {
                return yi((() => (this.invokeCallHook(e, t), this.poolingFunction(Mm(e), this.poolSize, this.strides, this.padding, this.dataFormat))))
            }
            getConfig() {
                const e = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides,
                        dataFormat: this.dataFormat
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        class wx extends xx {
            constructor(e) {
                super(e)
            }
            poolingFunction(e, t, n, s, r) {
                return Of(r), Mf(s), fx(e, t, n, s, r, "max")
            }
        }
        wx.className = "MaxPooling2D", fi(wx);
        class kx extends xx {
            constructor(e) {
                super(e)
            }
            poolingFunction(e, t, n, s, r) {
                return Of(r), Mf(s), fx(e, t, n, s, r, "avg")
            }
        }
        kx.className = "AveragePooling2D", fi(kx);
        class vx extends Km {
            constructor(e) {
                if (null == e.poolSize && (e.poolSize = [2, 2, 2]), super(e), this.poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) this.strides = this.poolSize;
                else if (Array.isArray(e.strides)) {
                    if (3 !== e.strides.length) throw new tf(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);
                    this.strides = e.strides
                } else this.strides = [e.strides, e.strides, e.strides];
                vf(this.poolSize, "poolSize"), vf(this.strides, "strides"), this.padding = null == e.padding ? "valid" : e.padding, this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, Of(this.dataFormat), Mf(this.padding), this.inputSpec = [new Vm({
                    ndim: 5
                })]
            }
            computeOutputShape(e) {
                e = Lm(e);
                let t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                    n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
                    s = "channelsFirst" === this.dataFormat ? e[4] : e[3];
                return t = ib(t, this.poolSize[0], this.padding, this.strides[0]), n = ib(n, this.poolSize[1], this.padding, this.strides[1]), s = ib(s, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, s] : [e[0], t, n, s, e[4]]
            }
            call(e, t) {
                return yi((() => (this.invokeCallHook(e, t), this.poolingFunction(Mm(e), this.poolSize, this.strides, this.padding, this.dataFormat))))
            }
            getConfig() {
                const e = {
                        poolSize: this.poolSize,
                        padding: this.padding,
                        strides: this.strides,
                        dataFormat: this.dataFormat
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        class Ix extends vx {
            constructor(e) {
                super(e)
            }
            poolingFunction(e, t, n, s, r) {
                return Of(r), Mf(s), mx(e, t, n, s, r, "max")
            }
        }
        Ix.className = "MaxPooling3D", fi(Ix);
        class Nx extends vx {
            constructor(e) {
                super(e)
            }
            poolingFunction(e, t, n, s, r) {
                return Of(r), Mf(s), mx(e, t, n, s, r, "avg")
            }
        }
        Nx.className = "AveragePooling3D", fi(Nx);
        class Sx extends Km {
            constructor(e) {
                super(e), this.inputSpec = [new Vm({
                    ndim: 3
                })]
            }
            computeOutputShape(e) {
                return [e[0], e[2]]
            }
            call(e, t) {
                throw new nf
            }
        }
        class Tx extends Sx {
            constructor(e) {
                super(e || {})
            }
            call(e, t) {
                return yi((() => {
                    const t = Mm(e);
                    return Lo(t, 1)
                }))
            }
        }
        Tx.className = "GlobalAveragePooling1D", fi(Tx);
        class $x extends Sx {
            constructor(e) {
                super(e || {})
            }
            call(e, t) {
                return yi((() => {
                    const t = Mm(e);
                    return $o(t, 1)
                }))
            }
        }
        $x.className = "GlobalMaxPooling1D", fi($x);
        class Cx extends Km {
            constructor(e) {
                super(e), this.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, Of(this.dataFormat), this.inputSpec = [new Vm({
                    ndim: 4
                })]
            }
            computeOutputShape(e) {
                return "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]]
            }
            call(e, t) {
                throw new nf
            }
            getConfig() {
                const e = {
                        dataFormat: this.dataFormat
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
        }
        class Ex extends Cx {
            call(e, t) {
                return yi((() => {
                    const t = Mm(e);
                    return "channelsLast" === this.dataFormat ? Lo(t, [1, 2]) : Lo(t, [2, 3])
                }))
            }
        }
        Ex.className = "GlobalAveragePooling2D", fi(Ex);
        class Ax extends Cx {
            call(e, t) {
                return yi((() => {
                    const t = Mm(e);
                    return "channelsLast" === this.dataFormat ? $o(t, [1, 2]) : $o(t, [2, 3])
                }))
            }
        }
        Ax.className = "GlobalMaxPooling2D", fi(Ax);
        class Rx extends Km {
            constructor(e) {
                super(e), this.layer = e.layer
            }
            build(e) {
                this.built = !0
            }
            get trainable() {
                return null != this.layer && this.layer.trainable
            }
            set trainable(e) {
                null != this.layer && (this.layer.trainable = e)
            }
            get trainableWeights() {
                return this.layer.trainableWeights
            }
            get nonTrainableWeights() {
                return this.layer.nonTrainableWeights
            }
            get updates() {
                return this.layer._updates
            }
            get losses() {
                return this.layer.losses
            }
            getWeights() {
                return this.layer.getWeights()
            }
            setWeights(e) {
                this.layer.setWeights(e)
            }
            getConfig() {
                const e = {
                        layer: {
                            className: this.layer.getClassName(),
                            config: this.layer.getConfig()
                        }
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
            setFastWeightInitDuringBuild(e) {
                super.setFastWeightInitDuringBuild(e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e)
            }
            static fromConfig(e, t, n = {}) {
                const s = Sg(t.layer, n);
                delete t.layer;
                const r = {
                    layer: s
                };
                return Object.assign(r, t), new e(r)
            }
        }
        class Fx extends Rx {
            constructor(e) {
                super(e), this.supportsMasking = !0
            }
            build(e) {
                if ((e = Lm(e)).length < 3) throw new tf(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);
                this.inputSpec = [{
                    shape: e
                }];
                const t = [e[0]].concat(e.slice(2));
                this.layer.built || (this.layer.build(t), this.layer.built = !0), super.build(e)
            }
            computeOutputShape(e) {
                const t = [(e = Lm(e))[0]].concat(e.slice(2)),
                    n = this.layer.computeOutputShape(t),
                    s = e[1];
                return [n[0], s].concat(n.slice(1))
            }
            call(e, t) {
                return yi((() => Tb(((e, n) => [Mm(this.layer.call(e, t)), []]), e = Mm(e), [], !1, null, null, !1, !0)[1]))
            }
        }
        Fx.className = "TimeDistributed", fi(Fx);
        class Dx extends Rx {
            constructor(e) {
                super(e);
                const t = e.layer.getConfig(),
                    n = {};
                n.className = e.layer.getClassName(), n.config = t, this.forwardLayer = Sg(n), t.goBackwards = !0 !== t.goBackwards;
                const s = {};
                var r;
                if (s.className = e.layer.getClassName(), s.config = t, this.backwardLayer = Sg(s), this.forwardLayer.name = "forward_" + this.forwardLayer.name, this.backwardLayer.name = "backward_" + this.backwardLayer.name, this.mergeMode = void 0 === e.mergeMode ? "concat" : e.mergeMode, r = this.mergeMode, wf(Df, "BidirectionalMergeMode", r), e.weights) throw new nf("weights support is not implemented for Bidirectional layer yet.");
                this._stateful = e.layer.stateful, this.returnSequences = e.layer.returnSequences, this.returnState = e.layer.returnState, this.supportsMasking = !0, this._trainable = !0, this.inputSpec = e.layer.inputSpec, this.numConstants = null
            }
            get trainable() {
                return this._trainable
            }
            set trainable(e) {
                this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e)
            }
            getWeights() {
                return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
            }
            setWeights(e) {
                const t = e.length,
                    n = Math.floor(t / 2);
                this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n))
            }
            computeOutputShape(e) {
                let t, n, s, r = this.forwardLayer.computeOutputShape(e);
                return Array.isArray(r) && Array.isArray(r[0]) || (r = [r]), this.returnState ? (s = r.slice(1), t = r[0]) : t = r[0], "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(s).concat(s.slice()) : [t].concat(s).concat(s.slice()) : lf(n)
            }
            apply(e, t) {
                let n = null == t ? null : t.initialState,
                    s = null == t ? null : t.constants;
                null == t && (t = {});
                const r = Sb(e, n, s, this.numConstants);
                if (e = r.inputs, n = r.initialState, s = r.constants, Array.isArray(e) && (n = e.slice(1), e = e[0]), (null == n || 0 === n.length) && null == s) return super.apply(e, t);
                const a = [],
                    i = [];
                if (null != n) {
                    const e = n.length;
                    if (e % 2 > 0) throw new tf("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
                    t.initialState = n, a.push(...n);
                    const s = n.map((e => new Vm({
                        shape: e.shape
                    })));
                    this.forwardLayer.stateSpec = s.slice(0, e / 2), this.backwardLayer.stateSpec = s.slice(e / 2), i.push(...s)
                }
                if (null != s) throw new nf("Support for constants in Bidirectional layers is not implemented yet.");
                const o = a[0] instanceof Gm;
                for (const e of a)
                    if (e instanceof Gm !== o) throw new tf("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
                if (o) {
                    const n = [e].concat(a),
                        s = this.inputSpec.concat(i),
                        r = this.inputSpec;
                    this.inputSpec = s;
                    const o = super.apply(n, t);
                    return this.inputSpec = r, o
                }
                return super.apply(e, t)
            }
            call(e, t) {
                return yi((() => {
                    const n = t.initialState;
                    let s, r, a, i;
                    if (null == n) s = this.forwardLayer.call(e, t), r = this.backwardLayer.call(e, t);
                    else {
                        const a = n.slice(0, n.length / 2),
                            i = n.slice(n.length / 2);
                        s = this.forwardLayer.call(e, Object.assign(t, {
                            initialState: a
                        })), r = this.backwardLayer.call(e, Object.assign(t, {
                            initialState: i
                        }))
                    }
                    return this.returnState && (Array.isArray(s) && (a = s.slice(1).concat(r.slice(1))), s = s[0], r = r[0]), this.returnSequences && (r = lu(r, 1)), "concat" === this.mergeMode ? i = tm([s, r]) : "sum" === this.mergeMode ? i = Si(s, r) : "ave" === this.mergeMode ? i = Co(.5, Si(s, r)) : "mul" === this.mergeMode ? i = Co(s, r) : null == this.mergeMode && (i = [s, r]), this.returnState ? null == this.mergeMode ? i.concat(a) : [i].concat(a) : i
                }))
            }
            resetStates(e) {
                this.forwardLayer.resetStates(), this.backwardLayer.resetStates()
            }
            build(e) {
                Bf(this.forwardLayer.name, (() => {
                    this.forwardLayer.build(e)
                })), Bf(this.backwardLayer.name, (() => {
                    this.backwardLayer.build(e)
                })), this.built = !0
            }
            computeMask(e, t) {
                let n;
                if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
                    const e = this.forwardLayer.states.map((e => null));
                    return Array.isArray(n) ? n.concat(e).concat(e) : [n].concat(e).concat(e)
                }
                return n
            }
            get trainableWeights() {
                return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
            }
            get nonTrainableWeights() {
                return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
            }
            setFastWeightInitDuringBuild(e) {
                super.setFastWeightInitDuringBuild(e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e)
            }
            getConfig() {
                const e = {
                        mergeMode: this.mergeMode
                    },
                    t = super.getConfig();
                return Object.assign(e, t), e
            }
            static fromConfig(e, t) {
                const n = Sg(t.layer);
                if (delete t.layer, null != t.numConstants) throw new nf("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
                const s = t;
                return s.layer = n, new e(s)
            }
        }
        Dx.className = "Bidirectional", fi(Dx);
        var _x, Ox;
        de().registerFlag("KEEP_INTERMEDIATE_TENSORS", (() => !1), (e => {
                e && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")
            })),
            function(e) {
                e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_QINT16 = 15] = "DT_QINT16", e[e.DT_QUINT16 = 16] = "DT_QUINT16", e[e.DT_UINT16 = 17] = "DT_UINT16", e[e.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e[e.DT_HALF = 19] = "DT_HALF", e[e.DT_RESOURCE = 20] = "DT_RESOURCE", e[e.DT_VARIANT = 21] = "DT_VARIANT", e[e.DT_UINT32 = 22] = "DT_UINT32", e[e.DT_UINT64 = 23] = "DT_UINT64", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", e[e.DT_QINT16_REF = 115] = "DT_QINT16_REF", e[e.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", e[e.DT_UINT16_REF = 117] = "DT_UINT16_REF", e[e.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", e[e.DT_HALF_REF = 119] = "DT_HALF_REF", e[e.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", e[e.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e[e.DT_UINT32_REF = 122] = "DT_UINT32_REF", e[e.DT_UINT64_REF = 123] = "DT_UINT64_REF"
            }(_x || (_x = {})),
            function(e) {
                let t;
                ! function(e) {
                    e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2"
                }(t = e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))
            }(Ox || (Ox = {}));
        const Mx = {};

        function Lx(e) {
            return Mx[e]
        }

        function zx(e, t, n, s, r) {
            const a = t.inputParams[e];
            if (a && void 0 !== a.inputIndexStart) {
                const e = a.inputIndexStart,
                    i = 0 === a.inputIndexEnd ? void 0 : void 0 === a.inputIndexEnd ? e + 1 : a.inputIndexEnd;
                if ("tensor" === a.type) return Bx(t.inputNames[a.inputIndexStart], n, s, r);
                if ("tensors" === a.type) {
                    return t.inputNames.slice(e, i).map((e => Bx(e, n, s, r)))
                }
                const o = Bx(t.inputNames.slice(e)[0], n, s, r),
                    u = o.dataSync();
                return "number" === a.type ? u[0] : ne(o.shape, u)
            }
            const i = t.attrParams[e];
            return i && i.value
        }

        function Bx(e, t, n, s) {
            const [r, a] = Wx(e);
            if (null != s) {
                const e = s.getHashTableHandleByName(r);
                if (null != e) return e
            }
            const i = n.currentContextIds.find((e => !!t[Ux(r, e)]));
            return void 0 !== i ? t[Ux(r, i)][a] : void 0
        }

        function Px(e, t) {
            const [n, s, r] = Wx(e);
            return [Ux(n, t && t.currentContextId), s, r]
        }

        function Ux(e, t) {
            return t ? `${e}-${t}` : e
        }

        function Wx(e) {
            const t = e.split(":");
            if (1 === t.length) return [e, 0, void 0];
            const n = t[0],
                s = 3 === t.length ? t[1] : void 0;
            return [n, Number(t[t.length - 1]), s]
        }

        function Vx(e, t, n) {
            let s = zx("pad", e, t, n);
            if ("explicit" === s) {
                s = zx("explicitPaddings", e, t, n);
                const r = [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ];
                for (let e = 0; e < 4; e++) r[e][0] = s[2 * e], r[e][1] = s[2 * e + 1];
                return r
            }
            return s
        }

        function Gx(e) {
            return e.kept ? e : Fa(e)
        }
        const Hx = [{
                tfOpName: "Add",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AddV2",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AddN",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }]
            }, {
                tfOpName: "BiasAdd",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sub",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "RealDiv",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Div",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "DivNoNan",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FloorDiv",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Mul",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Maximum",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Minimum",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Pow",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SquaredDifference",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Mod",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FloorMod",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }],
            jx = [{
                tfOpName: "Abs",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Acos",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Asin",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atan2",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Ceil",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ClipByValue",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "clipValueMin",
                    type: "number"
                }, {
                    start: 2,
                    name: "clipValueMax",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Complex",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "real",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "imag",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ComplexAbs",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cos",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cosh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Elu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Exp",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Floor",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Log",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Imag",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "outputType",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Neg",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Real",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "outputType",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Prelu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "alpha",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Relu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Relu6",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Selu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sigmoid",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sin",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sinh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sqrt",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Rsqrt",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Square",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tanh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sign",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Round",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Expm1",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Log1p",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Reciprocal",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Softplus",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Asinh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Acosh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atanh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Erf",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Prod",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axes",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool",
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LeakyRelu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "alpha",
                    name: "alpha",
                    type: "number",
                    defaultValue: .2
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IsNan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }],
            qx = [{
                tfOpName: "EmptyTensorList",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 1,
                    name: "maxNumElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LoopCond",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Switch",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Merge",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Enter",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "frame_name",
                    name: "frameName",
                    type: "string"
                }, {
                    tfName: "is_constant",
                    name: "isConstant",
                    type: "bool"
                }]
            }, {
                tfOpName: "Exit",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "NextIteration",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "size",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "dynamic_size",
                    name: "dynamicSize",
                    type: "bool"
                }, {
                    tfName: "clear_after_read",
                    name: "clearAfterRead",
                    type: "bool"
                }, {
                    tfName: "identical_element_shapes",
                    name: "identicalElementShapes",
                    type: "bool"
                }, {
                    tfName: "tensor_array_name",
                    name: "name",
                    type: "string"
                }]
            }, {
                tfOpName: "TensorArrayWriteV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayReadV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayGatherV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }]
            }, {
                tfOpName: "TensorArrayScatterV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorArrayConcatV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape_except0",
                    name: "elementShapeExcept0",
                    type: "shape",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArraySplitV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "lengths",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorArraySizeV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "flowIn",
                    type: "number"
                }]
            }, {
                tfOpName: "TensorArrayCloseV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }]
            }, {
                tfOpName: "StatelessIf",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "cond",
                    type: "tensor"
                }, {
                    start: 1,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "then_branch",
                    name: "thenBranch",
                    type: "func"
                }, {
                    tfName: "else_branch",
                    name: "elseBranch",
                    type: "func"
                }]
            }, {
                tfOpName: "If",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "cond",
                    type: "tensor"
                }, {
                    start: 1,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "then_branch",
                    name: "thenBranch",
                    type: "func"
                }, {
                    tfName: "else_branch",
                    name: "elseBranch",
                    type: "func"
                }]
            }, {
                tfOpName: "StatelessWhile",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "cond",
                    name: "cond",
                    type: "func"
                }, {
                    tfName: "body",
                    name: "body",
                    type: "func"
                }]
            }, {
                tfOpName: "While",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "cond",
                    name: "cond",
                    type: "func"
                }, {
                    tfName: "body",
                    name: "body",
                    type: "func"
                }]
            }, {
                tfOpName: "TensorListScatter",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListScatterV2",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 3,
                    name: "numElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListGather",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListGetItem",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListSetItem",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListReserve",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 1,
                    name: "numElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListFromTensor",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListStack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }, {
                    tfName: "num_elements",
                    name: "numElements",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListSplit",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 2,
                    name: "lengths",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListConcat",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListConcatV2",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListPopBack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListPushBack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListLength",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }]
            }, {
                tfOpName: "TensorListResize",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }]
            }],
            Kx = [{
                tfOpName: "AvgPool",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPool",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: [],
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPoolWithArgmax",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "include_batch_in_index",
                    name: "includeBatchInIndex",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AvgPool3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPool3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Conv1D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "stride",
                    name: "stride",
                    type: "number"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NWC"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "dilation",
                    name: "dilation",
                    type: "number",
                    defaultValue: 1
                }]
            }, {
                tfOpName: "Conv2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "useCudnnOnGpu",
                    name: "useCudnnOnGpu",
                    type: "bool"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "_FusedConv2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "use_cudnn_on_gpu",
                    name: "useCudnnOnGpu",
                    type: "bool",
                    defaultValue: !0
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    defaultValue: [1, 1, 1, 1]
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: 1e-4
                }, {
                    tfName: "leakyrelu_alpha",
                    name: "leakyreluAlpha",
                    type: "number"
                }]
            }, {
                tfOpName: "Conv2DBackpropInput",
                category: "convolution",
                inputs: [{
                    start: 2,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 0,
                    name: "outputShape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    notSupported: !0
                }]
            }, {
                tfOpName: "DepthwiseConv2d",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "DepthwiseConv2dNative",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "FusedDepthwiseConv2dNative",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    defaultValue: [1, 1, 1, 1]
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }]
            }, {
                tfOpName: "Conv3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Dilation2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "rates",
                    name: "dilations",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }]
            }],
            Xx = [{
                tfOpName: "Fill",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }, {
                    start: 1,
                    name: "value",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LinSpace",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "start",
                    type: "number"
                }, {
                    start: 1,
                    name: "stop",
                    type: "number"
                }, {
                    start: 2,
                    name: "num",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "OneHot",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "depth",
                    type: "number"
                }, {
                    start: 2,
                    name: "onValue",
                    type: "number",
                    defaultValue: 1
                }, {
                    start: 3,
                    name: "offValue",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Ones",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "OnesLike",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "RandomUniform",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "minval",
                    name: "minval",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "maxval",
                    name: "maxval",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Range",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "start",
                    type: "number"
                }, {
                    start: 1,
                    name: "stop",
                    type: "number"
                }, {
                    start: 2,
                    name: "step",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "Tidx",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TruncatedNormal",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "means",
                    name: "mean",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "stddev",
                    name: "stdDev",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number"
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Zeros",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ZerosLike",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Multinomial",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "logits",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numSamples",
                    type: "number"
                }],
                attrs: [{
                    tfName: "seed",
                    name: "seed",
                    type: "number"
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "output_dtype",
                    name: "output_dtype",
                    type: "dtype"
                }]
            }],
            Yx = [{
                tfOpName: "NonMaxSuppressionV2",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV3",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV4",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "T_threshold",
                    name: "threshold",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "pad_to_max_output_size",
                    name: "padToMaxOutputSize",
                    type: "bool"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV5",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }, {
                    start: 5,
                    name: "softNmsSigma",
                    type: "number"
                }]
            }, {
                tfOpName: "Where",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ListDiff",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }],
            Jx = [{
                tfOpName: "LowerBound",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "sortedSequence",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }]
            }, {
                tfOpName: "TopKV2",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "k",
                    type: "number"
                }],
                attrs: [{
                    tfName: "sorted",
                    name: "sorted",
                    type: "bool"
                }]
            }, {
                tfOpName: "UpperBound",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "sortedSequence",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Unique",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "UniqueV2",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }],
            Zx = [{
                tfOpName: "PlaceholderWithDefault",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "default",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "shape",
                    name: "shape",
                    type: "shape"
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Placeholder",
                category: "graph",
                attrs: [{
                    tfName: "shape",
                    name: "shape",
                    type: "shape"
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Const",
                category: "graph"
            }, {
                tfOpName: "Identity",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "IdentityN",
                category: "graph",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "x",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Snapshot",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Rank",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Size",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Shape",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "ShapeN",
                category: "graph",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "x",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Print",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "data",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "message",
                    name: "message",
                    type: "string"
                }, {
                    tfName: "first_n",
                    name: "firstN",
                    type: "number",
                    notSupported: !0
                }, {
                    tfName: "summarize",
                    name: "summarize",
                    type: "number",
                    defaultValue: 3
                }]
            }, {
                tfOpName: "NoOp",
                category: "graph",
                inputs: []
            }, {
                tfOpName: "StopGradient",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "FakeQuantWithMinMaxVars",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "min",
                    name: "min",
                    type: "number"
                }, {
                    tfName: "max",
                    name: "max",
                    type: "number"
                }]
            }],
            Qx = [{
                tfOpName: "HashTable",
                category: "hash_table",
                inputs: [],
                attrs: [{
                    tfName: "shared_name",
                    name: "sharedName",
                    type: "string"
                }, {
                    tfName: "use_node_name_sharing",
                    name: "useNodeNameSharing",
                    type: "bool"
                }, {
                    tfName: "key_dtype",
                    name: "keyDType",
                    type: "dtype"
                }, {
                    tfName: "value_dtype",
                    name: "valueDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "HashTableV2",
                category: "hash_table",
                inputs: [],
                attrs: [{
                    tfName: "shared_name",
                    name: "sharedName",
                    type: "string"
                }, {
                    tfName: "use_node_name_sharing",
                    name: "useNodeNameSharing",
                    type: "bool"
                }, {
                    tfName: "key_dtype",
                    name: "keyDType",
                    type: "dtype"
                }, {
                    tfName: "value_dtype",
                    name: "valueDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LookupTableImport",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableImportV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableFind",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableFindV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableSize",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }]
            }, {
                tfOpName: "LookupTableSizeV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }]
            }],
            ew = [{
                tfOpName: "ResizeBilinear",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "align_corners",
                    name: "alignCorners",
                    type: "bool"
                }, {
                    tfName: "half_pixel_centers",
                    name: "halfPixelCenters",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ResizeNearestNeighbor",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "align_corners",
                    name: "alignCorners",
                    type: "bool"
                }, {
                    tfName: "half_pixel_centers",
                    name: "halfPixelCenters",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "CropAndResize",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "image",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "boxInd",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "cropSize",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "method",
                    name: "method",
                    type: "string"
                }, {
                    tfName: "extrapolation_value",
                    name: "extrapolationValue",
                    type: "number"
                }]
            }, {
                tfOpName: "ImageProjectiveTransformV3",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "transforms",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "fillValue",
                    type: "number"
                }],
                attrs: [{
                    tfName: "interpolation",
                    name: "interpolation",
                    type: "string"
                }, {
                    tfName: "fill_mode",
                    name: "fillMode",
                    type: "string"
                }]
            }],
            tw = [{
                tfOpName: "Equal",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "NotEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Greater",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "GreaterEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Less",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LessEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalAnd",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalNot",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalOr",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Select",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SelectV2",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }],
            nw = [{
                tfOpName: "_FusedMatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: 1e-4
                }, {
                    tfName: "transpose_a",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "transpose_b",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "transpose_a",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "transpose_b",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BatchMatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "adj_x",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "adj_y",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BatchMatMulV2",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "adj_x",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "adj_y",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Transpose",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "perm",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Einsum",
                category: "matrices",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "equation",
                    name: "equation",
                    type: "string"
                }, {
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }],
            sw = [{
                tfOpName: "EuclideanNorm",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool",
                    defaultValue: !1
                }]
            }, {
                tfOpName: "FusedBatchNorm",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FusedBatchNormV2",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FusedBatchNormV3",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LRN",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "depth_radius",
                    name: "radius",
                    type: "number",
                    defaultValue: 5
                }, {
                    tfName: "bias",
                    name: "bias",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "alpha",
                    name: "alpha",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "beta",
                    name: "beta",
                    type: "number",
                    defaultValue: .5
                }]
            }, {
                tfOpName: "Softmax",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "LogSoftmax",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseToDense",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "sparseIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "sparseValues",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    defaultValue: !0,
                    notSupported: !0
                }]
            }],
            rw = [{
                tfOpName: "Bincount",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }, {
                    start: 2,
                    name: "weights",
                    type: "tensor"
                }]
            }, {
                tfOpName: "DenseBincount",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }, {
                    start: 2,
                    name: "weights",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "binary_output",
                    name: "binaryOutput",
                    type: "bool"
                }]
            }, {
                tfOpName: "Max",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Mean",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Min",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Sum",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "All",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Any",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "ArgMax",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "ArgMin",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "Prod",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Cumprod",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "exclusive",
                    name: "exclusive",
                    type: "bool"
                }, {
                    tfName: "reverse",
                    name: "reverse",
                    type: "bool"
                }]
            }, {
                tfOpName: "Cumsum",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "exclusive",
                    name: "exclusive",
                    type: "bool"
                }, {
                    tfName: "reverse",
                    name: "reverse",
                    type: "bool"
                }]
            }],
            aw = [{
                tfOpName: "ConcatV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    end: -1,
                    name: "tensors",
                    type: "tensors"
                }, {
                    start: -1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }]
            }, {
                tfOpName: "Concat",
                category: "slice_join",
                inputs: [{
                    start: 1,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }, {
                    start: 0,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }]
            }, {
                tfOpName: "GatherV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "batch_dims",
                    name: "batchDims",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Gather",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Reverse",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "dims",
                    type: "bool[]"
                }]
            }, {
                tfOpName: "ReverseV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Slice",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "begin",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "size",
                    type: "number[]"
                }]
            }, {
                tfOpName: "StridedSlice",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "begin",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "end",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "strides",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "begin_mask",
                    name: "beginMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "end_mask",
                    name: "endMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "new_axis_mask",
                    name: "newAxisMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "ellipsis_mask",
                    name: "ellipsisMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "shrink_axis_mask",
                    name: "shrinkAxisMask",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Pack",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Unpack",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "num",
                    name: "num",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tile",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "reps",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Split",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }, {
                    start: 1,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "num_split",
                    name: "numOrSizeSplits",
                    type: "number",
                    defaultValue: 1
                }]
            }, {
                tfOpName: "SplitV",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numOrSizeSplits",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "ScatterNd",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "GatherNd",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseToDense",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "sparseIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "sparseValues",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    defaultValue: !1,
                    notSupported: !0
                }]
            }],
            iw = [{
                tfOpName: "SparseFillEmptyRows",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "denseShape",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseReshape",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "inputIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "inputShape",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "newShape",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SparseSegmentMean",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "segmentIds",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseSegmentSum",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "segmentIds",
                    type: "tensor"
                }]
            }],
            ow = [{
                tfOpName: "FFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "IFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "RFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "fft_length",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IRFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "fft_length",
                    type: "number",
                    notSupported: !0
                }]
            }],
            uw = [{
                tfOpName: "StringNGrams",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "dataSplits",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "separator",
                    name: "separator",
                    type: "string"
                }, {
                    tfName: "ngram_widths",
                    name: "nGramWidths",
                    type: "number[]"
                }, {
                    tfName: "left_pad",
                    name: "leftPad",
                    type: "string"
                }, {
                    tfName: "right_pad",
                    name: "rightPad",
                    type: "string"
                }, {
                    tfName: "pad_width",
                    name: "padWidth",
                    type: "number"
                }, {
                    tfName: "preserve_short_sequences",
                    name: "preserveShortSequences",
                    type: "bool"
                }],
                outputs: ["ngrams", "ngrams_splits"]
            }, {
                tfOpName: "StringSplit",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "delimiter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "skip_empty",
                    name: "skipEmpty",
                    type: "bool"
                }],
                outputs: ["indices", "values", "shape"]
            }, {
                tfOpName: "StringToHashBucketFast",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "num_buckets",
                    name: "numBuckets",
                    type: "number"
                }]
            }],
            lw = [{
                tfOpName: "Cast",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "SrcT",
                    name: "sdtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "DstT",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ExpandDims",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "MirrorPad",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "mode",
                    name: "mode",
                    type: "string"
                }]
            }, {
                tfOpName: "Pad",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "constant_value",
                    name: "constantValue",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "PadV2",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "constantValue",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Reshape",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Squeeze",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "axis",
                    tfDeprecatedName: "squeeze_dims",
                    name: "axis",
                    type: "number[]"
                }]
            }, {
                tfOpName: "SpaceToBatchND",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "blockShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "paddings",
                    type: "number[]"
                }]
            }, {
                tfOpName: "BatchToSpaceND",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "blockShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "crops",
                    type: "number[]"
                }]
            }, {
                tfOpName: "DepthToSpace",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "block_size",
                    name: "blockSize",
                    type: "number"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string"
                }]
            }, {
                tfOpName: "BroadcastTo",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: []
            }, {
                tfOpName: "BroadcastArgs",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "s0",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "s1",
                    type: "tensor"
                }],
                attrs: []
            }];
        class cw {
            static get Instance() {
                return this._instance || (this._instance = new this)
            }
            constructor() {
                const e = [].concat(...[r, a, i, o, u, l, c, h, p, d, f, m, g, y, b, x, w, k, v].map((e => e.json)));
                this.opMappers = e.reduce(((e, t) => (e[t.tfOpName] = t, e)), {})
            }
            transformGraph(e, t = {}) {
                const n = e.node,
                    s = [],
                    r = [],
                    a = [],
                    i = n.reduce(((e, t) => (e[t.name] = this.mapNode(t), t.op.startsWith("Placeholder") ? s.push(e[t.name]) : "Const" === t.op ? r.push(e[t.name]) : null != t.input && 0 !== t.input.length || a.push(e[t.name]), e)), {});
                let o = [];
                const u = [];
                let l = {},
                    c = {};
                null != t && (l = this.mapSignatureEntries(t.inputs), c = this.mapSignatureEntries(t.outputs));
                const h = Object.keys(i);
                h.forEach((e => {
                    const t = i[e];
                    t.inputNames.forEach(((e, n) => {
                        const [s, , r] = Px(e), a = i[s];
                        if (null != a.outputs) {
                            const e = a.outputs.indexOf(r);
                            if (-1 !== e) {
                                const r = `${s}:${e}`;
                                t.inputNames[n] = r
                            }
                        }
                        t.inputs.push(a), a.children.push(t)
                    }))
                })), 0 === Object.keys(c).length ? h.forEach((e => {
                    const t = i[e];
                    0 === t.children.length && u.push(t)
                })) : Object.keys(c).forEach((e => {
                    const [t] = Px(e), n = i[t];
                    null != n && (n.signatureKey = c[e], u.push(n))
                })), Object.keys(l).length > 0 ? Object.keys(l).forEach((e => {
                    const [t] = Px(e), n = i[t];
                    n && (n.signatureKey = l[e], o.push(n))
                })) : o = s;
                let p = {};
                null != e.library && null != e.library.function && (p = e.library.function.reduce(((e, t) => (e[t.signature.name] = this.mapFunction(t), e)), {}));
                const d = {
                    nodes: i,
                    inputs: o,
                    outputs: u,
                    weights: r,
                    placeholders: s,
                    signature: t,
                    functions: p
                };
                return a.length > 0 && (d.initNodes = a), d
            }
            mapSignatureEntries(e) {
                return Object.keys(e || {}).reduce(((t, n) => (t[e[n].name] = n, t)), {})
            }
            mapNode(e) {
                const t = Lx(e.op) || this.opMappers[e.op] || {};
                null == e.attr && (e.attr = {});
                const n = {
                    name: e.name,
                    op: e.op,
                    category: t.category,
                    inputNames: (e.input || []).map((e => e.startsWith("^") ? e.slice(1) : e)),
                    inputs: [],
                    children: [],
                    inputParams: {},
                    attrParams: {},
                    rawAttrs: e.attr,
                    outputs: t.outputs
                };
                return null != t.inputs && (n.inputParams = t.inputs.reduce(((e, t) => (e[t.name] = {
                    type: t.type,
                    inputIndexStart: t.start,
                    inputIndexEnd: t.end
                }, e)), {})), null != t.attrs && (n.attrParams = t.attrs.reduce(((t, n) => {
                    const s = n.type;
                    let r;
                    switch (n.type) {
                        case "string":
                            r = pw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = pw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "string[]":
                            r = vw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = vw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "number":
                            r = fw(e.attr, n.tfName, n.defaultValue || 0), void 0 === r && n.tfDeprecatedName && (r = fw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "number[]":
                            r = kw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = kw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "bool":
                            r = dw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = dw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "bool[]":
                            r = Nw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = Nw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "shape":
                            r = ww(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = ww(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "shape[]":
                            r = Iw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = Iw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "dtype":
                            r = yw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = yw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "dtype[]":
                            r = bw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = bw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "func":
                            r = gw(e.attr, n.tfName, n.defaultValue), void 0 === r && n.tfDeprecatedName && (r = gw(e.attr, n.tfDeprecatedName, n.defaultValue));
                            break;
                        case "tensor":
                        case "tensors":
                            break;
                        default:
                            throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)
                    }
                    return t[n.name] = {
                        value: r,
                        type: s
                    }, t
                }), {})), n
            }
            mapFunction(e) {
                const t = e.nodeDef,
                    n = [];
                let s = {};
                null != t && (s = t.reduce(((e, t) => (e[t.name] = this.mapNode(t), "Const" === t.op && n.push(e[t.name]), e)), {}));
                const r = [],
                    a = [];
                e.signature.inputArg.forEach((e => {
                    const [t] = Px(e.name), n = {
                        name: t,
                        op: "Placeholder",
                        inputs: [],
                        inputNames: [],
                        category: "graph",
                        inputParams: {},
                        attrParams: {
                            dtype: {
                                value: mw(e.type),
                                type: "dtype"
                            }
                        },
                        children: []
                    };
                    n.signatureKey = e.name, r.push(n), s[t] = n
                }));
                Object.keys(s).forEach((e => {
                    const t = s[e];
                    t.inputNames.forEach(((e, n) => {
                        const [r, , a] = Px(e), i = s[r];
                        if (null != i.outputs) {
                            const e = i.outputs.indexOf(a);
                            if (-1 !== e) {
                                const s = `${r}:${e}`;
                                t.inputNames[n] = s
                            }
                        }
                        t.inputs.push(i), i.children.push(t)
                    }))
                }));
                const i = e.ret;
                e.signature.outputArg.forEach((e => {
                    const [t, n] = Px(i[e.name]), r = s[t];
                    null != r && (r.defaultOutput = n, a.push(r))
                }));
                const o = this.mapArgsToSignature(e);
                return {
                    nodes: s,
                    inputs: r,
                    outputs: a,
                    weights: n,
                    placeholders: [],
                    signature: o
                }
            }
            mapArgsToSignature(e) {
                return {
                    methodName: e.signature.name,
                    inputs: e.signature.inputArg.reduce(((e, t) => (e[t.name] = this.mapArgToTensorInfo(t), e)), {}),
                    outputs: e.signature.outputArg.reduce(((t, n) => (t[n.name] = this.mapArgToTensorInfo(n, e.ret), t)), {})
                }
            }
            mapArgToTensorInfo(e, t) {
                let n = e.name;
                return null != t && (n = t[n]), {
                    name: n,
                    dtype: e.type
                }
            }
        }

        function hw(e, t) {
            const n = Array.isArray(e) ? String.fromCharCode.apply(null, e) : function(e) {
                const t = de().global;
                if (void 0 !== t.atob) return t.atob(e);
                if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
                throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")
            }(e);
            return t ? n : n.toLowerCase()
        }

        function pw(e, t, n, s = !1) {
            const r = e[t];
            return null != r ? hw(r.s, s) : n
        }

        function dw(e, t, n) {
            const s = e[t];
            return s ? s.b : n
        }

        function fw(e, t, n) {
            const s = e[t] || {},
                r = null != s.i ? s.i : null != s.f ? s.f : n;
            return "number" == typeof r ? r : parseInt(r, 10)
        }

        function mw(e) {
            switch ("string" == typeof e && (e = _x[e]), e) {
                case _x.DT_FLOAT:
                case _x.DT_HALF:
                    return "float32";
                case _x.DT_INT32:
                case _x.DT_INT64:
                case _x.DT_INT8:
                case _x.DT_UINT8:
                    return "int32";
                case _x.DT_BOOL:
                    return "bool";
                case _x.DT_DOUBLE:
                    return "float32";
                case _x.DT_STRING:
                    return "string";
                default:
                    return null
            }
        }

        function gw(e, t, n) {
            const s = e[t];
            return s && s.func ? s.func.name : n
        }

        function yw(e, t, n) {
            const s = e[t];
            return s && s.type ? mw(s.type) : n
        }

        function bw(e, t, n) {
            const s = e[t];
            return s && s.list && s.list.type ? s.list.type.map((e => mw(e))) : n
        }

        function xw(e) {
            if (!e.unknownRank) return null != e.dim ? e.dim.map((e => "number" == typeof e.size ? e.size : parseInt(e.size, 10))) : []
        }

        function ww(e, t, n) {
            const s = e[t];
            return s && s.shape ? xw(s.shape) : n
        }

        function kw(e, t, n) {
            const s = e[t];
            return s ? ((s.list.f && s.list.f.length ? s.list.f : s.list.i) || []).map((e => "number" == typeof e ? e : parseInt(e, 10))) : n
        }

        function vw(e, t, n, s = !1) {
            const r = e[t];
            return r && r.list && r.list.s ? r.list.s.map((e => hw(e, s))) : n
        }

        function Iw(e, t, n) {
            const s = e[t];
            return s && s.list && s.list.shape ? s.list.shape.map((e => xw(e))) : n
        }

        function Nw(e, t, n) {
            const s = e[t];
            return s && s.list && s.list.b ? s.list.b : n
        }
        class Sw {
            constructor(e, t, n) {
                this.node = e, this.tensorMap = t, this.context = n, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map((e => this.getInput(e))), null != e.rawAttrs && (this.attrs = Object.keys(e.rawAttrs).reduce(((e, t) => (e[t] = this.getAttr(t), e)), {}))
            }
            getInput(e) {
                return Bx(e, this.tensorMap, this.context)
            }
            getAttr(e, t) {
                const n = this.node.rawAttrs[e];
                if (null != n.tensor) return Bx(e, this.tensorMap, this.context);
                if (null != n.i || null != n.f) return fw(this.node.rawAttrs, e, t);
                if (null != n.s) return pw(this.node.rawAttrs, e, t);
                if (null != n.b) return dw(this.node.rawAttrs, e, t);
                if (null != n.shape) return ww(this.node.rawAttrs, e, t);
                if (null != n.type) return yw(this.node.rawAttrs, e, t);
                if (null != n.list) {
                    if (null != n.list.i || null != n.list.f) return kw(this.node.rawAttrs, e, t);
                    if (null != n.list.s) return vw(this.node.rawAttrs, e, t);
                    if (null != n.list.shape) return Iw(this.node.rawAttrs, e, t);
                    if (null != n.list.b) return Nw(this.node.rawAttrs, e, t);
                    if (null != n.list.type) return bw(this.node.rawAttrs, e, t)
                }
                return t
            }
        }
        const Tw = Pr({
            addN_: function(e) {
                R(Array.isArray(e), (() => "The argument passed to tf.addN() must be a list of tensors")), R(e.length >= 1, (() => `Must pass at least one tensor to tf.addN(), but got ${e.length}`));
                const t = e.map(((e, t) => zr(e, `tensors${t}`, "addN"))),
                    n = t[0];
                t.forEach((e => {
                    if (e.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
                })), t.forEach((e => {
                    if (!M(e.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
                }));
                const s = t;
                return Er.runKernel(ve, s)
            }
        });

        function $w(e, t, n = "") {
            if ("number" != typeof e && "number" != typeof t) {
                R(e.length === t.length, (() => n + ` Shapes ${e} and ${t} must match`));
                for (let s = 0; s < e.length; s++) {
                    const r = e[s],
                        a = t[s];
                    R(r < 0 || a < 0 || r === a, (() => n + ` Shapes ${e} and ${t} must match`))
                }
            }
        }

        function Cw(e) {
            return "number" != typeof e && !e.some((e => e < 0))
        }

        function Ew(e, t, n) {
            let s = Aw(e, n);
            const r = !Cw(s);
            if (r && 0 === t.length) throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);
            if (r && t.forEach((e => {
                    s = Aw(e.shape, s)
                })), !Cw(s)) throw new Error(`Non-fully-defined elementShape: ${s}`);
            return s
        }

        function Aw(e, t) {
            if ("number" == typeof e) return t;
            if ("number" == typeof t) return e;
            if (e.length !== t.length) throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);
            const n = [];
            for (let s = 0; s < e.length; ++s) {
                const r = e[s],
                    a = t[s];
                if (r >= 0 && a >= 0 && r !== a) throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);
                n[s] = r >= 0 ? r : a
            }
            return n
        }
        class Rw {
            constructor(e, t, n, s, r, a, i) {
                this.name = e, this.dtype = t, this.maxSize = n, this.elementShape = s, this.identicalElementShapes = r, this.dynamicSize = a, this.clearAfterRead = i, this.tensors = [], this.closed_ = !1, this.idTensor = vi(0), xi(this.idTensor)
            }
            get id() {
                return this.idTensor.id
            }
            get closed() {
                return this.closed_
            }
            clearAndClose(e) {
                this.tensors.forEach((t => {
                    null != e && e.has(t.tensor.id) || t.tensor.dispose()
                })), this.tensors = [], this.closed_ = !0, this.idTensor.dispose()
            }
            size() {
                return this.tensors.length
            }
            read(e) {
                if (this.closed_) throw new Error(`TensorArray ${this.name} has already been closed.`);
                if (e < 0 || e >= this.size()) throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
                const t = this.tensors[e];
                if (t.cleared) throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
                return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor
            }
            readMany(e) {
                return e.map((e => this.read(e)))
            }
            write(e, t) {
                if (this.closed_) throw new Error(`TensorArray ${this.name} has already been closed.`);
                if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
                const n = this.tensors[e] || {};
                if (t.dtype !== this.dtype) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);
                if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), $w(this.elementShape, t.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`), n.read) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
                if (n.written) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
                n.tensor = t, xi(t), n.written = !0, this.tensors[e] = n
            }
            writeMany(e, t) {
                if (e.length !== t.length) throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);
                e.forEach(((e, n) => this.write(e, t[n])))
            }
            gather(e, t) {
                if (t && t !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);
                if (e) e = e.slice(0, this.size());
                else {
                    e = [];
                    for (let t = 0; t < this.size(); t++) e.push(t)
                }
                if (0 === e.length) return Vr([], [0].concat(this.elementShape));
                const n = this.readMany(e);
                return $w(this.elementShape, n[0].shape, "TensorArray shape mismatch: "), Iu(n, 0)
            }
            concat(e) {
                if (e && e !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
                if (0 === this.size()) return Vr([], [0].concat(this.elementShape));
                const t = [];
                for (let e = 0; e < this.size(); e++) t.push(e);
                const n = this.readMany(t);
                return $w(this.elementShape, n[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`), Ji(n, 0)
            }
            scatter(e, t) {
                if (t.dtype !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
                if (e.length !== t.shape[0]) throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
                const n = Math.max(...e);
                if (!this.dynamicSize && n >= this.maxSize) throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);
                this.writeMany(e, Cu(t, 0))
            }
            split(e, t) {
                if (t.dtype !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
                let n = 0;
                const s = e.map((e => (n += e, n)));
                if (n !== t.shape[0]) throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);
                if (!this.dynamicSize && e.length !== this.maxSize) throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
                const r = 0 === n ? 0 : t.size / n,
                    a = [];
                yi((() => {
                    t = Vi(t, [1, n, r]);
                    for (let n = 0; n < e.length; ++n) {
                        const i = [0, 0 === n ? 0 : s[n - 1], 0],
                            o = [1, e[n], r];
                        a[n] = Vi(du(t, i, o), this.elementShape)
                    }
                    return a
                }));
                const i = [];
                for (let t = 0; t < e.length; t++) i[t] = t;
                this.writeMany(i, a)
            }
        }
        class Fw {
            constructor(e, t, n, s = -1) {
                this.tensors = e, this.elementShape = t, this.elementDtype = n, null != e && e.forEach((e => {
                    if (n !== e.dtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);
                    $w(t, e.shape, "TensorList shape mismatch: "), xi(e)
                })), this.idTensor = vi(0), this.maxNumElements = s, xi(this.idTensor)
            }
            get id() {
                return this.idTensor.id
            }
            copy() {
                return new Fw([...this.tensors], this.elementShape, this.elementDtype)
            }
            clearAndClose(e) {
                this.tensors.forEach((t => {
                    null != e && e.has(t.id) || t.dispose()
                })), this.tensors.length = 0, this.idTensor.dispose()
            }
            size() {
                return this.tensors.length
            }
            stack(e, t, n = -1) {
                if (t !== this.elementDtype) throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
                if (-1 !== n && this.tensors.length !== n) throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);
                $w(e, this.elementShape, "TensorList shape mismatch: ");
                const s = Ew(this.elementShape, this.tensors, e);
                return yi((() => {
                    const e = this.tensors.map((e => Vi(e, s)));
                    return Iu(e, 0)
                }))
            }
            popBack(e, t) {
                if (t !== this.elementDtype) throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
                if (0 === this.size()) throw new Error("Trying to pop from an empty list.");
                const n = Ew(this.elementShape, this.tensors, e),
                    s = this.tensors.pop();
                return $w(s.shape, e, "TensorList shape mismatch: "), Vi(s, n)
            }
            pushBack(e) {
                if (e.dtype !== this.elementDtype) throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);
                if ($w(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw new Error("Trying to push element into a full list.");
                xi(e), this.tensors.push(e)
            }
            resize(e) {
                if (e < 0) throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);
                if (-1 !== this.maxNumElements && e > this.maxNumElements) throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);
                const t = new Fw([], this.elementShape, this.elementDtype, this.maxNumElements);
                t.tensors.length = e;
                for (let n = 0; n < Math.min(this.tensors.length, e); ++n) t.tensors[n] = this.tensors[n];
                return t
            }
            getItem(e, t, n) {
                if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
                if (e < 0 || e > this.tensors.length) throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);
                if (null == this.tensors[e]) throw new Error(`element at index ${e} is null.`);
                $w(this.tensors[e].shape, t, "TensorList shape mismatch: ");
                const s = Ew(this.elementShape, this.tensors, t);
                return Vi(this.tensors[e], s)
            }
            setItem(e, t) {
                if (t.dtype !== this.elementDtype) throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);
                if (e < 0 || -1 !== this.maxNumElements && e >= this.maxNumElements) throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);
                $w(this.elementShape, t.shape, "TensorList shape mismatch: "), xi(t), this.tensors[e] = t
            }
            gather(e, t, n) {
                if (t !== this.elementDtype) throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);
                $w(this.elementShape, n, "TensorList shape mismatch: "), e = e.slice(0, this.size());
                const s = Ew(this.elementShape, this.tensors, n);
                return 0 === e.length ? Vr([], [0].concat(s)) : yi((() => {
                    const t = e.map((e => Vi(this.tensors[e], s)));
                    return Iu(t, 0)
                }))
            }
            concat(e, t) {
                if (e && e !== this.elementDtype) throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);
                $w(this.elementShape, t, "TensorList shape mismatch: ");
                const n = Ew(this.elementShape, this.tensors, t);
                return 0 === this.size() ? Vr([], [0].concat(n)) : yi((() => {
                    const e = this.tensors.map((e => Vi(e, n)));
                    return Ji(e, 0)
                }))
            }
        }
        const Dw = async (e, t, n) => {
            switch (e.op) {
                case "If":
                case "StatelessIf": {
                    const s = zx("thenBranch", e, t, n),
                        r = zx("elseBranch", e, t, n),
                        a = zx("cond", e, t, n),
                        i = zx("args", e, t, n);
                    return (await a.data())[0] ? n.functionMap[s].executeFunctionAsync(i, n.tensorArrayMap, n.tensorListMap) : n.functionMap[r].executeFunctionAsync(i, n.tensorArrayMap, n.tensorListMap)
                }
                case "While":
                case "StatelessWhile": {
                    const s = zx("body", e, t, n),
                        r = zx("cond", e, t, n),
                        a = zx("args", e, t, n),
                        i = await n.functionMap[r].executeFunctionAsync(a, n.tensorArrayMap, n.tensorListMap),
                        o = a.map((e => e.id));
                    let u = await i[0].data();
                    i.forEach((e => {
                        e.kept || -1 !== o.indexOf(e.id) || e.dispose()
                    }));
                    let l = a;
                    for (; u[0];) {
                        const e = l;
                        l = await n.functionMap[s].executeFunctionAsync(l, n.tensorArrayMap, n.tensorListMap);
                        const t = l.map((e => e.id));
                        e.forEach((e => {
                            e.kept || -1 !== o.indexOf(e.id) || -1 !== t.indexOf(e.id) || e.dispose()
                        }));
                        const a = await n.functionMap[r].executeFunctionAsync(l, n.tensorArrayMap, n.tensorListMap);
                        u = await a[0].data(), a.forEach((e => {
                            e.kept || -1 !== o.indexOf(e.id) || -1 !== t.indexOf(e.id) || e.dispose()
                        }))
                    }
                    return l
                }
                case "LoopCond":
                    return [Gx(zx("pred", e, t, n))];
                case "Switch": {
                    const s = zx("pred", e, t, n);
                    let r = zx("data", e, t, n);
                    return r.kept || (r = Gx(r)), (await s.data())[0] ? [void 0, r] : [r, void 0]
                }
                case "Merge": {
                    const s = e.inputNames.find((e => void 0 !== Bx(e, t, n)));
                    if (s) {
                        return [Gx(Bx(s, t, n))]
                    }
                    return
                }
                case "Enter": {
                    const s = zx("frameName", e, t, n),
                        r = zx("tensor", e, t, n);
                    return n.enterFrame(s), [Gx(r)]
                }
                case "Exit": {
                    const s = zx("tensor", e, t, n);
                    return n.exitFrame(), [Gx(s)]
                }
                case "NextIteration": {
                    const s = zx("tensor", e, t, n);
                    return n.nextIteration(), [Gx(s)]
                }
                case "TensorArrayV3": {
                    const s = zx("size", e, t, n),
                        r = zx("dtype", e, t, n),
                        a = zx("elementShape", e, t, n),
                        i = zx("dynamicSize", e, t, n),
                        o = zx("clearAfterRead", e, t, n),
                        u = zx("identicalElementShapes", e, t, n),
                        l = zx("name", e, t, n),
                        c = new Rw(l, r, s, a, u, i, o);
                    return n.addTensorArray(c), [c.idTensor, vi(1)]
                }
                case "TensorArrayWriteV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = zx("index", e, t, n),
                        a = zx("tensor", e, t, n),
                        i = n.getTensorArray(s.id);
                    return i.write(r, a), [i.idTensor]
                }
                case "TensorArrayReadV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = zx("index", e, t, n);
                    return [n.getTensorArray(s.id).read(r)]
                }
                case "TensorArrayGatherV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = zx("indices", e, t, n),
                        a = zx("dtype", e, t, n);
                    return [n.getTensorArray(s.id).gather(r, a)]
                }
                case "TensorArrayScatterV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = zx("indices", e, t, n),
                        a = zx("tensor", e, t, n),
                        i = n.getTensorArray(s.id);
                    return i.scatter(r, a), [i.idTensor]
                }
                case "TensorArrayConcatV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = n.getTensorArray(s.id),
                        a = zx("dtype", e, t, n);
                    return [r.concat(a)]
                }
                case "TensorArraySplitV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = zx("tensor", e, t, n),
                        a = zx("lengths", e, t, n),
                        i = n.getTensorArray(s.id);
                    return i.split(a, r), [i.idTensor]
                }
                case "TensorArraySizeV3": {
                    const s = zx("tensorArrayId", e, t, n);
                    return [vi(n.getTensorArray(s.id).size(), "int32")]
                }
                case "TensorArrayCloseV3": {
                    const s = zx("tensorArrayId", e, t, n),
                        r = n.getTensorArray(s.id);
                    return r.clearAndClose(), [r.idTensor]
                }
                case "TensorListSetItem": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("index", e, t, n),
                        a = zx("tensor", e, t, n),
                        i = n.getTensorList(s.id);
                    return i.setItem(r, a), [i.idTensor]
                }
                case "TensorListGetItem": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("index", e, t, n),
                        a = zx("elementShape", e, t, n),
                        i = zx("elementDType", e, t, n);
                    return [n.getTensorList(s.id).getItem(r, a, i)]
                }
                case "TensorListScatterV2":
                case "TensorListScatter": {
                    const s = zx("indices", e, t, n),
                        r = function(e, t, n, s) {
                            if (t.length !== e.shape[0]) throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);
                            const r = Math.max(...t);
                            if (null != s && -1 !== s && r >= s) throw new Error(`Max index must be < array size (${r}  vs. ${s})`);
                            const a = new Fw([], n, e.dtype, s),
                                i = Cu(e, 0);
                            return t.forEach(((e, t) => {
                                a.setItem(e, i[t])
                            })), a
                        }(zx("tensor", e, t, n), s, zx("elementShape", e, t, n), zx("numElements", e, t, n));
                    return n.addTensorList(r), [r.idTensor]
                }
                case "TensorListReserve":
                case "EmptyTensorList": {
                    const s = zx("elementShape", e, t, n),
                        r = zx("elementDType", e, t, n);
                    let a;
                    a = "TensorListReserve" === e.op ? "numElements" : "maxNumElements";
                    const i = function(e, t, n) {
                        return new Fw([], e, t, n)
                    }(s, r, zx(a, e, t, n));
                    return n.addTensorList(i), [i.idTensor]
                }
                case "TensorListGather": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("indices", e, t, n),
                        a = zx("elementShape", e, t, n),
                        i = zx("elementDType", e, t, n);
                    return [n.getTensorList(s.id).gather(r, i, a)]
                }
                case "TensorListStack": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("elementShape", e, t, n),
                        a = zx("elementDType", e, t, n),
                        i = zx("numElements", e, t, n);
                    return [n.getTensorList(s.id).stack(r, a, i)]
                }
                case "TensorListFromTensor": {
                    const s = function(e, t, n) {
                        const s = e.dtype;
                        if (e.shape.length < 1) throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);
                        if (e.dtype !== n) throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);
                        $w(e.shape.slice(1), t, "TensorList shape mismatch: ");
                        const r = Cu(e);
                        return new Fw(r, t, s)
                    }(zx("tensor", e, t, n), zx("elementShape", e, t, n), zx("elementDType", e, t, n));
                    return n.addTensorList(s), [s.idTensor]
                }
                case "TensorListConcat":
                case "TensorListConcatV2": {
                    const s = zx("tensorListId", e, t, n),
                        r = n.getTensorList(s.id),
                        a = zx("dtype", e, t, n),
                        i = zx("elementShape", e, t, n);
                    return [r.concat(a, i)]
                }
                case "TensorListPushBack": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("tensor", e, t, n),
                        a = n.getTensorList(s.id);
                    return a.pushBack(r), [a.idTensor]
                }
                case "TensorListPopBack": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("elementShape", e, t, n),
                        a = zx("elementDType", e, t, n);
                    return [n.getTensorList(s.id).popBack(r, a)]
                }
                case "TensorListSplit": {
                    const s = zx("tensor", e, t, n),
                        r = zx("elementShape", e, t, n),
                        a = function(e, t, n) {
                            let s = 0;
                            const r = t.map((e => (s += e, s)));
                            if (s !== e.shape[0]) throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${e.shape}`);
                            const a = Aw(e.shape.slice(1), n),
                                i = 0 === s ? 0 : e.size / s,
                                o = yi((() => {
                                    const n = [];
                                    e = Vi(e, [1, s, i]);
                                    for (let s = 0; s < t.length; ++s) {
                                        const o = [0, 0 === s ? 0 : r[s - 1], 0],
                                            u = [1, t[s], i];
                                        n[s] = Vi(du(e, o, u), a)
                                    }
                                    return e.dispose(), n
                                })),
                                u = new Fw([], n, e.dtype, t.length);
                            for (let e = 0; e < o.length; e++) u.setItem(e, o[e]);
                            return u
                        }(s, zx("lengths", e, t, n), r);
                    return n.addTensorList(a), [a.idTensor]
                }
                case "TensorListLength": {
                    const s = zx("tensorListId", e, t, n);
                    return [vi(n.getTensorList(s.id).size(), "int32")]
                }
                case "TensorListResize": {
                    const s = zx("tensorListId", e, t, n),
                        r = zx("size", e, t, n),
                        a = n.getTensorList(s.id).resize(r);
                    return n.addTensorList(a), [a.idTensor]
                }
                default:
                    throw TypeError(`Node type ${e.op} is not implemented`)
            }
        };
        const _w = Pr({
            maxPoolWithArgmax_: function(e, t, n, s, r = !1) {
                const a = {
                        x: zr(e, "x", "maxPoolWithArgmax")
                    },
                    i = {
                        filterSize: t,
                        strides: n,
                        pad: s,
                        includeBatchInIndex: r
                    },
                    o = Er.runKernel(en, a, i);
                return {
                    result: o[0],
                    indexes: o[1]
                }
            }
        });

        function Ow(e, t, n) {
            const [s, r] = zx("fusedOps", e, t, n), a = "biasadd" === s, i = !a, o = "prelu" === r, u = "fusedbatchnorm" === s, l = zx("numArgs", e, t, n);
            if (a) {
                if (o && 2 !== l) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                if (!o && a && 1 !== l) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")
            }
            if (u) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
            const c = zx("strides", e, t, n),
                h = Vx(e, t, n),
                p = zx("dataFormat", e, t, n).toUpperCase(),
                d = zx("dilations", e, t, n);
            let [f, m] = zx("args", e, t, n);
            i && (m = f, f = void 0);
            return {
                stride: c,
                pad: h,
                dataFormat: p,
                dilations: d,
                biasArg: f,
                preluArg: m,
                activationFunc: r,
                leakyreluAlpha: zx("leakyreluAlpha", e, t, n)
            }
        }

        function Mw(e, t, n) {
            if (n <= 0) throw new Error("The number of values should be positive.");
            const s = {
                start: e,
                stop: t,
                num: n
            };
            return Er.runKernel(Pt, {}, s)
        }
        const Lw = Pr({
            multinomial_: function(e, t, n, s = !1) {
                const r = zr(e, "logits", "multinomial"),
                    a = r.size,
                    i = r.rank;
                if (a < 2) throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);
                if (i > 2) throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);
                n = n || Math.random();
                const o = {
                        logits: 1 === i ? Vi(r, [1, -1]) : r
                    },
                    u = {
                        numSamples: t,
                        seed: n,
                        normalized: s
                    },
                    l = Er.runKernel(on, o, u);
                return 1 === i ? Vi(l, [l.size]) : l
            }
        });
        const zw = async function(e) {
            const t = zr(e, "condition", "whereAsync", "bool"),
                n = await t.data(),
                s = gh(t.shape, n);
            return e !== t && t.dispose(), s
        };
        const Bw = async function(e, t) {
            const n = zr(e, "x", "setdiff1d"),
                s = zr(t, "y", "setdiff1d");
            R(n.dtype === s.dtype, (() => `x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`)), R(1 === n.rank, (() => `x should be 1D tensor, but got x (${n.shape}).`)), R(1 === s.rank, (() => `y should be 1D tensor, but got y (${s.shape}).`));
            const r = await n.data(),
                a = await s.data(),
                i = new Set(a);
            let o = 0;
            for (let e = 0; e < r.length; e++) i.has(r[e]) || o++;
            const u = new ir([o], n.dtype),
                l = new ir([o], "int32");
            for (let e = 0, t = 0; e < r.length; e++) i.has(r[e]) || (u.values[t] = r[e], l.values[t] = e, t++);
            return [u.toTensor(), l.toTensor()]
        };

        function Pw(e, t, n) {
            return {
                boxes: zx("boxes", e, t, n),
                scores: zx("scores", e, t, n),
                maxOutputSize: zx("maxOutputSize", e, t, n),
                iouThreshold: zx("iouThreshold", e, t, n),
                scoreThreshold: zx("scoreThreshold", e, t, n),
                softNmsSigma: zx("softNmsSigma", e, t, n)
            }
        }
        const Uw = 2147483648;
        const Ww = Pr({
            searchSorted_: function(e, t, n = "left") {
                const s = zr(e, "sortedSequence", "searchSorted"),
                    r = zr(t, "values", "searchSorted"),
                    a = s.shape[s.shape.length - 1],
                    i = r.shape[r.shape.length - 1],
                    o = Vi(s, [-1, a]),
                    u = Vi(r, [-1, i]);
                if (o.rank < 2) throw new Error("Sorted input argument must be at least 2-dimensional");
                if (o.shape[0] !== u.shape[0]) throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
                if (O(u.shape) >= Uw) throw new Error("values tensor size must less than 2147483648");
                if (o.shape[1] >= Uw) throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);
                const l = {
                        sortedSequence: o,
                        values: u
                    },
                    c = {
                        side: n
                    };
                return Er.runKernel(On, l, c)
            }
        });

        function Vw(e, t) {
            return Ww(e, t, "left")
        }

        function Gw(e, t) {
            return Ww(e, t, "right")
        }
        class Hw {
            constructor(e, t) {
                this.keyDType = e, this.valueDType = t, this.handle = vi(0), this.tensorMap = new Map, xi(this.handle)
            }
            get id() {
                return this.handle.id
            }
            clearAndClose() {
                this.tensorMap.forEach((e => e.dispose())), this.tensorMap.clear(), this.handle.dispose()
            }
            size() {
                return this.tensorMap.size
            }
            tensorSize() {
                return vi(this.size(), "int32")
            }
            async import(e, t) {
                this.checkKeyAndValueTensor(e, t);
                const n = await e.data();
                return this.tensorMap.forEach((e => e.dispose())), this.tensorMap.clear(), yi((() => {
                    const e = Cu(t),
                        s = n.length,
                        r = e.length;
                    R(s === r, (() => `The number of elements doesn't match, keys has ${s} elements, the values has ${r} elements.`));
                    for (let t = 0; t < s; t++) {
                        const s = n[t],
                            r = e[t];
                        xi(r), this.tensorMap.set(s, r)
                    }
                    return this.handle
                }))
            }
            async find(e, t) {
                this.checkKeyAndValueTensor(e, t);
                const n = await e.data();
                return yi((() => {
                    const e = [];
                    for (let s = 0; s < n.length; s++) {
                        const r = n[s],
                            a = this.findWithDefault(r, t);
                        e.push(a)
                    }
                    return Iu(e)
                }))
            }
            findWithDefault(e, t) {
                const n = this.tensorMap.get(e);
                return null != n ? n : t
            }
            checkKeyAndValueTensor(e, t) {
                if (e.dtype !== this.keyDType) throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
                if (t.dtype !== this.valueDType) throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)
            }
        }
        const jw = Pr({
            einsum_: function(e, ...t) {
                const n = t.map(((e, t) => zr(e, `tensors${t}`, "einsum"))),
                    s = {
                        equation: e
                    };
                return Er.runKernel(dt, n, s)
            }
        });
        const qw = Pr({
            sparseToDense_: function(e, t, n, s = 0) {
                const r = zr(e, "sparseIndices", "sparseToDense", "int32"),
                    a = zr(t, "sparseValues", "sparseToDense", "string_or_numeric"),
                    i = zr(s, "defaultValue", "sparseToDense", a.dtype);
                ! function(e, t, n, s) {
                    if ("int32" !== e.dtype) throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);
                    if (e.rank > 2) throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);
                    const r = e.rank > 0 ? e.shape[0] : 1,
                        a = e.rank > 1 ? e.shape[1] : 1;
                    if (n.length !== a) throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);
                    const i = t.size;
                    if (0 !== t.rank && (1 !== t.rank || i !== r)) throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);
                    if (t.dtype !== s.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
                }(r, a, n, i);
                const o = {
                        sparseIndices: r,
                        sparseValues: a,
                        defaultValue: i
                    },
                    u = {
                        outputShape: n
                    };
                return Er.runKernel(Qn, o, u)
            }
        });
        const Kw = Pr({
            denseBincount_: function(e, t, n, s = !1) {
                const r = zr(e, "x", "denseBincount"),
                    a = zr(t, "weights", "denseBincount");
                R("int32" === r.dtype, (() => `Error in denseBincount: input dtype must be int32, but got ${r.dtype}`)), R(r.rank <= 2, (() => `Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`)), R(n >= 0, (() => `size must be non-negative, but got ${n}.`)), R(a.size === r.size || 0 === a.size, (() => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`));
                const i = {
                        x: r,
                        weights: a
                    },
                    o = {
                        size: n,
                        binaryOutput: s
                    };
                return Er.runKernel(st, i, o)
            }
        });
        const Xw = Pr({
            scatterND_: function(e, t, n) {
                const s = zr(e, "indices", "scatterND", "int32"),
                    r = zr(t, "updates", "scatterND");
                Nc(r, s, n);
                const a = {
                        indices: s,
                        updates: r
                    },
                    i = {
                        shape: n
                    };
                return Er.runKernel(_n, a, i)
            }
        });
        const Yw = Pr({
            gatherND_: function(e, t) {
                const n = zr(t, "indices", "gatherND", "int32"),
                    s = {
                        params: zr(e, "x", "gatherND", "string_or_numeric"),
                        indices: n
                    };
                return Er.runKernel(Ct, s)
            }
        });
        const Jw = Pr({
            broadcastArgs_: function(e, t) {
                const n = zr(e, "s0", "broadcastArgs", "int32"),
                    s = zr(t, "s1", "broadcastArgs", "int32");
                if (1 !== n.rank) throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);
                if (1 !== s.rank) throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);
                const r = {
                    s0: n,
                    s1: s
                };
                return Er.runKernel(Be, r)
            }
        });

        function Zw(e, t, n, s) {
            const r = ((e, t, n) => {
                switch (e.category) {
                    case "arithmetic":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "BiasAdd":
                                case "AddV2":
                                case "Add":
                                    return [Si(zx("a", e, t, n), zx("b", e, t, n))];
                                case "AddN":
                                    return [Tw(zx("tensors", e, t, n))];
                                case "FloorMod":
                                case "Mod":
                                    return [Gd(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Mul":
                                    return [Co(zx("a", e, t, n), zx("b", e, t, n))];
                                case "RealDiv":
                                case "Div":
                                    return [ho(zx("a", e, t, n), zx("b", e, t, n))];
                                case "DivNoNan":
                                    return [Rd(zx("a", e, t, n), zx("b", e, t, n))];
                                case "FloorDiv":
                                    return [co(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Sub":
                                    return [Eo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Minimum":
                                    return [zo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Maximum":
                                    return [Mo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Pow":
                                    return [Dl(zx("a", e, t, n), zx("b", e, t, n))];
                                case "SquaredDifference":
                                    return [Ul(zx("a", e, t, n), zx("b", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "basic_math":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Abs":
                                case "ComplexAbs":
                                    return [Ni(zx("x", e, t, n))];
                                case "Acos":
                                    return [wd(zx("x", e, t, n))];
                                case "Acosh":
                                    return [kd(zx("x", e, t, n))];
                                case "Asin":
                                    return [Id(zx("x", e, t, n))];
                                case "Asinh":
                                    return [Nd(zx("x", e, t, n))];
                                case "Atan":
                                    return [Sd(zx("x", e, t, n))];
                                case "Atan2":
                                    return [Td(zx("x", e, t, n), zx("y", e, t, n))];
                                case "Atanh":
                                    return [$d(zx("x", e, t, n))];
                                case "Ceil":
                                    return [Cd(zx("x", e, t, n))];
                                case "Complex":
                                    return [Ur(zx("real", e, t, n), zx("imag", e, t, n))];
                                case "Cos":
                                    return [ld(zx("x", e, t, n))];
                                case "Cosh":
                                    return [hd(zx("x", e, t, n))];
                                case "Elu":
                                    return [po(zx("x", e, t, n))];
                                case "Erf":
                                    return [Dd(zx("x", e, t, n))];
                                case "Exp":
                                    return [mo(zx("x", e, t, n))];
                                case "Expm1":
                                    return [Od(zx("x", e, t, n))];
                                case "Floor":
                                    return [wo(zx("x", e, t, n))];
                                case "Log":
                                    return [So(zx("x", e, t, n))];
                                case "Log1p":
                                    return [To(zx("x", e, t, n))];
                                case "Imag":
                                    return [Fu(zx("x", e, t, n))];
                                case "Neg":
                                    return [Xo(zx("x", e, t, n))];
                                case "Reciprocal":
                                    return [qd(zx("x", e, t, n))];
                                case "Real":
                                    return [Du(zx("x", e, t, n))];
                                case "Relu":
                                    return [uu(zx("x", e, t, n))];
                                case "Round":
                                    return [$l(zx("x", e, t, n))];
                                case "Selu":
                                    return [cu(zx("x", e, t, n))];
                                case "Sigmoid":
                                    return [pu(zx("x", e, t, n))];
                                case "Sin":
                                    return [jh(zx("x", e, t, n))];
                                case "Sign":
                                    return [Kd(zx("x", e, t, n))];
                                case "Sinh":
                                    return [Kh(zx("x", e, t, n))];
                                case "Softplus":
                                    return [xu(zx("x", e, t, n))];
                                case "Sqrt":
                                    return [ku(zx("x", e, t, n))];
                                case "Square":
                                    return [qo(zx("x", e, t, n))];
                                case "Tanh":
                                    return [Nu(zx("x", e, t, n))];
                                case "Tan":
                                    return [Yd(zx("x", e, t, n))];
                                case "ClipByValue":
                                    return [Yi(zx("x", e, t, n), zx("clipValueMin", e, t, n), zx("clipValueMax", e, t, n))];
                                case "Relu6":
                                    return [Uu(zx("x", e, t, n))];
                                case "Rsqrt":
                                    return [op(Bx(e.inputNames[0], t, n))];
                                case "Prod":
                                    return [jd(zx("x", e, t, n), zx("axes", e, t, n))];
                                case "LeakyRelu":
                                    return [No(zx("x", e, t, n), zx("alpha", e, t, n))];
                                case "Prelu":
                                    return [nu(zx("x", e, t, n), zx("alpha", e, t, n))];
                                case "IsNan":
                                    return [zd(Bx(e.inputNames[0], t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "control":
                        return Dw(e, t, n);
                    case "convolution":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Conv1D": {
                                    const s = zx("stride", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("dataFormat", e, t, n).toUpperCase(),
                                        i = zx("dilation", e, t, n);
                                    return [so(zx("x", e, t, n), zx("filter", e, t, n), s, r, a, i)]
                                }
                                case "Conv2D": {
                                    const s = zx("strides", e, t, n),
                                        r = Vx(e, t, n),
                                        a = zx("dataFormat", e, t, n).toUpperCase(),
                                        i = zx("dilations", e, t, n);
                                    return [no(zx("x", e, t, n), zx("filter", e, t, n), [s[1], s[2]], r, a, [i[1], i[2]])]
                                }
                                case "_FusedConv2D": {
                                    const {
                                        stride: s,
                                        pad: r,
                                        dataFormat: a,
                                        dilations: i,
                                        biasArg: o,
                                        preluArg: u,
                                        activationFunc: l,
                                        leakyreluAlpha: c
                                    } = Ow(e, t, n);
                                    return [qu({
                                        x: zx("x", e, t, n),
                                        filter: zx("filter", e, t, n),
                                        strides: [s[1], s[2]],
                                        pad: r,
                                        dataFormat: a,
                                        dilations: [i[1], i[2]],
                                        bias: o,
                                        activation: l,
                                        preluActivationWeights: u,
                                        leakyreluAlpha: c
                                    })]
                                }
                                case "FusedDepthwiseConv2dNative": {
                                    const {
                                        stride: s,
                                        pad: r,
                                        dataFormat: a,
                                        dilations: i,
                                        biasArg: o,
                                        preluArg: u,
                                        activationFunc: l,
                                        leakyreluAlpha: c
                                    } = Ow(e, t, n);
                                    return [Yu({
                                        x: zx("x", e, t, n),
                                        filter: zx("filter", e, t, n),
                                        strides: [s[1], s[2]],
                                        pad: r,
                                        dataFormat: a,
                                        dilations: [i[1], i[2]],
                                        bias: o,
                                        activation: l,
                                        preluActivationWeights: u,
                                        leakyreluAlpha: c
                                    })]
                                }
                                case "Conv2DBackpropInput":
                                case "Conv2dTranspose": {
                                    const s = zx("outputShape", e, t, n),
                                        r = zx("strides", e, t, n),
                                        a = Vx(e, t, n);
                                    return [ao(zx("x", e, t, n), zx("filter", e, t, n), s, [r[1], r[2]], a)]
                                }
                                case "DepthwiseConv2dNative":
                                case "DepthwiseConv2d": {
                                    const s = zx("strides", e, t, n),
                                        r = Vx(e, t, n),
                                        a = zx("dilations", e, t, n),
                                        i = zx("dataFormat", e, t, n).toUpperCase();
                                    return [lo(zx("input", e, t, n), zx("filter", e, t, n), [s[1], s[2]], r, i, [a[1], a[2]])]
                                }
                                case "Conv3D": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("dataFormat", e, t, n).toUpperCase(),
                                        i = zx("dilations", e, t, n);
                                    return [io(zx("x", e, t, n), zx("filter", e, t, n), [s[1], s[2], s[3]], r, a, [i[1], i[2], i[3]])]
                                }
                                case "AvgPool": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("kernelSize", e, t, n);
                                    return [Gi(zx("x", e, t, n), [a[1], a[2]], [s[1], s[2]], r)]
                                }
                                case "MaxPool": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("kernelSize", e, t, n);
                                    return [_o(zx("x", e, t, n), [a[1], a[2]], [s[1], s[2]], r)]
                                }
                                case "MaxPoolWithArgmax": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("kernelSize", e, t, n),
                                        i = zx("includeBatchInIndex", e, t, n),
                                        {
                                            result: o,
                                            indexes: u
                                        } = _w(zx("x", e, t, n), [a[1], a[2]], [s[1], s[2]], r, i);
                                    return [o, u]
                                }
                                case "AvgPool3D": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("kernelSize", e, t, n);
                                    return [Hi(zx("x", e, t, n), [a[1], a[2], a[3]], [s[1], s[2], s[3]], r)]
                                }
                                case "MaxPool3D": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("kernelSize", e, t, n);
                                    return [Oo(zx("x", e, t, n), [a[1], a[2], a[3]], [s[1], s[2], s[3]], r)]
                                }
                                case "Dilation2D": {
                                    const s = zx("strides", e, t, n),
                                        r = zx("pad", e, t, n),
                                        a = zx("dilations", e, t, n),
                                        i = s[1],
                                        o = s[2],
                                        u = a[1],
                                        l = a[2];
                                    return [Ad(zx("x", e, t, n), zx("filter", e, t, n), [i, o], r, [u, l], "NHWC")]
                                }
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "creation":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Fill": {
                                    const s = zx("shape", e, t, n),
                                        r = zx("dtype", e, t, n);
                                    return [xo(s, zx("value", e, t, n), r)]
                                }
                                case "LinSpace":
                                    return [Mw(zx("start", e, t, n), zx("stop", e, t, n), zx("num", e, t, n))];
                                case "Multinomial": {
                                    const s = zx("logits", e, t, n),
                                        r = zx("numSamples", e, t, n),
                                        a = zx("seed", e, t, n);
                                    return [Lw(s, r, a)]
                                }
                                case "OneHot": {
                                    const s = zx("indices", e, t, n),
                                        r = zx("depth", e, t, n),
                                        a = zx("onValue", e, t, n),
                                        i = zx("offValue", e, t, n);
                                    return [Jo(s, r, a, i)]
                                }
                                case "Ones":
                                    return [Qo(zx("shape", e, t, n), zx("dtype", e, t, n))];
                                case "OnesLike":
                                    return [eu(zx("x", e, t, n))];
                                case "RandomUniform":
                                    return [ou(zx("shape", e, t, n), zx("minval", e, t, n), zx("maxval", e, t, n), zx("dtype", e, t, n))];
                                case "Range":
                                    return [Cl(zx("start", e, t, n), zx("stop", e, t, n), zx("step", e, t, n), zx("dtype", e, t, n))];
                                case "TruncatedNormal": {
                                    const s = zx("shape", e, t, n),
                                        r = zx("mean", e, t, n),
                                        a = zx("stdDev", e, t, n),
                                        i = zx("seed", e, t, n);
                                    return [$u(s, r, a, zx("dtype", e, t, n), i)]
                                }
                                case "Zeros":
                                    return [Zo(zx("shape", e, t, n), zx("dtype", e, t, n))];
                                case "ZerosLike":
                                    return [Ru(zx("x", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "dynamic":
                        return (async (e, t, n) => {
                            switch (e.op) {
                                case "NonMaxSuppressionV5": {
                                    const {
                                        boxes: s,
                                        scores: r,
                                        maxOutputSize: a,
                                        iouThreshold: i,
                                        scoreThreshold: o,
                                        softNmsSigma: u
                                    } = Pw(e, t, n), l = await Jl.nonMaxSuppressionWithScoreAsync(s, r, a, i, o, u);
                                    return [l.selectedIndices, l.selectedScores]
                                }
                                case "NonMaxSuppressionV4": {
                                    const {
                                        boxes: s,
                                        scores: r,
                                        maxOutputSize: a,
                                        iouThreshold: i,
                                        scoreThreshold: o
                                    } = Pw(e, t, n), u = zx("padToMaxOutputSize", e, t, n), l = await Jl.nonMaxSuppressionPaddedAsync(s, r, a, i, o, u);
                                    return [l.selectedIndices, l.validOutputs]
                                }
                                case "NonMaxSuppressionV3":
                                case "NonMaxSuppressionV2": {
                                    const {
                                        boxes: s,
                                        scores: r,
                                        maxOutputSize: a,
                                        iouThreshold: i,
                                        scoreThreshold: o
                                    } = Pw(e, t, n);
                                    return [await Jl.nonMaxSuppressionAsync(s, r, a, i, o)]
                                }
                                case "Where": {
                                    const s = Ra(zx("condition", e, t, n), "bool"),
                                        r = [await zw(s)];
                                    return s.dispose(), r
                                }
                                case "ListDiff":
                                    return Bw(zx("x", e, t, n), zx("y", e, t, n));
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n);
                    case "evaluation":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "LowerBound":
                                    return [Vw(zx("sortedSequence", e, t, n), zx("values", e, t, n))];
                                case "TopKV2": {
                                    const s = zx("x", e, t, n),
                                        r = zx("k", e, t, n),
                                        a = zx("sorted", e, t, n),
                                        i = Jd(s, r, a);
                                    return [i.values, i.indices]
                                }
                                case "UpperBound":
                                    return [Gw(zx("sortedSequence", e, t, n), zx("values", e, t, n))];
                                case "Unique": {
                                    const s = zx("x", e, t, n),
                                        r = Zd(s);
                                    return [r.values, r.indices]
                                }
                                case "UniqueV2": {
                                    const s = zx("x", e, t, n),
                                        r = zx("axis", e, t, n),
                                        a = Zd(s, r);
                                    return [a.values, a.indices]
                                }
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "image":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "ResizeBilinear": {
                                    const s = zx("images", e, t, n),
                                        r = zx("size", e, t, n),
                                        a = zx("alignCorners", e, t, n),
                                        i = zx("halfPixelCenters", e, t, n);
                                    return [Jl.resizeBilinear(s, [r[0], r[1]], a, i)]
                                }
                                case "ResizeNearestNeighbor": {
                                    const s = zx("images", e, t, n),
                                        r = zx("size", e, t, n),
                                        a = zx("alignCorners", e, t, n),
                                        i = zx("halfPixelCenters", e, t, n);
                                    return [Jl.resizeNearestNeighbor(s, [r[0], r[1]], a, i)]
                                }
                                case "CropAndResize": {
                                    const s = zx("image", e, t, n),
                                        r = zx("boxes", e, t, n),
                                        a = zx("boxInd", e, t, n),
                                        i = zx("cropSize", e, t, n),
                                        o = zx("method", e, t, n),
                                        u = zx("extrapolationValue", e, t, n);
                                    return [Jl.cropAndResize(s, r, a, i, o, u)]
                                }
                                case "ImageProjectiveTransformV3": {
                                    const s = zx("images", e, t, n),
                                        r = zx("transforms", e, t, n),
                                        a = zx("outputShape", e, t, n),
                                        i = zx("fillValue", e, t, n),
                                        o = zx("interpolation", e, t, n),
                                        u = zx("fillMode", e, t, n);
                                    return [Jl.transform(s, r, o.toLowerCase(), u.toLowerCase(), i, a)]
                                }
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "graph":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Const":
                                    return t[e.name];
                                case "PlaceholderWithDefault":
                                    const s = zx("default", e, t, n);
                                    return [Bx(e.name, t, n) || s];
                                case "Placeholder":
                                    return [Bx(e.name, t, n)];
                                case "Identity":
                                case "StopGradient":
                                case "FakeQuantWithMinMaxVars":
                                case "Snapshot":
                                    return [Gx(zx("x", e, t, n))];
                                case "IdentityN":
                                    return zx("x", e, t, n).map((e => Gx(e)));
                                case "Shape":
                                    return [Su(zx("x", e, t, n).shape, "int32")];
                                case "ShapeN":
                                    return zx("x", e, t, n).map((e => Su(e.shape)));
                                case "Size":
                                    return [vi(zx("x", e, t, n).size, "int32")];
                                case "Rank":
                                    return [vi(zx("x", e, t, n).rank, "int32")];
                                case "NoOp":
                                    return [vi(1)];
                                case "Print":
                                    const r = zx("x", e, t, n),
                                        a = zx("data", e, t, n),
                                        i = zx("message", e, t, n),
                                        o = zx("summarize", e, t, n);
                                    console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(i);
                                    for (let e = 0; e < a.length; e++) console.log(Array.prototype.slice.call(a[e].dataSync()).slice(0, o));
                                    return [r];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "logical":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Equal":
                                    return [fo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "NotEqual":
                                    return [Yo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Greater":
                                    return [vo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "GreaterEqual":
                                    return [Io(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Less":
                                    return [Tp(zx("a", e, t, n), zx("b", e, t, n))];
                                case "LessEqual":
                                    return [Tl(zx("a", e, t, n), zx("b", e, t, n))];
                                case "LogicalAnd":
                                    return [Fo(zx("a", e, t, n), zx("b", e, t, n))];
                                case "LogicalNot":
                                    return [rd(zx("a", e, t, n))];
                                case "LogicalOr":
                                    return [Ud(zx("a", e, t, n), zx("b", e, t, n))];
                                case "Select":
                                case "SelectV2":
                                    return [Au(zx("condition", e, t, n), zx("a", e, t, n), zx("b", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "matrices":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "BatchMatMul":
                                case "BatchMatMulV2":
                                case "MatMul":
                                    return [Do(zx("a", e, t, n), zx("b", e, t, n), zx("transposeA", e, t, n), zx("transposeB", e, t, n))];
                                case "Einsum":
                                    return [jw(zx("equation", e, t, n), ...zx("tensors", e, t, n))];
                                case "Transpose":
                                    return [_u(zx("x", e, t, n), zx("perm", e, t, n))];
                                case "_FusedMatMul":
                                    const [s, r] = zx("fusedOps", e, t, n), a = "biasadd" === s, i = "prelu" === r, o = zx("numArgs", e, t, n), u = zx("leakyreluAlpha", e, t, n);
                                    if (a) {
                                        if (i && 2 !== o) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                                        if (!i && 1 !== o) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")
                                    }
                                    const [l, c] = zx("args", e, t, n);
                                    return [Ju({
                                        a: zx("a", e, t, n),
                                        b: zx("b", e, t, n),
                                        transposeA: zx("transposeA", e, t, n),
                                        transposeB: zx("transposeB", e, t, n),
                                        bias: l,
                                        activation: r,
                                        preluActivationWeights: c,
                                        leakyreluAlpha: u
                                    })];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "normalization":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "EuclideanNorm":
                                    return [_d(zx("x", e, t, n), zx("axis", e, t, n), zx("keepDims", e, t, n))];
                                case "FusedBatchNorm":
                                case "FusedBatchNormV2":
                                case "FusedBatchNormV3":
                                    return [ji(zx("x", e, t, n), zx("mean", e, t, n), zx("variance", e, t, n), zx("offset", e, t, n), zx("scale", e, t, n), zx("epsilon", e, t, n))];
                                case "LRN":
                                    return [Bd(zx("x", e, t, n), zx("radius", e, t, n), zx("bias", e, t, n), zx("alpha", e, t, n), zx("beta", e, t, n))];
                                case "Softmax":
                                    return [bu(zx("x", e, t, n))];
                                case "LogSoftmax":
                                    return [Ro(zx("x", e, t, n))];
                                case "SparseToDense":
                                    return [qw(zx("sparseIndices", e, t, n), zx("outputShape", e, t, n), zx("sparseValues", e, t, n), zx("defaultValue", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "reduction":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Max": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [$o(zx("x", e, t, n), s, r)]
                                }
                                case "Mean": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [Lo(zx("x", e, t, n), s, r)]
                                }
                                case "Min": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [Fl(zx("x", e, t, n), s, r)]
                                }
                                case "Sum": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [Ao(zx("x", e, t, n), s, r)]
                                }
                                case "All": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [Ti(zx("x", e, t, n), s, r)]
                                }
                                case "Any": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [$i(zx("x", e, t, n), s, r)]
                                }
                                case "ArgMax": {
                                    const s = zx("axis", e, t, n);
                                    return [Ci(zx("x", e, t, n), s)]
                                }
                                case "ArgMin": {
                                    const s = zx("axis", e, t, n);
                                    return [vd(zx("x", e, t, n), s)]
                                }
                                case "Prod": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("keepDims", e, t, n);
                                    return [jd(zx("x", e, t, n), s, r)]
                                }
                                case "Cumprod": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("exclusive", e, t, n),
                                        a = zx("reverse", e, t, n);
                                    return [Hp(zx("x", e, t, n), s, r, a)]
                                }
                                case "Cumsum": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("exclusive", e, t, n),
                                        a = zx("reverse", e, t, n);
                                    return [Yh(zx("x", e, t, n), s, r, a)]
                                }
                                case "Bincount":
                                    const s = zx("x", e, t, n),
                                        r = zx("weights", e, t, n),
                                        a = zx("size", e, t, n);
                                    return [Sl(s, r, a)];
                                case "DenseBincount": {
                                    const s = zx("x", e, t, n),
                                        r = zx("weights", e, t, n),
                                        a = zx("size", e, t, n),
                                        i = zx("binaryOutput", e, t, n);
                                    return [Kw(s, r, a, i)]
                                }
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "slice_join":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "ConcatV2":
                                case "Concat": {
                                    const s = zx("n", e, t, n),
                                        r = zx("axis", e, t, n);
                                    let a = zx("tensors", e, t, n);
                                    return a = a.slice(0, s), [Ji(a, r)]
                                }
                                case "Gather": {
                                    const s = zx("x", e, t, n),
                                        r = zx("indices", e, t, n);
                                    return [ko(s, Ra(r, "int32"), 0)]
                                }
                                case "GatherV2": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("batchDims", e, t, n),
                                        a = zx("x", e, t, n),
                                        i = zx("indices", e, t, n);
                                    return [ko(a, Ra(i, "int32"), s, r)]
                                }
                                case "Reverse": {
                                    const s = zx("dims", e, t, n),
                                        r = [];
                                    for (let e = 0; e < s.length; e++) s[e] && r.push(e);
                                    const a = zx("x", e, t, n);
                                    return [lu(a, r)]
                                }
                                case "ReverseV2": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("x", e, t, n);
                                    return [lu(r, s)]
                                }
                                case "Slice": {
                                    const s = zx("begin", e, t, n),
                                        r = zx("size", e, t, n);
                                    return [du(zx("x", e, t, n), s, r)]
                                }
                                case "StridedSlice": {
                                    const s = zx("begin", e, t, n),
                                        r = zx("end", e, t, n),
                                        a = zx("strides", e, t, n),
                                        i = zx("beginMask", e, t, n),
                                        o = zx("endMask", e, t, n),
                                        u = zx("ellipsisMask", e, t, n),
                                        l = zx("newAxisMask", e, t, n),
                                        c = zx("shrinkAxisMask", e, t, n),
                                        h = zx("x", e, t, n);
                                    return [Xd(h, s, r, a, i, o, u, l, c)]
                                }
                                case "Pack":
                                    return yi((() => {
                                        const s = zx("axis", e, t, n),
                                            r = zx("tensors", e, t, n),
                                            a = r[0].shape,
                                            i = vu(r[0]).shape,
                                            o = r.map((e => {
                                                const t = M(e.shape, a);
                                                if (!t && !M(vu(e).shape, i)) throw new Error("the input tensors shape does not match");
                                                return t ? e : Vi(e, a)
                                            }));
                                        return [Iu(o, s)]
                                    }));
                                case "Unpack": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("tensor", e, t, n);
                                    return Cu(r, s)
                                }
                                case "Tile": {
                                    const s = zx("reps", e, t, n);
                                    return [yo(zx("x", e, t, n), s)]
                                }
                                case "Split":
                                case "SplitV": {
                                    const s = zx("axis", e, t, n),
                                        r = zx("numOrSizeSplits", e, t, n),
                                        a = zx("x", e, t, n);
                                    return wu(a, r, s)
                                }
                                case "ScatterNd": {
                                    const s = zx("indices", e, t, n),
                                        r = zx("values", e, t, n),
                                        a = zx("shape", e, t, n);
                                    return [Xw(s, r, a)]
                                }
                                case "GatherNd": {
                                    const s = zx("x", e, t, n),
                                        r = zx("indices", e, t, n);
                                    return [Yw(s, r)]
                                }
                                case "SparseToDense": {
                                    const s = zx("sparseIndices", e, t, n),
                                        r = zx("outputShape", e, t, n),
                                        a = zx("sparseValues", e, t, n),
                                        i = zx("defaultValue", e, t, n);
                                    return [qw(s, a, r, a.dtype === i.dtype ? i : Ra(i, a.dtype))]
                                }
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "sparse":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "SparseFillEmptyRows": {
                                    const {
                                        outputIndices: s,
                                        outputValues: r,
                                        emptyRowIndicator: a,
                                        reverseIndexMap: i
                                    } = Ql.sparseFillEmptyRows(zx("indices", e, t, n), zx("values", e, t, n), zx("denseShape", e, t, n), zx("defaultValue", e, t, n));
                                    return [s, r, a, i]
                                }
                                case "SparseReshape": {
                                    const {
                                        outputIndices: s,
                                        outputShape: r
                                    } = Ql.sparseReshape(zx("inputIndices", e, t, n), zx("inputShape", e, t, n), zx("newShape", e, t, n));
                                    return [s, r]
                                }
                                case "SparseSegmentMean":
                                    return [Ql.sparseSegmentMean(zx("data", e, t, n), zx("indices", e, t, n), zx("segmentIds", e, t, n))];
                                case "SparseSegmentSum":
                                    return [Ql.sparseSegmentSum(zx("data", e, t, n), zx("indices", e, t, n), zx("segmentIds", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "spectral":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "FFT":
                                    return [Mu(zx("x", e, t, n))];
                                case "IFFT":
                                    return [zu(zx("x", e, t, n))];
                                case "RFFT":
                                    return [Lu(zx("x", e, t, n))];
                                case "IRFFT":
                                    return [Bu(zx("x", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "string":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "StringNGrams": {
                                    const {
                                        nGrams: s,
                                        nGramsSplits: r
                                    } = ec.stringNGrams(zx("data", e, t, n), zx("dataSplits", e, t, n), zx("separator", e, t, n), zx("nGramWidths", e, t, n), zx("leftPad", e, t, n), zx("rightPad", e, t, n), zx("padWidth", e, t, n), zx("preserveShortSequences", e, t, n));
                                    return [s, r]
                                }
                                case "StringSplit": {
                                    const {
                                        indices: s,
                                        values: r,
                                        shape: a
                                    } = ec.stringSplit(zx("input", e, t, n), zx("delimiter", e, t, n), zx("skipEmpty", e, t, n));
                                    return [s, r, a]
                                }
                                case "StringToHashBucketFast":
                                    return [ec.stringToHashBucketFast(zx("input", e, t, n), zx("numBuckets", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "transformation":
                        return yi((() => ((e, t, n) => {
                            switch (e.op) {
                                case "Cast":
                                    return [Ra(zx("x", e, t, n), zx("dtype", e, t, n))];
                                case "ExpandDims": {
                                    const s = zx("axis", e, t, n);
                                    return [go(zx("x", e, t, n), s)]
                                }
                                case "Squeeze": {
                                    const s = zx("axis", e, t, n);
                                    return [vu(zx("x", e, t, n), s)]
                                }
                                case "Reshape":
                                    return [Vi(zx("x", e, t, n), zx("shape", e, t, n))];
                                case "MirrorPad":
                                    return [Vd(zx("x", e, t, n), zx("padding", e, t, n), zx("mode", e, t, n))];
                                case "PadV2":
                                case "Pad":
                                    return [tu(zx("x", e, t, n), zx("padding", e, t, n), zx("constantValue", e, t, n))];
                                case "SpaceToBatchND": {
                                    const s = zx("blockShape", e, t, n),
                                        r = zx("paddings", e, t, n);
                                    return [_h(zx("x", e, t, n), s, r)]
                                }
                                case "BatchToSpaceND": {
                                    const s = zx("blockShape", e, t, n),
                                        r = zx("crops", e, t, n);
                                    return [gd(zx("x", e, t, n), s, r)]
                                }
                                case "DepthToSpace": {
                                    const s = zx("blockSize", e, t, n),
                                        r = zx("dataFormat", e, t, n).toUpperCase();
                                    return [Ed(zx("x", e, t, n), s, r)]
                                }
                                case "BroadcastTo":
                                    return [Eu(zx("x", e, t, n), zx("shape", e, t, n))];
                                case "BroadcastArgs":
                                    return [Jw(zx("s0", e, t, n), zx("s1", e, t, n))];
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n)));
                    case "hash_table":
                        return (async (e, t, n, s) => {
                            switch (e.op) {
                                case "HashTable":
                                case "HashTableV2": {
                                    const r = zx("keyDType", e, t, n),
                                        a = zx("valueDType", e, t, n),
                                        i = new Hw(r, a);
                                    return s.addHashTable(e.name, i), [i.handle]
                                }
                                case "LookupTableImport":
                                case "LookupTableImportV2": {
                                    const r = zx("tableHandle", e, t, n, s),
                                        a = zx("keys", e, t, n),
                                        i = zx("values", e, t, n),
                                        o = s.getHashTableById(r.id);
                                    return [await o.import(a, i)]
                                }
                                case "LookupTableFind":
                                case "LookupTableFindV2": {
                                    const r = zx("tableHandle", e, t, n, s),
                                        a = zx("keys", e, t, n),
                                        i = zx("defaultValue", e, t, n),
                                        o = s.getHashTableById(r.id);
                                    return [await o.find(a, i)]
                                }
                                case "LookupTableSize":
                                case "LookupTableSizeV2": {
                                    const r = zx("tableHandle", e, t, n, s);
                                    return [s.getHashTableById(r.id).tensorSize()]
                                }
                                default:
                                    throw TypeError(`Node type ${e.op} is not implemented`)
                            }
                        })(e, t, n, s);
                    case "custom":
                        const r = Lx(e.op);
                        if (r && r.customExecutor) return r.customExecutor(new Sw(e, t, n));
                        throw TypeError(`Custom op ${e.op} is not registered.`);
                    default:
                        throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)
                }
            })(e, t, n);
            return le(r) ? r.then((e => [].concat(e))) : [].concat(r)
        }
        class Qw {
            constructor(e = {}, t = {}, n = {}, s = {}) {
                this.weightMap = e, this.tensorArrayMap = t, this.tensorListMap = n, this.functionMap = s, this.rootContext = {
                    id: 0,
                    frameName: "",
                    iterationId: 0
                }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds()
            }
            newFrame(e, t) {
                return {
                    id: e,
                    frameName: t,
                    iterationId: 0
                }
            }
            set currentContext(e) {
                this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds())
            }
            get currentContext() {
                return this.contexts
            }
            get currentContextId() {
                return this._currentContextIds[0]
            }
            get currentContextIds() {
                return this._currentContextIds
            }
            generateCurrentContextIds() {
                const e = [];
                for (let t = 0; t < this.contexts.length - 1; t++) {
                    const n = this.contexts.slice(0, this.contexts.length - t);
                    e.push(this.contextIdforContexts(n))
                }
                e.push(""), this._currentContextIds = e
            }
            contextIdforContexts(e) {
                return e ? e.map((e => 0 === e.id && 0 === e.iterationId ? "" : `${e.frameName}-${e.iterationId}`)).join("/") : ""
            }
            enterFrame(e) {
                this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))
            }
            exitFrame() {
                if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
                this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift()
            }
            nextIteration() {
                if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
                {
                    this.contexts = this.contexts.slice(), this.lastId++;
                    const e = Object.assign({}, this.contexts[this.contexts.length - 1]);
                    e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
                }
            }
            getWeight(e) {
                return this.weightMap[e]
            }
            addTensorArray(e) {
                this.tensorArrayMap[e.id] = e
            }
            getTensorArray(e) {
                return this.tensorArrayMap[e]
            }
            addTensorList(e) {
                this.tensorListMap[e.id] = e
            }
            getTensorList(e) {
                return this.tensorListMap[e]
            }
            dispose(e) {
                for (const t in this.tensorArrayMap) this.tensorArrayMap[t].clearAndClose(e);
                for (const t in this.tensorListMap) this.tensorListMap[t].clearAndClose(e)
            }
        }

        function ek(e, t, n, s) {
            const r = new Set,
                a = [];
            let i = null,
                o = null;
            const u = new Set,
                l = Object.keys(e).map((e => Wx(e)[0]));
            let c = [];
            null != s && (c = s.map((e => Wx(e.name)[0])));
            const h = [...t];
            for (; h.length > 0;) {
                const e = h.pop();
                (rk(e) || ak(e) || ik(e)) && null == i && (i = e, o = i.children.map((e => e.name)).filter((e => r.has(e)))), r.add(e.name), null == n[e.name] && (-1 === l.indexOf(e.name) && -1 === c.indexOf(e.name) && (0 !== e.inputs.length ? e.inputs.forEach((e => {
                    u.has(e.name) || (u.add(e.name), h.push(e))
                })) : a.push(e.name)))
            }
            return {
                inputs: e,
                outputs: t,
                usedNodes: r,
                missingInputs: a,
                dynamicNode: i,
                syncInputs: o
            }
        }
        const tk = ["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"],
            nk = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"],
            sk = ["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"];

        function rk(e) {
            return tk.indexOf(e.op) >= 0
        }

        function ak(e) {
            return nk.indexOf(e.op) >= 0
        }

        function ik(e) {
            return sk.indexOf(e.op) >= 0
        }
        class ok {
            constructor(e, t) {
                this.graph = e, this.parent = t, this.compiledMap = new Map, this._weightMap = {}, this.SEPERATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.intermediateTensors = {}, this.keepTensorForDebug = !1, this._outputs = e.outputs, this._inputs = e.inputs, this._initNodes = e.initNodes, this._signature = e.signature, this._functions = e.functions, null != e.functions && Object.keys(e.functions).forEach((t => {
                    this._functionExecutorMap[t] = new ok(e.functions[t], this)
                }))
            }
            get weightIds() {
                return this.parent ? this.parent.weightIds : this._weightIds
            }
            get functionExecutorMap() {
                return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap
            }
            get weightMap() {
                return this.parent ? this.parent.weightMap : this._weightMap
            }
            set weightMap(e) {
                const t = Object.keys(e).map((t => e[t].map((e => e.id))));
                this._weightIds = [].concat(...t), this._weightMap = e
            }
            set resourceManager(e) {
                this._resourceManager = e
            }
            get inputs() {
                return this._inputs.map((e => ({
                    name: e.name,
                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                })))
            }
            get outputs() {
                return this._outputs.map((e => ({
                    name: e.name,
                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                })))
            }
            get inputNodes() {
                return this._inputs.map((e => e.signatureKey || e.name))
            }
            get outputNodes() {
                return this._outputs.map((e => {
                    const t = e.signatureKey || e.name;
                    return e.defaultOutput ? `${t}:${e.defaultOutput}` : t
                }))
            }
            get functions() {
                return Object.keys(this._functions).reduce(((e, t) => (e[t] = this._functions[t].signature, e)), {})
            }
            getCompilationKey(e, t) {
                const n = e.map((e => e.name)).sort(),
                    s = t.map((e => e.name)).sort();
                return n.join(this.SEPERATOR) + "--" + s.join(this.SEPERATOR)
            }
            compile(e, t) {
                const n = ek(e, t, this.weightMap, this._initNodes),
                    {
                        missingInputs: s,
                        dynamicNode: r,
                        syncInputs: a
                    } = n;
                if (null != r) throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);
                if (s.length > 0) {
                    const n = t.map((e => e.name)),
                        r = Object.keys(e);
                    throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${r}]. Missing the following inputs: [${s}]`)
                }
                return function(e, t, n) {
                    const {
                        usedNodes: s,
                        inputs: r
                    } = n, a = [], i = Object.keys(r).map((e => Wx(e)[0])).map((t => e.nodes[t])), o = e.initNodes;
                    i.forEach((e => {
                        s.has(e.name) && a.push(e)
                    })), e.weights.forEach((e => {
                        s.has(e.name) && a.push(e)
                    })), null != o && o.forEach((e => {
                        s.has(e.name) && a.push(e)
                    }));
                    const u = new Set,
                        l = [];
                    for (; a.length > 0;) {
                        const e = a.pop();
                        u.add(e.name), t[e.name] || l.push(e), e.children.forEach((e => {
                            !u.has(e.name) && s.has(e.name) && e.inputs.every((e => u.has(e.name))) && a.push(e)
                        }))
                    }
                    return l
                }(this.graph, this.weightMap, n)
            }
            execute(e, t) {
                e = this.mapInputs(e);
                const n = Object.keys(e).sort();
                this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);
                const s = n.map((e => this.graph.nodes[Wx(e)[0]])),
                    r = t.map((e => Wx(e)[0]));
                let a = r.map((e => this.graph.nodes[e]));
                this.resetIntermediateTensors(), 0 === a.length && (a = this._outputs);
                const i = this.getCompilationKey(s, a);
                let o = this.compiledMap.get(i);
                null == o && (o = this.compile(e, a), this.compiledMap.set(i, o));
                const u = {},
                    l = {};
                return yi((() => {
                    const n = new Qw(this.weightMap, u, l, this.functionExecutorMap),
                        s = Object.assign({}, this.weightMap);
                    Object.keys(e).forEach((t => {
                        const [n, r] = Wx(t), a = [];
                        a[r] = e[t], s[n] = a
                    }));
                    const a = this.getFrozenTensorIds(s),
                        i = {};
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e];
                        if (!s[t.name]) {
                            const e = Zw(t, s, n, this._resourceManager);
                            if (le(e)) throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);
                            s[t.name] = e, this.checkTensorForDisposal(t.name, t, s, n, a, r, i)
                        }
                    }
                    return null == this.parent && n.dispose(a), t.map((e => Bx(e, s, n)))
                }))
            }
            getFrozenTensorIds(e) {
                const t = [].concat.apply([], Object.keys(e).map((t => e[t])).map((e => e.map((e => e.id)))));
                return new Set(t)
            }
            checkTensorForDisposal(e, t, n, s, r, a, i) {
                "control" !== t.category && -1 === a.indexOf(e) && (n[e].forEach((e => {
                    null != e && (i[e.id] = (i[e.id] || 0) + t.children.length)
                })), t.inputs.forEach((e => {
                    if ("control" !== e.category) {
                        const a = function(e, t, n) {
                            return t[Ux(e, n.currentContextId)]
                        }(e.name, n, s);
                        null != a && a.forEach((e => {
                            if (e && !e.kept && !r.has(e.id)) {
                                const n = i[e.id];
                                if (1 === n) {
                                    if (this.keepTensorForDebug) {
                                        const [n, r] = Px(t.name, s);
                                        this.intermediateTensors[n] || (this.intermediateTensors[n] = []), this.intermediateTensors[n][r] = e
                                    } else e.dispose();
                                    delete i[e.id]
                                } else null != n && i[e.id]--
                            }
                        }))
                    }
                })))
            }
            async executeAsync(e, t) {
                return this._executeAsync(e, t)
            }
            disposeIntermediateTensors() {
                this.intermediateTensors && (Object.keys(this.intermediateTensors).forEach((e => this.intermediateTensors[e].forEach((e => e.dispose())))), this.disposeTensorsMap())
            }
            disposeTensorsMap() {
                this.tensorsMap && Object.keys(this.tensorsMap).forEach((e => {
                    this.tensorsMap[e].forEach((e => {
                        !e || e.kept || e.isDisposed || this.keepIds.has(e.id) || e.dispose()
                    }))
                }))
            }
            getIntermediateTensors() {
                return this.tensorsMap
            }
            resetIntermediateTensors() {
                for (const e in this.intermediateTensors) this.intermediateTensors[e].forEach((e => e.dispose())), delete this.intermediateTensors[e]
            }
            async _executeAsync(e, t, n = !1, s = {}, r = {}) {
                n || (e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t));
                try {
                    this.keepTensorForDebug = de().getBool("KEEP_INTERMEDIATE_TENSORS")
                } catch (e) {
                    console.warn(e.message)
                }
                this.resetIntermediateTensors();
                const a = new Qw(this.weightMap, s, r, this.functionExecutorMap);
                this.tensorsMap = await this.executeWithControlFlow(e, a, t, n);
                const i = t.map((e => Bx(e, this.tensorsMap, a))),
                    o = i.map((e => e.id)),
                    u = Object.keys(e).map((t => e[t].id));
                return this.keepIds = new Set([...o, ...u, ...this.weightIds]), this.keepTensorForDebug || this.disposeTensorsMap(), null == this.parent && a.dispose(this.keepIds), i
            }
            async executeFunctionAsync(e, t, n) {
                const s = e.reduce(((e, t, n) => (e[this.inputs[n].name] = t, e)), {});
                return this._executeAsync(s, this.outputNodes, !0, t, n)
            }
            async executeWithControlFlow(e, t, n, s) {
                const r = Object.keys(e),
                    a = r.map((e => this.graph.nodes[Wx(e)[0]])),
                    i = n.map((e => Wx(e)[0]));
                let o = i.map((e => this.graph.nodes[e]));
                0 === o.length && (o = this._outputs);
                const {
                    usedNodes: u,
                    missingInputs: l,
                    dynamicNode: c,
                    syncInputs: h
                } = ek(e, o, this.weightMap, this._initNodes), p = [...a, ...this.graph.weights, ...this._initNodes || []].map((e => ({
                    node: e,
                    contexts: t.currentContext
                }))), d = Object.assign({}, this.weightMap);
                Object.keys(e).forEach((t => {
                    const [n, s] = Wx(t), r = [];
                    r[s] = e[t], d[n] = r
                }));
                const f = {},
                    m = this.getFrozenTensorIds(d),
                    g = {};
                for (; p.length > 0;) {
                    const e = this.processStack(a, p, t, d, g, m, i, f, u);
                    await Promise.all(e)
                }
                null != c || s || console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
                const y = o.filter((e => !rk(e) && !Bx(e.name, d, t))).map((e => e.name));
                if (y.length > 0) {
                    let e = "";
                    throw null != c && (e = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`), new Error(`Cannot compute the outputs [${y}] from the provided inputs [${r}]. Consider providing the following inputs: [${l}]. ${e}`)
                }
                return d
            }
            processStack(e, t, n, s, r, a, i, o, u) {
                const l = [];
                for (; t.length > 0;) {
                    const e = t.pop();
                    n.currentContext = e.contexts;
                    let c = "";
                    if ("Enter" === e.node.op && zx("isConstant", e.node, s, n) && ([c] = Px(e.node.name, n)), null == s[e.node.name]) {
                        const h = Zw(e.node, s, n, this._resourceManager);
                        c || ([c] = Px(e.node.name, n));
                        const p = n.currentContext;
                        le(h) ? l.push(h.then((l => (s[c] = l, n.currentContext = p, this.checkTensorForDisposal(c, e.node, s, n, a, i, o), this.processChildNodes(e.node, t, n, s, r, u), l)))) : (s[c] = h, this.checkTensorForDisposal(c, e.node, s, n, a, i, o), this.processChildNodes(e.node, t, n, s, r, u))
                    } else this.processChildNodes(e.node, t, n, s, r, u)
                }
                return l
            }
            processChildNodes(e, t, n, s, r, a) {
                e.children.forEach((e => {
                    const [i] = Px(e.name, n);
                    !r[i] && a.has(e.name) && ("Merge" === e.op ? e.inputNames.some((e => !!Bx(e, s, n))) && (r[i] = !0, t.push({
                        contexts: n.currentContext,
                        node: e
                    })) : e.inputNames.every((e => !!Bx(e, s, n))) && (r[i] = !0, t.push({
                        contexts: n.currentContext,
                        node: e
                    })))
                }))
            }
            dispose() {
                Object.keys(this.weightMap).forEach((e => this.weightMap[e].forEach((e => e.dispose()))))
            }
            checkInputShapeAndType(e) {
                Object.keys(e).forEach((t => {
                    const n = e[t],
                        [s] = Wx(t),
                        r = this.graph.nodes[s];
                    if (r.attrParams.shape && r.attrParams.shape.value) {
                        const e = r.attrParams.shape.value;
                        R(e.length === n.shape.length && n.shape.every(((t, n) => -1 === e[n] || e[n] === t)), (() => `The shape of dict['${r.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))
                    }
                    r.attrParams.dtype && r.attrParams.dtype.value && R(n.dtype === r.attrParams.dtype.value, (() => `The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${n.dtype}`))
                }))
            }
            mapInputs(e) {
                const t = {};
                for (const n in e)
                    if (null != this._signature && null != this._signature.inputs && null != this._signature.inputs[n]) {
                        t[this._signature.inputs[n].name] = e[n]
                    } else t[n] = e[n];
                return t
            }
            checkInputs(e) {
                const t = Object.keys(e).filter((e => {
                    const [t] = Wx(e);
                    return null == this.graph.nodes[t]
                }));
                if (t.length > 0) throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)
            }
            mapOutputs(e) {
                return e.map((e => {
                    if (null != this._signature && null != this._signature.outputs && null != this._signature.outputs[e]) {
                        return this._signature.outputs[e].name
                    }
                    return e
                }), {})
            }
            checkOutputs(e) {
                e.forEach((e => {
                    const [t] = Wx(e);
                    if (!this.graph.nodes[t]) throw new Error(`The output '${e}' is not found in the graph`)
                }))
            }
        }
        class uk {
            constructor(e = {}, t = {}) {
                this.hashTableNameToHandle = e, this.hashTableMap = t
            }
            addHashTable(e, t) {
                this.hashTableNameToHandle[e] = t.handle, this.hashTableMap[t.id] = t
            }
            getHashTableHandleByName(e) {
                return this.hashTableNameToHandle[e]
            }
            getHashTableById(e) {
                return this.hashTableMap[e]
            }
            dispose() {
                for (const e in this.hashTableMap) this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
                for (const e in this.hashTableNameToHandle) this.hashTableNameToHandle[e].dispose(), delete this.hashTableNameToHandle[e]
            }
        }
        const lk = "?tfjs-format=file",
            ck = "model.json";
        class hk {
            constructor(e, t = {}) {
                this.modelUrl = e, this.loadOptions = t, this.version = "n/a", null == t && (this.loadOptions = {}), this.resourceManager = new uk
            }
            get modelVersion() {
                return this.version
            }
            get inputNodes() {
                return this.executor.inputNodes
            }
            get outputNodes() {
                return this.executor.outputNodes
            }
            get inputs() {
                return this.executor.inputs
            }
            get outputs() {
                return this.executor.outputs
            }
            get weights() {
                return this.executor.weightMap
            }
            get metadata() {
                return this.artifacts.userDefinedMetadata
            }
            get modelSignature() {
                return this.signature
            }
            findIOHandler() {
                const e = this.modelUrl;
                if (null != e.load) this.handler = e;
                else if (null != this.loadOptions.requestInit) this.handler = Ua(e, this.loadOptions);
                else {
                    const s = (t = e, n = this.loadOptions, ta.getLoadHandlers(t, n));
                    if (0 === s.length) s.push(Ua(e, this.loadOptions));
                    else if (s.length > 1) throw new Error(`Found more than one (${s.length}) load handlers for URL '${[e]}'`);
                    this.handler = s[0]
                }
                var t, n
            }
            load() {
                if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                const e = this.handler.load();
                return le(e) ? e.then((e => this.loadSync(e))) : this.loadSync(e)
            }
            loadSync(e) {
                this.artifacts = e;
                const t = this.artifacts.modelTopology;
                let n;
                n = null != this.artifacts.userDefinedMetadata && null != this.artifacts.userDefinedMetadata.signature ? this.artifacts.userDefinedMetadata.signature : this.artifacts.signature, this.signature = n, this.version = `${t.versions.producer}.${t.versions.minConsumer}`;
                const s = jr(this.artifacts.weightData, this.artifacts.weightSpecs);
                if (this.executor = new ok(cw.Instance.transformGraph(t, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(s), this.executor.resourceManager = this.resourceManager, null != e.modelInitializer && null != e.modelInitializer.node) {
                    const t = cw.Instance.transformGraph(e.modelInitializer);
                    this.initializer = new ok(t), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializer.executeAsync({}, [])
                }
                return !0
            }
            async save(e, t) {
                if ("string" == typeof e) {
                    const t = na(e);
                    if (0 === t.length) throw new Error(`Cannot find any save handlers for URL '${e}'`);
                    if (t.length > 1) throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);
                    e = t[0]
                }
                if (null == e.save) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                return e.save(this.artifacts)
            }
            predict(e, t) {
                return this.execute(e, this.outputNodes)
            }
            normalizeInputs(e) {
                if (!(e instanceof cr || Array.isArray(e))) return e;
                if ((e = Array.isArray(e) ? e : [e]).length !== this.inputNodes.length) throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);
                return this.inputNodes.reduce(((t, n, s) => (t[n] = e[s], t)), {})
            }
            normalizeOutputs(e) {
                return e = e || this.outputNodes, Array.isArray(e) ? e : [e]
            }
            execute(e, t) {
                e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
                const n = this.executor.execute(e, t);
                return n.length > 1 ? n : n[0]
            }
            async executeAsync(e, t) {
                e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
                const n = await this.executor.executeAsync(e, t);
                return n.length > 1 ? n : n[0]
            }
            getIntermediateTensors() {
                return this.executor.getIntermediateTensors()
            }
            disposeIntermediateTensors() {
                this.executor.disposeIntermediateTensors()
            }
            convertTensorMapToTensorsMap(e) {
                return Object.keys(e).reduce(((t, n) => (t[n] = [e[n]], t)), {})
            }
            dispose() {
                this.executor.dispose(), this.initializer && this.initializer.dispose(), this.resourceManager.dispose()
            }
        }
        async function pk(e, t = {}) {
            if (null == e) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
            null == t && (t = {}), t.fromTFHub && "string" == typeof e && (e = function(e) {
                e.endsWith("/") || (e += "/");
                return `${e}${ck}${lk}`
            }(e));
            const n = new hk(e, t);
            return await n.load(), n
        }
        var dk, fk = n(391);

        function mk(e, t, n = new Map, s = new Set) {
            if (null == e) return null;
            if ("function" == typeof Blob && e instanceof Blob) return e.slice();
            if (s.has(e)) throw new Error("Circular references are not supported.");
            if (n.has(e)) return n.get(e);
            const r = t(e);
            if (r.recurse && null !== r.value) throw new Error("A deep map function may not return both a value and recurse=true.");
            if (r.recurse) {
                if (xk(e)) {
                    const r = Array.isArray(e) ? [] : {};
                    s.add(e);
                    for (const a in e) {
                        const i = mk(e[a], t, n, s);
                        r[a] = i
                    }
                    return s.delete(e), e.__proto__ && (r.__proto__ = e.__proto__), r
                }
                throw new Error(`Can't recurse into non-iterable type: ${e}`)
            }
            return n.set(e, r.value), r.value
        }

        function gk(e, t = bk) {
            return yk(e, t)
        }

        function yk(e, t, n = new Set) {
            const s = e[0];
            if (n.has(s)) throw new Error("Circular references are not supported.");
            const r = t(e);
            if (r.recurse && null !== r.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
            if (r.recurse) {
                if (xk(s)) {
                    const r = Array.isArray(s) ? [] : {};
                    n.add(s);
                    for (const a in s) {
                        const s = yk(e.map((e => e[a])), t, n);
                        r[a] = s
                    }
                    return n.delete(s), r
                }
                throw new Error(`Can't recurse into non-iterable type: ${s}`)
            }
            return r.value
        }

        function bk(e) {
            return null === e ? null : xk(e[0]) ? {
                value: null,
                recurse: !0
            } : {
                value: e,
                recurse: !1
            }
        }

        function xk(e) {
            let t = !1;
            if (de().get("IS_BROWSER")) t = e instanceof TextDecoder;
            else {
                const {
                    StringDecoder: s
                } = n(551);
                t = e instanceof s
            }
            return null != e && !ArrayBuffer.isView(e) && (Array.isArray(e) || "object" == typeof e && !(e instanceof cr) && !(e instanceof Promise) && !t)
        }

        function wk(e) {
            return function(e, t) {
                return mk(e, t)
            }(e, kk)
        }

        function kk(e) {
            return e instanceof cr ? {
                value: e.clone(),
                recurse: !1
            } : xk(e) ? {
                value: null,
                recurse: !0
            } : {
                value: e,
                recurse: !1
            }
        }
        class vk {
            constructor(e) {
                if (this.capacity = e, this.begin = 0, this.end = 0, null == e) throw new RangeError("Can't create a ring buffer of unknown capacity.");
                if (e < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
                this.data = new Array(e), this.doubledCapacity = 2 * e
            }
            wrap(e) {
                for (; e < 0;) e += this.doubledCapacity;
                return e % this.doubledCapacity
            }
            get(e) {
                if (e < 0) throw new RangeError("Can't get item at a negative index.");
                return this.data[e % this.capacity]
            }
            set(e, t) {
                if (e < 0) throw new RangeError("Can't set item at a negative index.");
                this.data[e % this.capacity] = t
            }
            length() {
                let e = this.end - this.begin;
                return e < 0 && (e = this.doubledCapacity + e), e
            }
            isFull() {
                return this.length() === this.capacity
            }
            isEmpty() {
                return 0 === this.length()
            }
            push(e) {
                if (this.isFull()) throw new RangeError("Ring buffer is full.");
                this.set(this.end, e), this.end = this.wrap(this.end + 1)
            }
            pushAll(e) {
                for (const t of e) this.push(t)
            }
            pop() {
                if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                this.end = this.wrap(this.end - 1);
                const e = this.get(this.end);
                return this.set(this.end, void 0), e
            }
            unshift(e) {
                if (this.isFull()) throw new RangeError("Ring buffer is full.");
                this.begin = this.wrap(this.begin - 1), this.set(this.begin, e)
            }
            shift() {
                if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                const e = this.get(this.begin);
                return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), e
            }
            shuffleExcise(e) {
                if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                const t = this.wrap(this.begin + e),
                    n = this.get(t);
                return this.set(t, this.pop()), n
            }
        }
        class Ik extends vk {
            constructor() {
                super(Ik.INITIAL_CAPACITY)
            }
            isFull() {
                return !1
            }
            push(e) {
                super.isFull() && this.expand(), super.push(e)
            }
            unshift(e) {
                super.isFull() && this.expand(), super.unshift(e)
            }
            expand() {
                const e = 2 * this.capacity,
                    t = new Array(e),
                    n = this.length();
                for (let e = 0; e < n; e++) t[e] = this.get(this.wrap(this.begin + e));
                this.data = t, this.capacity = e, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n
            }
        }

        function Nk(e) {
            return new Ck(e)
        }

        function Sk(e, t) {
            return new Bk(e, t)
        }
        Ik.INITIAL_CAPACITY = 32;
        class Tk {
            async toArray() {
                const e = [];
                let t = await this.next();
                for (; !t.done;) e.push(t.value), t = await this.next();
                return e
            }
            async toArrayForTest() {
                const e = this.prefetch(100),
                    t = [];
                let n = await e.next();
                for (; !n.done;) t.push(n.value), n = await e.next();
                return t
            }
            async resolveFully() {
                let e = await this.next();
                for (; !e.done;) e = await this.next()
            }
            async resolveWhile(e) {
                let t = await this.next(),
                    n = e(t.value);
                for (; !t.done && n;) t = await this.next(), n = e(t.value)
            }
            handleErrors(e) {
                return new Ok(this, e)
            }
            filter(e) {
                return new Dk(this, e)
            }
            map(e) {
                return new _k(this, e)
            }
            mapAsync(e) {
                return new Mk(this, e)
            }
            serialMapAsync(e) {
                return new Mk(this, e).serial()
            }
            flatmap(e) {
                return new zk(this, e)
            }
            async forEachAsync(e) {
                return this.map(e).resolveFully()
            }
            async serialForEach(e) {
                return this.serialMapAsync(e).resolveWhile((e => !0 === e))
            }
            rowMajorBatch(e, t = !0) {
                return new Fk(this, e, t)
            }
            columnMajorBatch(e, t = !0, n = bk) {
                return this.rowMajorBatch(e, t).map((e => gk(e, n)))
            }
            concatenate(e, t) {
                return new Bk(new $k([this, e]), t)
            }
            take(e) {
                return e < 0 || null == e ? this : new Rk(this, e)
            }
            skip(e) {
                return e < 0 || null == e ? this : new Ak(this, e)
            }
            prefetch(e) {
                return new Pk(this, e)
            }
            shuffle(e, t) {
                return new Uk(this, e, t)
            }
            serial() {
                return new Ek(this)
            }
        }
        class $k extends Tk {
            constructor(e) {
                super(), this.items = e, this.trav = 0
            }
            summary() {
                return `Array of ${this.items.length} items`
            }
            async next() {
                if (this.trav >= this.items.length) return {
                    value: null,
                    done: !0
                };
                const e = this.items[this.trav];
                return this.trav++, {
                    value: wk(e),
                    done: !1
                }
            }
        }
        class Ck extends Tk {
            constructor(e) {
                super(), this.nextFn = e
            }
            summary() {
                return "Function call"
            }
            async next() {
                try {
                    return this.nextFn()
                } catch (e) {
                    throw e.message = `Error thrown while iterating through a dataset: ${e.message}`, e
                }
            }
        }
        class Ek extends Tk {
            constructor(e) {
                super(), this.upstream = e, this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            summary() {
                return `${this.upstream.summary()} -> Serial`
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            async serialNext() {
                return this.upstream.next()
            }
        }
        class Ak extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.maxCount = t, this.count = 0, this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            summary() {
                return `${this.upstream.summary()} -> Skip`
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            async serialNext() {
                for (; this.count++ < this.maxCount;) {
                    const e = await this.upstream.next();
                    if (e.done) return e;
                    bi(e.value)
                }
                return this.upstream.next()
            }
        }
        class Rk extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.maxCount = t, this.count = 0
            }
            summary() {
                return `${this.upstream.summary()} -> Take`
            }
            async next() {
                return this.count++ >= this.maxCount ? {
                    value: null,
                    done: !0
                } : this.upstream.next()
            }
        }
        class Fk extends Tk {
            constructor(e, t, n = !0) {
                super(), this.upstream = e, this.batchSize = t, this.enableSmallLastBatch = n, this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            summary() {
                return `${this.upstream.summary()} -> RowMajorBatch`
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            async serialNext() {
                const e = [];
                for (; e.length < this.batchSize;) {
                    const t = await this.upstream.next();
                    if (t.done) return this.enableSmallLastBatch && e.length > 0 ? {
                        value: e,
                        done: !1
                    } : {
                        value: null,
                        done: !0
                    };
                    e.push(t.value)
                }
                return {
                    value: e,
                    done: !1
                }
            }
        }
        class Dk extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.predicate = t, this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            summary() {
                return `${this.upstream.summary()} -> Filter`
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            async serialNext() {
                for (;;) {
                    const e = await this.upstream.next();
                    if (e.done || this.predicate(e.value)) return e;
                    bi(e.value)
                }
            }
        }
        class _k extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.transform = t
            }
            summary() {
                return `${this.upstream.summary()} -> Map`
            }
            async next() {
                const e = await this.upstream.next();
                if (e.done) return {
                    value: null,
                    done: !0
                };
                const t = Ir(e.value),
                    n = this.transform(e.value),
                    s = Ir(n);
                for (const e of t) vr(e, s) || e.dispose();
                return {
                    value: n,
                    done: !1
                }
            }
        }
        class Ok extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.handler = t, this.count = 0, this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            summary() {
                return `${this.upstream.summary()} -> handleErrors`
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            async serialNext() {
                for (;;) try {
                    return await this.upstream.next()
                } catch (e) {
                    if (!this.handler(e)) return {
                        value: null,
                        done: !0
                    }
                }
            }
        }
        class Mk extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.transform = t
            }
            summary() {
                return `${this.upstream.summary()} -> AsyncMap`
            }
            async next() {
                const e = await this.upstream.next();
                if (e.done) return {
                    value: null,
                    done: !0
                };
                const t = Ir(e.value),
                    n = await this.transform(e.value),
                    s = Ir(n);
                for (const e of t) vr(e, s) || e.dispose();
                return {
                    value: n,
                    done: !1
                }
            }
        }
        class Lk extends Tk {
            constructor() {
                super(), this.outputQueue = new Ik, this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            async serialNext() {
                for (; 0 === this.outputQueue.length();)
                    if (!await this.pump()) return {
                        value: null,
                        done: !0
                    };
                return {
                    value: this.outputQueue.shift(),
                    done: !1
                }
            }
        }
        class zk extends Lk {
            constructor(e, t) {
                super(), this.upstream = e, this.transform = t
            }
            summary() {
                return `${this.upstream.summary()} -> Flatmap`
            }
            async pump() {
                const e = await this.upstream.next();
                if (e.done) return !1;
                const t = Ir(e.value),
                    n = this.transform(e.value),
                    s = Ir(n);
                this.outputQueue.pushAll(n);
                for (const e of t) vr(e, s) || e.dispose();
                return !0
            }
        }
        class Bk extends Tk {
            constructor(e, t) {
                super(), this.baseErrorHandler = t, this.lastRead = null, this.iterator = null, this.moreIterators = e
            }
            summary() {
                return "TODO: fill in upstream of chained summaries -> Chained"
            }
            async next() {
                return this.lastRead = this.readFromChain(this.lastRead), this.lastRead
            }
            async readFromChain(e) {
                if (await e, null == this.iterator) {
                    const e = await this.moreIterators.next();
                    if (e.done) return {
                        value: null,
                        done: !0
                    };
                    this.iterator = e.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler))
                }
                const t = await this.iterator.next();
                return t.done ? (this.iterator = null, this.readFromChain(e)) : t
            }
        }! function(e) {
            e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST"
        }(dk || (dk = {}));
        class Pk extends Tk {
            constructor(e, t) {
                super(), this.upstream = e, this.bufferSize = t, this.buffer = new vk(t)
            }
            summary() {
                return `${this.upstream.summary()} -> Prefetch`
            }
            refill() {
                for (; !this.buffer.isFull();) {
                    const e = this.upstream.next();
                    this.buffer.push(e)
                }
            }
            next() {
                return this.refill(), this.buffer.shift()
            }
        }
        class Uk extends Pk {
            constructor(e, t, n) {
                super(e, t), this.upstream = e, this.windowSize = t, this.upstreamExhausted = !1, this.random = fk.alea(n || Xs().toString()), this.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                })
            }
            async next() {
                return this.lastRead = this.lastRead.then((() => this.serialNext())), this.lastRead
            }
            randomInt(e) {
                return Math.floor(this.random() * e)
            }
            chooseIndex() {
                return this.randomInt(this.buffer.length())
            }
            async serialNext() {
                for (this.upstreamExhausted || this.refill(); !this.buffer.isEmpty();) {
                    const e = this.chooseIndex(),
                        t = await this.buffer.shuffleExcise(e);
                    if (!t.done) return this.refill(), t;
                    this.upstreamExhausted = !0
                }
                return {
                    value: null,
                    done: !0
                }
            }
        }
        class Wk {
            constructor() {
                this.size = null
            }
            batch(e, t = !0) {
                const n = this;
                let s;
                return R(e > 0, (() => `batchSize needs to be positive, but it is\n      ${e}`)), s = this.size === 1 / 0 || null == this.size ? this.size : t ? Math.ceil(this.size / e) : Math.floor(this.size / e), Vk((async () => (await n.iterator()).columnMajorBatch(e, t, Gk)), s)
            }
            concatenate(e) {
                const t = this;
                let n;
                return n = this.size === 1 / 0 || e.size === 1 / 0 ? 1 / 0 : null != this.size && null != e.size ? this.size + e.size : null, Vk((async () => (await t.iterator()).concatenate(await e.iterator())), n)
            }
            filter(e) {
                const t = this;
                let n;
                return n = this.size === 1 / 0 ? 1 / 0 : null, Vk((async () => (await t.iterator()).filter((t => yi((() => e(t)))))), n)
            }
            async forEachAsync(e) {
                return (await this.iterator()).forEachAsync(e)
            }
            map(e) {
                const t = this;
                return Vk((async () => (await t.iterator()).map((t => yi((() => e(t)))))), this.size)
            }
            mapAsync(e) {
                const t = this;
                return Vk((async () => (await t.iterator()).mapAsync(e)), this.size)
            }
            prefetch(e) {
                if (null == e) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
                const t = this;
                return Vk((async () => (await t.iterator()).prefetch(e)), this.size)
            }
            repeat(e) {
                const t = this;
                let n;
                return n = null != this.size && e > 0 ? this.size * e : 0 === e ? 0 : null != this.size && (void 0 === e || e < 0) ? 1 / 0 : null, Vk((async () => Sk(Nk((async () => ({
                    value: await t.iterator(),
                    done: !1
                }))).take(e))), n)
            }
            skip(e) {
                const t = this;
                let n;
                return n = null != this.size && e >= 0 && this.size >= e ? this.size - e : null != this.size && (this.size < e || void 0 === e || e < 0) ? 0 : null, Vk((async () => (await t.iterator()).skip(e)), n)
            }
            shuffle(e, t, n = !0) {
                if (null == e || e < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
                const s = this,
                    r = fk.alea(t || Xs().toString());
                return Vk((async () => {
                    let t = r.int32();
                    return n && (t += r.int32()), (await s.iterator()).shuffle(e, t.toString())
                }), this.size)
            }
            take(e) {
                const t = this;
                let n;
                return n = null != this.size && this.size > e ? e : null != this.size && this.size <= e ? this.size : null, Vk((async () => (await t.iterator()).take(e)), n)
            }
            async toArray() {
                if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
                return (await this.iterator()).toArray()
            }
            async toArrayForTest() {
                if (this.size === 1 / 0) throw new Error("Can not convert infinite data stream to array.");
                return (await this.iterator()).toArrayForTest()
            }
        }

        function Vk(e, t = null) {
            return new class extends Wk {
                constructor() {
                    super(...arguments), this.size = t
                }
                async iterator() {
                    return e()
                }
            }
        }

        function Gk(e) {
            if (null === e) return null;
            const t = e[0];
            if (null == (n = t) || null === (s = n) || "object" != typeof s && "function" != typeof s || Array.isArray(n) || "object" == typeof n && n instanceof cr || q(n)) {
                return {
                    value: function(e) {
                        if (0 === e.length) throw new Error("Can't make a batch of zero elements.");
                        return e[0] instanceof cr ? Iu(e) : Vr(e)
                    }(e),
                    recurse: !1
                }
            }
            var n, s;
            return {
                value: null,
                recurse: !0
            }
        }
        Wk.MAX_BUFFER_SIZE = 1e4;
        Symbol("out"), Symbol("field"), Symbol("quote"), Symbol("quoteafterquote"), Symbol("quoteinquote");

        function Hk(e, t) {
            Array.isArray(e) || (e = [e]), e.forEach((e => {
                null != e && R("complex64" !== e.dtype, (() => `${t} does not support complex64 tensors in the CPU backend.`))
            }))
        }
        const jk = gh;
        class qk extends S {
            constructor() {
                super(), this.blockSize = 48, this.firstUse = !0, this.data = new N(this, mi())
            }
            nextDataId() {
                return qk.nextDataId++
            }
            write(e, t, n) {
                this.firstUse && (this.firstUse = !1, de().get("IS_NODE") && Is("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));
                const s = {
                    id: this.nextDataId()
                };
                return this.data.set(s, {
                    values: e,
                    dtype: n,
                    refCount: 1
                }), s
            }
            makeTensorInfo(e, t, n) {
                let s;
                if ("string" === t && null != n && n.length > 0 && X(n[0])) {
                    const r = n.map((e => Ys(e)));
                    s = this.write(r, e, t)
                } else s = this.write(n, e, t);
                return {
                    dataId: s,
                    shape: e,
                    dtype: t
                }
            }
            refCount(e) {
                if (this.data.has(e)) {
                    return this.data.get(e).refCount
                }
                return 0
            }
            incRef(e) {
                this.data.get(e).refCount++
            }
            decRef(e) {
                if (this.data.has(e)) {
                    this.data.get(e).refCount--
                }
            }
            move(e, t, n, s, r) {
                this.data.set(e, {
                    values: t,
                    dtype: s,
                    refCount: r
                })
            }
            numDataIds() {
                return this.data.numDataIds()
            }
            async read(e) {
                return this.readSync(e)
            }
            readSync(e) {
                const {
                    dtype: t,
                    complexTensorInfos: n
                } = this.data.get(e);
                if ("complex64" === t) {
                    return _c(this.readSync(n.real.dataId), this.readSync(n.imag.dataId))
                }
                return this.data.get(e).values
            }
            bufferSync(e) {
                const t = this.readSync(e.dataId);
                if ("string" === e.dtype) try {
                    const n = t.map((e => Js(e)));
                    return Aa(e.shape, e.dtype, n)
                } catch (e) {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
                return Aa(e.shape, e.dtype, t)
            }
            makeOutput(e, t, n) {
                return mi().makeTensorFromTensorInfo(this.makeTensorInfo(t, n, e), this)
            }
            disposeData(e, t = !1) {
                if (this.data.has(e)) {
                    if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return !1;
                    const {
                        complexTensorInfos: n
                    } = this.data.get(e);
                    null != n && (this.disposeData(n.real.dataId, !0), this.disposeData(n.imag.dataId, !0)), this.data.delete(e)
                }
                return !0
            }
            disposeIntermediateTensorInfo(e) {
                this.disposeData(e.dataId)
            }
            async time(e) {
                const t = Xs();
                e();
                return {
                    kernelMs: Xs() - t
                }
            }
            memory() {
                return {
                    unreliable: !0,
                    reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
                }
            }
            where(e) {
                Hk([e], "where");
                const t = this.readSync(e.dataId);
                return jk(e.shape, t)
            }
            dispose() {}
            floatPrecision() {
                return 32
            }
            epsilon() {
                return super.epsilon()
            }
        }
        qk.nextDataId = 0;

        function Kk(e, t, n) {
            return ({
                inputs: s,
                attrs: r,
                backend: a
            }) => {
                const {
                    x: i
                } = s;
                if (Hk(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
                const o = a,
                    u = o.data.get(i.dataId).values,
                    l = O(i.shape),
                    c = n || i.dtype,
                    h = H(c, l);
                for (let e = 0; e < l; ++e) h[e] = t(u[e], r);
                return o.makeTensorInfo(i.shape, c, h)
            }
        }

        function Xk(e, t, n) {
            return ({
                inputs: s,
                attrs: r,
                backend: a
            }) => {
                const {
                    x: i
                } = s;
                if (Hk(i, e), "string" === i.dtype || "string" === n) throw new Error("unaryKernelFunc does not support string input/output");
                const o = a,
                    u = o.data.get(i.dataId).values,
                    l = n || i.dtype,
                    c = t(u, l, r);
                return o.makeTensorInfo(i.shape, l, c)
            }
        }
        wi("cpu", (() => new qk), 1);
        const Yk = Kk(ft, (e => e >= 0 ? e : Math.exp(e) - 1)),
            Jk = {
                kernelName: ft,
                backendName: "cpu",
                kernelFunc: Yk
            };

        function Zk(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                x: s
            } = t;
            return n.incRef(s.dataId), {
                dataId: s.dataId,
                shape: s.shape,
                dtype: s.dtype
            }
        }
        const Qk = {
            kernelName: Rt,
            backendName: "cpu",
            kernelFunc: Zk
        };

        function ev(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                alpha: a
            } = s;
            Hk([r], "leakyRelu");
            const i = O(r.shape),
                o = n.data.get(r.dataId).values,
                u = G("float32", i);
            for (let e = 0; e < o.length; e++) u[e] = o[e] < 0 ? a * o[e] : o[e];
            return n.makeTensorInfo(r.shape, "float32", u)
        }
        const tv = {
            kernelName: Lt,
            backendName: "cpu",
            kernelFunc: ev
        };

        function nv(e) {
            return (t, n, s, r, a) => {
                const i = Ga(t, n),
                    o = i.length,
                    u = ee(i),
                    l = G(a, O(i)),
                    c = t.length,
                    h = n.length,
                    p = ee(t),
                    d = ee(n),
                    f = Wa(t, i),
                    m = Wa(n, i);
                if (f.length + m.length === 0)
                    for (let t = 0; t < l.length; ++t) l[t] = e(s[t % s.length], r[t % r.length]);
                else
                    for (let t = 0; t < l.length; ++t) {
                        const n = ue(t, o, u),
                            a = n.slice(-c);
                        f.forEach((e => a[e] = 0));
                        const i = oe(a, c, p),
                            g = n.slice(-h);
                        m.forEach((e => g[e] = 0));
                        const y = oe(g, h, d);
                        l[t] = e(s[i], r[y])
                    }
                return [l, i]
            }
        }
        const sv = nv(((e, t) => e < 0 ? t * e : e));

        function rv(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                x: s,
                alpha: r
            } = t;
            Hk([s, r], "prelu");
            const a = n.data.get(s.dataId).values,
                i = n.data.get(r.dataId).values,
                [o, u] = sv(s.shape, r.shape, a, i, "float32");
            return n.makeTensorInfo(u, "float32", o)
        }
        const av = {
                kernelName: xn,
                backendName: "cpu",
                kernelFunc: rv
            },
            iv = Kk(Nn, (e => Math.max(0, e))),
            ov = {
                kernelName: Nn,
                backendName: "cpu",
                kernelFunc: iv
            },
            uv = Kk(An, (e => Math.min(Math.max(0, e), 6))),
            lv = {
                kernelName: An,
                backendName: "cpu",
                kernelFunc: uv
            };

        function cv(e) {
            return (t, n, s) => {
                const r = G(n, t.length);
                for (let n = 0; n < t.length; ++n) r[n] = e(t[n], s);
                return r
            }
        }
        const hv = cv((e => 1 / (1 + Math.exp(-e)))),
            pv = Kk(Wn, (e => 1 / (1 + Math.exp(-e)))),
            dv = {
                kernelName: Wn,
                backendName: "cpu",
                kernelFunc: pv
            };

        function fv(e, t, n, s, r) {
            if ("linear" === n) return Zk({
                inputs: {
                    x: t
                },
                backend: e
            });
            if ("relu" === n) return iv({
                inputs: {
                    x: t
                },
                backend: e
            });
            if ("elu" === n) return Yk({
                inputs: {
                    x: t
                },
                backend: e
            });
            if ("relu6" === n) return uv({
                inputs: {
                    x: t
                },
                backend: e
            });
            if ("prelu" === n) return rv({
                inputs: {
                    x: t,
                    alpha: s
                },
                backend: e
            });
            if ("leakyrelu" === n) return ev({
                inputs: {
                    x: t
                },
                backend: e,
                attrs: {
                    alpha: r
                }
            });
            if ("sigmoid" === n) return pv({
                inputs: {
                    x: t
                },
                backend: e
            });
            throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)
        }

        function mv(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                real: s,
                imag: r
            } = t, a = n.data.get(s.dataId).values, i = n.data.get(r.dataId).values, o = n.makeTensorInfo(s.shape, "complex64");
            return n.data.get(o.dataId).complexTensorInfos = {
                real: n.makeTensorInfo(s.shape, "float32", a),
                imag: n.makeTensorInfo(r.shape, "float32", i)
            }, o
        }
        const gv = {
            kernelName: Ve,
            backendName: "cpu",
            kernelFunc: mv
        };

        function yv(e, t, n = "float32") {
            if ("complex64" === n) {
                return mv({
                    inputs: {
                        real: yv(e, t, "float32"),
                        imag: yv(e, t, "float32")
                    },
                    backend: e
                })
            }
            const s = re(O(t), n);
            return e.makeTensorInfo(t, n, s)
        }

        function bv(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                input: s
            } = t, r = n.data.get(s.dataId).complexTensorInfos.real, a = n.data.get(r.dataId).values;
            return n.makeTensorInfo(r.shape, r.dtype, a)
        }
        const xv = {
            kernelName: vn,
            backendName: "cpu",
            kernelFunc: bv
        };

        function wv(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                dtype: a
            } = s;
            if ("complex64" === a) {
                if ("complex64" === r.dtype) return Zk({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                const e = yv(n, r.shape, r.dtype),
                    t = wv({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            dtype: "float32"
                        }
                    }),
                    s = mv({
                        inputs: {
                            real: t,
                            imag: e
                        },
                        backend: n
                    });
                return n.disposeIntermediateTensorInfo(e), n.disposeIntermediateTensorInfo(t), s
            }
            if ("complex64" === r.dtype) {
                const e = bv({
                        inputs: {
                            input: r
                        },
                        backend: n
                    }),
                    t = wv({
                        inputs: {
                            x: e
                        },
                        backend: n,
                        attrs: {
                            dtype: a
                        }
                    });
                return n.disposeIntermediateTensorInfo(e), t
            }
            if (!j(r.dtype, a)) {
                const e = Zk({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                return {
                    dataId: e.dataId,
                    shape: e.shape,
                    dtype: a
                }
            }
            if ("int32" === a) {
                const e = n.data.get(r.dataId).values,
                    t = Int32Array.from(e);
                return n.makeTensorInfo(r.shape, "int32", t)
            }
            if ("bool" === a) {
                const e = n.data.get(r.dataId).values,
                    t = Ks([0], r.dtype),
                    [s, a] = nv(((e, t) => e !== t ? 1 : 0))(r.shape, [], e, t, "bool");
                return n.makeTensorInfo(a, "bool", s)
            }
            throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)
        }
        const kv = {
            kernelName: Pe,
            backendName: "cpu",
            kernelFunc: wv
        };

        function vv(e, t, n, s) {
            return null == n ? ({
                inputs: n,
                backend: r
            }) => {
                const {
                    a,
                    b: i
                } = n, o = r;
                Hk([a, i], e);
                const u = o.data.get(a.dataId).values,
                    l = o.data.get(i.dataId).values,
                    c = "string" === a.dtype ? fh(u) : u,
                    h = "string" === a.dtype ? fh(l) : l,
                    p = s || a.dtype,
                    [d, f] = t(a.shape, i.shape, c, h, p);
                return o.makeTensorInfo(f, p, d)
            } : ({
                inputs: e,
                backend: r
            }) => {
                const {
                    a,
                    b: i
                } = e, o = r;
                if ("complex64" === a.dtype || "complex64" === i.dtype) {
                    const e = wv({
                            inputs: {
                                x: a
                            },
                            backend: o,
                            attrs: {
                                dtype: "complex64"
                            }
                        }),
                        t = o.data.get(e.dataId),
                        s = t.complexTensorInfos.real,
                        r = t.complexTensorInfos.imag,
                        u = o.data.get(s.dataId).values,
                        l = o.data.get(r.dataId).values,
                        c = wv({
                            inputs: {
                                x: i
                            },
                            backend: o,
                            attrs: {
                                dtype: "complex64"
                            }
                        }),
                        h = o.data.get(c.dataId),
                        p = h.complexTensorInfos.real,
                        d = h.complexTensorInfos.imag,
                        f = o.data.get(p.dataId).values,
                        m = o.data.get(d.dataId).values,
                        [g, y, b] = n(a.shape, i.shape, u, l, f, m),
                        x = o.makeTensorInfo(b, "float32", g),
                        w = o.makeTensorInfo(b, "float32", y),
                        k = mv({
                            inputs: {
                                real: x,
                                imag: w
                            },
                            backend: o
                        });
                    return o.disposeIntermediateTensorInfo(e), o.disposeIntermediateTensorInfo(c), o.disposeIntermediateTensorInfo(x), o.disposeIntermediateTensorInfo(w), k
                } {
                    const e = o.data.get(a.dataId).values,
                        n = o.data.get(i.dataId).values,
                        r = s || a.dtype,
                        [u, l] = t(a.shape, i.shape, e, n, r);
                    return o.makeTensorInfo(l, r, u)
                }
            }
        }

        function Iv(e) {
            return (t, n, s, r, a, i) => {
                const o = Ga(t, n),
                    u = O(o),
                    l = o.length,
                    c = ee(o),
                    h = G("float32", u),
                    p = G("float32", u),
                    d = Wa(t, o),
                    f = Wa(n, o),
                    m = _c(s, r),
                    g = _c(a, i),
                    y = t.length,
                    b = ee(t),
                    x = n.length,
                    w = ee(n);
                if (d.length + f.length === 0)
                    for (let t = 0; t < h.length; t++) {
                        const n = t % m.length,
                            s = t % g.length,
                            r = e(m[2 * n], m[2 * n + 1], g[2 * s], g[2 * s + 1]);
                        h[t] = r.real, p[t] = r.imag
                    } else
                        for (let t = 0; t < h.length; t++) {
                            const n = ue(t, l, c),
                                s = n.slice(-y);
                            d.forEach((e => s[e] = 0));
                            const r = oe(s, y, b),
                                a = n.slice(-x);
                            f.forEach((e => a[e] = 0));
                            const i = oe(a, x, w),
                                o = e(m[2 * r], m[2 * r + 1], g[2 * i], g[2 * i + 1]);
                            h[t] = o.real, p[t] = o.imag
                        }
                return [h, p, o]
            }
        }
        const Nv = nv(((e, t) => e + t)),
            Sv = Iv(((e, t, n, s) => ({
                real: e + n,
                imag: t + s
            }))),
            Tv = vv(ke, Nv, Sv),
            $v = {
                kernelName: ke,
                backendName: "cpu",
                kernelFunc: Tv
            };

        function Cv(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                shape: a
            } = s, i = O(r.shape), o = U(a, i), u = O(o);
            R(i === u, (() => `The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)), n.incRef(r.dataId);
            const l = n.data.get(r.dataId);
            if (null != l.complexTensorInfos) {
                const e = l.complexTensorInfos.real,
                    t = l.complexTensorInfos.imag;
                e.shape = o, t.shape = o
            }
            return {
                dataId: r.dataId,
                shape: o,
                dtype: r.dtype
            }
        }
        const Ev = {
            kernelName: Sn,
            backendName: "cpu",
            kernelFunc: Cv
        };

        function Av(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                a: r,
                b: a
            } = t, {
                transposeA: i,
                transposeB: o
            } = s;
            Hk([r, a], "matMul");
            const u = r.shape.length,
                l = a.shape.length,
                c = i ? r.shape[u - 2] : r.shape[u - 1],
                h = o ? a.shape[l - 1] : a.shape[l - 2],
                p = i ? r.shape[u - 1] : r.shape[u - 2],
                d = o ? a.shape[l - 2] : a.shape[l - 1],
                f = r.shape.slice(0, -2),
                m = a.shape.slice(0, -2),
                g = O(f),
                y = O(m),
                b = Ga(r.shape.slice(0, -2), a.shape.slice(0, -2)).concat([p, d]);
            R(c === h, (() => `Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));
            const x = o ? [y, d, h] : [y, h, d],
                w = Cv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: i ? [g, c, p] : [g, p, c]
                    }
                }),
                k = Cv({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        shape: x
                    }
                }),
                v = i ? w.shape[1] : w.shape[2],
                I = i ? w.shape[2] : w.shape[1],
                N = o ? k.shape[1] : k.shape[2],
                S = Math.max(g, y),
                T = n.data.get(w.dataId).values,
                $ = n.data.get(k.dataId).values,
                C = ee(w.shape),
                E = ee(k.shape),
                [A, F, D] = i ? [C[0], 1, C[1]] : [C[0], C[1], 1],
                [_, M, L] = o ? [1, E[1], E[0]] : [E[1], 1, E[0]],
                z = I * N,
                B = Aa([S, I, N], w.dtype),
                P = B.values,
                U = n.blockSize;
            for (let e = 0; e < S; e++)
                for (let t = 0; t < I; t += U)
                    for (let n = 0; n < N; n += U)
                        for (let s = 0; s < v; s += U) {
                            const r = Math.min(t + U, I),
                                a = Math.min(n + U, N),
                                i = Math.min(s + U, v);
                            for (let o = t; o < r; o++)
                                for (let t = n; t < a; t++) {
                                    let n = 0;
                                    for (let r = s; r < i; r++) {
                                        const s = Math.min(e, g - 1) * A,
                                            a = Math.min(e, y - 1) * L;
                                        n += T[s + o * F + r * D] * $[r * _ + t * M + a]
                                    }
                                    P[e * z + (o * N + t)] += n
                                }
                        }
            return n.disposeIntermediateTensorInfo(w), n.disposeIntermediateTensorInfo(k), n.makeTensorInfo(b, B.dtype, B.values)
        }
        const Rv = {
            kernelName: Me,
            backendName: "cpu",
            kernelFunc: Av
        };
        const Fv = {
            kernelName: ws,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    a: r,
                    b: a,
                    bias: i,
                    preluActivationWeights: o
                } = t, {
                    transposeA: u,
                    transposeB: l,
                    activation: c,
                    leakyreluAlpha: h
                } = s;
                let p, d, f;
                const m = [];
                p = Av({
                    inputs: {
                        a: r,
                        b: a
                    },
                    attrs: {
                        transposeA: u,
                        transposeB: l
                    },
                    backend: n
                }), i && (d = Tv({
                    inputs: {
                        a: p,
                        b: i
                    },
                    backend: n
                }), m.push(p), p = d), c && (f = fv(n, p, c, o, h), m.push(p), p = f);
                for (const e of m) n.disposeIntermediateTensorInfo(e);
                return p
            }
        };

        function Dv(e) {
            const t = new Float32Array(e.length);
            for (let n = 0; n < e.length; ++n) t[n] = Math.abs(e[n]);
            return t
        }
        const _v = {
                kernelName: be,
                backendName: "cpu",
                kernelFunc: e => {
                    const {
                        x: t
                    } = e.inputs, n = e.backend;
                    Hk(t, "abs");
                    let s = new Float32Array(O(t.shape));
                    return s = Dv(n.data.get(t.dataId).values), n.makeOutput(s, t.shape, t.dtype)
                }
            },
            Ov = Kk(xe, (e => Math.acos(e))),
            Mv = {
                kernelName: xe,
                backendName: "cpu",
                kernelFunc: Ov
            },
            Lv = Kk(we, (e => Math.acosh(e))),
            zv = {
                kernelName: we,
                backendName: "cpu",
                kernelFunc: Lv
            };
        const Bv = {
            kernelName: ve,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, s = t;
                Hk(t, "addN");
                const r = s.map((e => n.data.get(e.dataId).values)),
                    a = Aa(s[0].shape, s[0].dtype),
                    i = a.values;
                for (let e = 0; e < s.length; e++) {
                    const t = r[e];
                    for (let e = 0; e < i.length; e++) i[e] += t[e]
                }
                return n.makeTensorInfo(a.shape, a.dtype, a.values)
            }
        };

        function Pv(e, t, n, s, r) {
            const a = t.length,
                i = O(t),
                o = ee(t),
                u = ee(r),
                l = G(n, O(r));
            for (let t = 0; t < i; ++t) {
                const n = ue(t, a, o),
                    r = new Array(n.length);
                for (let e = 0; e < r.length; e++) r[e] = n[s[e]];
                l[oe(r, a, u)] = e[t]
            }
            return l
        }

        function Uv(e) {
            const {
                inputs: t,
                attrs: n,
                backend: s
            } = e, {
                x: r
            } = t, {
                perm: a
            } = n;
            Hk(r, "transpose");
            const i = r.shape.length,
                o = new Array(i);
            for (let e = 0; e < o.length; e++) o[e] = r.shape[a[e]];
            const u = Pv(s.data.get(r.dataId).values, r.shape, r.dtype, a, o);
            return {
                dataId: s.write(u, o, r.dtype),
                shape: o,
                dtype: r.dtype
            }
        }
        const Wv = {
            kernelName: ps,
            backendName: "cpu",
            kernelFunc: Uv
        };
        const Vv = {
            kernelName: Ie,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    keepDims: i
                } = s;
                Hk(r, "all");
                const o = W(a, r.shape);
                let u = o;
                const l = Go(u, r.shape.length);
                let c = r;
                null != l && (c = Uv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), u = jo(u.length, r.shape.length)), Vo("all", u, c.shape.length);
                const [h, p] = Uo(c.shape, u), d = O(p), f = re(O(h), c.dtype), m = n.data.get(c.dataId).values;
                for (let e = 0; e < f.length; ++e) {
                    const t = e * d;
                    let n = m[t];
                    for (let e = 0; e < d; ++e) {
                        const s = m[t + e];
                        n = n && s
                    }
                    f[e] = n
                }
                null != l && n.disposeIntermediateTensorInfo(c);
                const g = n.makeTensorInfo(h, c.dtype, f);
                if (i) {
                    const e = Cv({
                        inputs: {
                            x: g
                        },
                        backend: n,
                        attrs: {
                            shape: Wo(h, o)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(g), e
                }
                return g
            }
        };
        const Gv = {
            kernelName: Ne,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    keepDims: i
                } = s;
                Hk(r, "any");
                const o = W(a, r.shape);
                let u = o;
                const l = Go(u, r.shape.length);
                let c = r;
                null != l && (c = Uv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), u = jo(u.length, r.shape.length)), Vo("any", u, c.shape.length);
                const [h, p] = Uo(c.shape, u), d = O(p), f = re(O(h), c.dtype), m = n.data.get(c.dataId).values;
                for (let e = 0; e < f.length; ++e) {
                    const t = e * d;
                    let n = m[t];
                    for (let e = 0; e < d; ++e) {
                        const s = m[t + e];
                        n = n || s
                    }
                    f[e] = n
                }
                null != l && n.disposeIntermediateTensorInfo(c);
                const g = n.makeTensorInfo(h, c.dtype, f);
                if (i) {
                    const e = Cv({
                        inputs: {
                            x: g
                        },
                        backend: n,
                        attrs: {
                            shape: Wo(h, o)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(g), e
                }
                return g
            }
        };
        const Hv = {
            kernelName: Se,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a
                } = s;
                Hk(r, "argMax");
                let i = W(a, r.shape);
                const o = Go(i, r.shape.length);
                let u = r;
                const l = [];
                null != o && (u = Uv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: o
                    }
                }), l.push(u), i = jo(i.length, u.shape.length)), i = [i[0]], Vo("argMax", i, u.shape.length);
                const [c, h] = Uo(u.shape, i), p = re(O(c), "int32"), d = O(h), f = n.data.get(u.dataId).values;
                for (let e = 0; e < p.length; ++e) {
                    const t = e * d;
                    let n = f[t],
                        s = 0;
                    for (let e = 0; e < d; ++e) {
                        const r = f[t + e];
                        r > n && (n = r, s = e)
                    }
                    p[e] = s
                }
                return l.forEach((e => n.disposeIntermediateTensorInfo(e))), n.makeTensorInfo(c, "int32", p)
            }
        };
        const jv = {
                kernelName: Te,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        axis: a
                    } = s;
                    Hk(r, "argMin");
                    let i = W(a, r.shape);
                    const o = Go(i, r.shape.length);
                    let u = r;
                    const l = [];
                    null != o && (u = Uv({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            perm: o
                        }
                    }), l.push(u), i = jo(i.length, u.shape.length)), i = [i[0]], Vo("argMin", i, u.shape.length);
                    const [c, h] = Uo(u.shape, i), p = re(O(c), "int32"), d = O(h), f = n.data.get(u.dataId).values;
                    for (let e = 0; e < p.length; ++e) {
                        const t = e * d;
                        let n = f[t],
                            s = 0;
                        for (let e = 0; e < d; ++e) {
                            const r = f[t + e];
                            r < n && (n = r, s = e)
                        }
                        p[e] = s
                    }
                    return l.forEach((e => n.disposeIntermediateTensorInfo(e))), n.makeTensorInfo(c, "int32", p)
                }
            },
            qv = Kk($e, (e => Math.asin(e))),
            Kv = {
                kernelName: $e,
                backendName: "cpu",
                kernelFunc: qv
            },
            Xv = Kk(Ce, (e => Math.asinh(e))),
            Yv = {
                kernelName: Ce,
                backendName: "cpu",
                kernelFunc: Xv
            },
            Jv = Kk(Ee, (e => Math.atan(e))),
            Zv = {
                kernelName: Ee,
                backendName: "cpu",
                kernelFunc: Jv
            },
            Qv = nv(((e, t) => Math.atan2(e, t))),
            eI = vv(Re, Qv),
            tI = {
                kernelName: Re,
                backendName: "cpu",
                kernelFunc: eI
            },
            nI = Kk(Ae, (e => Math.atanh(e))),
            sI = {
                kernelName: Ae,
                backendName: "cpu",
                kernelFunc: nI
            };

        function rI(e, t, n, s, r, a) {
            const i = r.strideHeight,
                o = r.strideWidth,
                u = r.dilationHeight,
                l = r.dilationWidth,
                c = r.effectiveFilterHeight,
                h = r.effectiveFilterWidth,
                p = r.padInfo.top,
                d = r.padInfo.left,
                f = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                m = Aa(r.outShape, n),
                g = m.values,
                y = r.outShape[1] * r.outShape[2] * r.outShape[3],
                b = r.outShape[2] * r.outShape[3],
                x = r.outShape[3];
            for (let t = 0; t < r.batchSize; ++t) {
                const n = t * y,
                    m = t * s[0];
                for (let t = 0; t < r.inChannels; ++t)
                    for (let y = 0; y < r.outHeight; ++y) {
                        const w = y * i - p,
                            k = Math.max(0, w),
                            v = Math.min(r.inHeight, c + w),
                            I = n + y * b;
                        for (let n = 0; n < r.outWidth; ++n) {
                            const i = n * o - d,
                                c = Math.max(0, i),
                                p = Math.min(r.inWidth, h + i);
                            let y = f,
                                b = 0,
                                w = 0;
                            for (let n = k; n < v; n += u) {
                                const r = m + n * s[1];
                                for (let n = c; n < p; n += l) {
                                    const i = e[r + n * s[2] + t];
                                    "max" === a && i > y ? y = i : "avg" === a && (b += i, w++)
                                }
                                if (isNaN(y)) break
                            }
                            g[I + n * x + t] = "avg" === a ? b / w : y
                        }
                    }
            }
            return m
        }

        function aI(e, t, n, s, r = !1, a = !1) {
            const i = Aa(s.outShape, "int32"),
                o = s.strideHeight,
                u = s.strideWidth,
                l = s.dilationHeight,
                c = s.dilationWidth,
                h = s.effectiveFilterHeight,
                p = s.effectiveFilterWidth,
                d = s.padInfo.top,
                f = s.padInfo.left,
                m = Aa(t, n, e);
            for (let e = 0; e < s.batchSize; ++e)
                for (let t = 0; t < s.inChannels; ++t)
                    for (let n = 0; n < s.outHeight; ++n) {
                        const g = n * o - d;
                        let y = g;
                        for (; y < 0;) y += l;
                        const b = Math.min(s.inHeight, h + g);
                        for (let o = 0; o < s.outWidth; ++o) {
                            const h = o * u - f;
                            let d = h;
                            for (; d < 0;) d += c;
                            const x = Math.min(s.inWidth, p + h);
                            let w = Number.NEGATIVE_INFINITY,
                                k = -1;
                            for (let n = y; n < b; n += l) {
                                const i = n - g;
                                for (let o = d; o < x; o += c) {
                                    const u = o - h,
                                        l = m.get(e, n, o, t);
                                    l > w && (w = l, k = r ? a ? ((e * s.inHeight + n) * s.inWidth + o) * s.inChannels + t : (n * s.inWidth + o) * s.inChannels + t : i * p + u)
                                }
                            }
                            i.set(k, e, n, o, t)
                        }
                    }
            return i
        }

        function iI(e, t, n, s, r, a) {
            const i = r.strideDepth,
                o = r.strideHeight,
                u = r.strideWidth,
                l = r.dilationDepth,
                c = r.dilationHeight,
                h = r.dilationWidth,
                p = r.effectiveFilterDepth,
                d = r.effectiveFilterHeight,
                f = r.effectiveFilterWidth,
                m = r.padInfo.front,
                g = r.padInfo.top,
                y = r.padInfo.left,
                b = "max" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
                x = Aa(r.outShape, n),
                w = x.values,
                k = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4],
                v = r.outShape[2] * r.outShape[3] * r.outShape[4],
                I = r.outShape[3] * r.outShape[4],
                N = r.outShape[4];
            for (let t = 0; t < r.batchSize; ++t) {
                const n = t * k,
                    x = t * s[0];
                for (let t = 0; t < r.inChannels; ++t)
                    for (let k = 0; k < r.outDepth; ++k) {
                        const S = k * i - m;
                        let T = S;
                        for (; T < 0;) T += l;
                        const $ = Math.min(r.inDepth, p + S),
                            C = n + k * v;
                        for (let n = 0; n < r.outHeight; ++n) {
                            const i = n * o - g;
                            let p = i;
                            for (; p < 0;) p += c;
                            const m = Math.min(r.inHeight, d + i),
                                k = C + n * I;
                            for (let n = 0; n < r.outWidth; ++n) {
                                const i = n * u - y;
                                let o = i;
                                for (; o < 0;) o += h;
                                const d = Math.min(r.inWidth, f + i),
                                    g = k + n * N;
                                let v = b,
                                    I = 0,
                                    S = 0;
                                for (let n = T; n < $; n += l) {
                                    const r = x + n * s[1];
                                    for (let n = p; n < m; n += c) {
                                        const i = r + n * s[2];
                                        for (let n = o; n < d; n += h) {
                                            const r = e[i + n * s[3] + t];
                                            if ("max" === a && r > v ? v = r : "avg" === a && (I += r, S++), isNaN(v)) break
                                        }
                                        if (isNaN(v)) break
                                    }
                                    if (isNaN(v)) break
                                }
                                w[g + t] = "avg" === a ? I / S : v
                            }
                        }
                    }
            }
            return x
        }
        const oI = {
            kernelName: Fe,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t;
                Hk(r, "avgPool");
                const {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u
                } = s;
                R(Pi(i, 1), (() => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
                const l = Ai(r.shape, a, i, 1, o, u);
                let c;
                if (1 === l.filterWidth && 1 === l.filterHeight && M(l.inShape, l.outShape)) c = Zk({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                else {
                    const e = n.data.get(r.dataId).values,
                        t = ee(r.shape),
                        s = rI(e, r.shape, r.dtype, t, l, "avg");
                    c = n.makeTensorInfo(l.outShape, r.dtype, s.values)
                }
                return c
            }
        };
        const uI = {
            kernelName: _e,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u,
                    dataFormat: l
                } = s;
                Hk(r, "avgPool3d");
                const c = Ri(r.shape, a, i, 1, o, u, l),
                    h = iI(n.data.get(r.dataId).values, r.shape, r.dtype, ee(r.shape), c, "avg");
                return n.makeTensorInfo(h.shape, "float32", h.values)
            }
        };
        const lI = {
            kernelName: Oe,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a
                } = t, {
                    filterSize: i,
                    strides: o,
                    pad: u,
                    dimRoundingMode: l
                } = s;
                Hk([r, a], "avgPool3DGrad");
                const c = Ri(a.shape, i, o, 1, u, l),
                    h = c.strideDepth,
                    p = c.strideHeight,
                    d = c.strideWidth,
                    f = c.filterDepth,
                    m = c.filterHeight,
                    g = c.filterWidth,
                    y = c.dilationDepth,
                    b = c.dilationHeight,
                    x = c.dilationWidth,
                    w = c.effectiveFilterDepth,
                    k = c.effectiveFilterHeight,
                    v = c.effectiveFilterWidth,
                    I = w - 1 - c.padInfo.front,
                    N = v - 1 - c.padInfo.left,
                    S = k - 1 - c.padInfo.top,
                    T = Aa(a.shape, "float32"),
                    $ = 1 / (f * m * g),
                    C = n.bufferSync(r);
                for (let e = 0; e < c.batchSize; ++e)
                    for (let t = 0; t < c.inChannels; ++t)
                        for (let n = 0; n < c.inDepth; ++n)
                            for (let s = 0; s < c.inHeight; ++s)
                                for (let r = 0; r < c.inWidth; ++r) {
                                    const a = n - I,
                                        i = s - S,
                                        o = r - N;
                                    let u = 0;
                                    for (let n = 0; n < w; n += y) {
                                        const s = (a + n) / h;
                                        if (!(s < 0 || s >= c.outDepth || Math.floor(s) !== s))
                                            for (let n = 0; n < k; n += b) {
                                                const r = (i + n) / p;
                                                if (!(r < 0 || r >= c.outHeight || Math.floor(r) !== r))
                                                    for (let n = 0; n < v; n += x) {
                                                        const a = (o + n) / d;
                                                        if (a < 0 || a >= c.outWidth || Math.floor(a) !== a) continue;
                                                        u += C.get(e, s, r, a, t)
                                                    }
                                            }
                                    }
                                    T.set(u * $, e, n, s, r, t)
                                }
                return n.makeTensorInfo(T.shape, T.dtype, T.values)
            }
        };
        const cI = {
            kernelName: De,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a
                } = t, i = a;
                Hk([r, a], "avgPoolGrad");
                const {
                    filterSize: o,
                    strides: u,
                    pad: l
                } = s, c = Ai(i.shape, o, u, 1, l), h = c.strideHeight, p = c.strideWidth, d = c.filterHeight, f = c.filterWidth, m = c.dilationHeight, g = c.dilationWidth, y = c.effectiveFilterHeight, b = c.effectiveFilterWidth, x = b - 1 - c.padInfo.left, w = y - 1 - c.padInfo.top, k = Aa(i.shape, "float32"), v = 1 / (d * f), I = n.data.get(r.dataId).values, N = Aa(r.shape, "float32", I);
                for (let e = 0; e < c.batchSize; ++e)
                    for (let t = 0; t < c.inChannels; ++t)
                        for (let n = 0; n < c.inHeight; ++n)
                            for (let s = 0; s < c.inWidth; ++s) {
                                const r = n - w,
                                    a = s - x;
                                let i = 0;
                                for (let n = 0; n < y; n += m) {
                                    const s = (r + n) / h;
                                    if (!(s < 0 || s >= c.outHeight || Math.floor(s) !== s))
                                        for (let n = 0; n < b; n += g) {
                                            const r = (a + n) / p;
                                            if (r < 0 || r >= c.outWidth || Math.floor(r) !== r) continue;
                                            i += N.get(e, s, r, t)
                                        }
                                }
                                k.set(i * v, e, n, s, t)
                            }
                return n.makeTensorInfo(k.shape, k.dtype, k.values)
            }
        };
        const hI = {
            kernelName: Tt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    scale: a,
                    offset: i,
                    mean: o,
                    variance: u
                } = t;
                R(o.shape.length === u.shape.length, (() => "Batch normalization gradient requires mean and variance to have equal ranks.")), R(null == i || o.shape.length === i.shape.length, (() => "Batch normalization gradient requires mean and offset to have equal ranks.")), R(null == a || o.shape.length === a.shape.length, (() => "Batch normalization gradient requires mean and scale to have equal ranks.")), Hk([r, o, u, a, i], "batchNorm");
                let {
                    varianceEpsilon: l
                } = s;
                null == l && (l = .001);
                const c = n.data.get(r.dataId).values,
                    h = n.data.get(o.dataId).values,
                    p = n.data.get(u.dataId).values,
                    d = a ? n.data.get(a.dataId).values : new Float32Array([1]),
                    f = i ? n.data.get(i.dataId).values : new Float32Array([0]),
                    m = new Float32Array(c.length),
                    g = f.length,
                    y = d.length,
                    b = p.length,
                    x = h.length;
                let w = 0,
                    k = 0,
                    v = 0,
                    I = 0;
                for (let e = 0; e < c.length; ++e) m[e] = f[w++] + (c[e] - h[k++]) * d[v++] / Math.sqrt(p[I++] + l), w >= g && (w = 0), k >= x && (k = 0), v >= y && (v = 0), I >= b && (I = 0);
                return n.makeTensorInfo(r.shape, r.dtype, m)
            }
        };

        function pI(e, t, n, s, r) {
            const a = oi(s, t, n),
                i = O(n),
                o = ee(s);
            if (a) {
                const n = ui(t, o);
                return "string" === r ? e.slice(n, n + i) : e.subarray(n, n + i)
            }
            const u = Aa(s, r, "string" === r ? fh(e) : e),
                l = Aa(n, r);
            for (let e = 0; e < l.size; ++e) {
                const n = l.indexToLoc(e),
                    s = n.map(((e, n) => e + t[n]));
                l.set(u.get(...s), ...n)
            }
            return "string" === r ? mh(l.values) : l.values
        }

        function dI(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                begin: a,
                size: i
            } = s;
            Hk(r, "slice");
            const [o, u] = li(r, a, i);
            Xa(r, o, u);
            const l = pI(n.data.get(r.dataId).values, o, u, r.shape, r.dtype);
            return n.makeTensorInfo(u, r.dtype, l)
        }
        const fI = {
            kernelName: zn,
            backendName: "cpu",
            kernelFunc: dI
        };
        const mI = {
            kernelName: Le,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    blockShape: a,
                    crops: i
                } = s;
                Hk([r], "batchToSpaceND");
                const o = a.reduce(((e, t) => e * t)),
                    u = yc(r.shape, a, o),
                    l = bc(u.length, a.length),
                    c = xc(r.shape, a, o),
                    h = wc(i, a.length),
                    p = kc(c, i, a.length),
                    d = Cv({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    }),
                    f = Uv({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            perm: l
                        }
                    }),
                    m = Cv({
                        inputs: {
                            x: f
                        },
                        backend: n,
                        attrs: {
                            shape: c
                        }
                    }),
                    g = dI({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            begin: h,
                            size: p
                        }
                    });
                return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), g
            }
        };

        function gI(e, t, n, s, r) {
            const a = O(s),
                i = re(r, n);
            for (let n = 0; n < e.length; n++) {
                const s = e[n];
                if (s < 0) throw new Error("Input x must be non-negative!");
                s >= r || (i[s] += a > 0 ? t[n] : 1)
            }
            return i
        }

        function yI(e, t, n, s = !1) {
            const r = e.shape[0],
                a = e.shape[1],
                i = Aa([r, n], t.dtype);
            for (let o = 0; o < r; o++)
                for (let r = 0; r < a; r++) {
                    const a = e.get(o, r);
                    if (a < 0) throw new Error("Input x must be non-negative!");
                    a >= n || (s ? i.set(1, o, a) : t.size > 0 ? i.set(i.get(o, a) + t.get(o, r), o, a) : i.set(i.get(o, a) + 1, o, a))
                }
            return i
        }
        const bI = {
            kernelName: ze,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    weights: a
                } = t, {
                    size: i
                } = s, o = gI(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);
                return n.makeTensorInfo([i], a.dtype, o)
            }
        };
        const xI = {
                kernelName: Be,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        s0: s,
                        s1: r
                    } = t, a = n.data.get(s.dataId).values, i = n.data.get(r.dataId).values, o = Ga(Array.from(a), Array.from(i));
                    return n.makeTensorInfo([o.length], "int32", Int32Array.from(o))
                }
            },
            wI = cv((e => Math.ceil(e))),
            kI = Xk(Ue, wI),
            vI = {
                kernelName: Ue,
                backendName: "cpu",
                kernelFunc: kI
            },
            II = Kk(We, ((e, t) => {
                const n = t;
                return e > n.clipValueMax ? n.clipValueMax : e < n.clipValueMin ? n.clipValueMin : e
            })),
            NI = {
                kernelName: We,
                backendName: "cpu",
                kernelFunc: II
            },
            SI = {
                kernelName: Ge,
                backendName: "cpu",
                kernelFunc: e => {
                    const {
                        x: t
                    } = e.inputs, n = e.backend, s = new Float32Array(O(t.shape)), r = n.data.get(t.dataId), a = r.complexTensorInfos.real, i = r.complexTensorInfos.imag, o = n.data.get(a.dataId).values, u = n.data.get(i.dataId).values;
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e],
                            n = u[e];
                        s[e] = Math.hypot(t, n)
                    }
                    return n.makeOutput(s, t.shape, "float32")
                }
            };

        function TI(e, t, n, s) {
            const r = H(n, O(t));
            if (s && "string" !== n) {
                let t = 0;
                e.forEach((e => {
                    const n = O(e.shape);
                    r.set(e.vals, t), t += n
                }))
            } else {
                let s = 0;
                e.forEach((e => {
                    const a = "string" === n ? fh(e.vals) : e.vals;
                    let i = 0;
                    for (let n = 0; n < e.shape[0]; ++n) {
                        const o = n * t[1] + s;
                        for (let t = 0; t < e.shape[1]; ++t) r[o + t] = a[i++]
                    }
                    s += e.shape[1]
                }))
            }
            return r
        }

        function $I(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                input: s
            } = t, r = n.data.get(s.dataId).complexTensorInfos.imag, a = n.data.get(r.dataId).values;
            return n.makeTensorInfo(r.shape, r.dtype, a)
        }
        const CI = {
            kernelName: Dt,
            backendName: "cpu",
            kernelFunc: $I
        };

        function EI(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                axis: r
            } = s, a = W(r, t[0].shape)[0];
            let i = dc(t.map((e => e.shape)), a);
            if (0 === O(i)) return n.makeTensorInfo(i, t[0].dtype, []);
            const o = t.filter((e => O(e.shape) > 0));
            if (1 === o.length) return Zk({
                inputs: {
                    x: o[0]
                },
                backend: n
            });
            if (pc(o.map((e => e.shape)), a), "complex64" === o[0].dtype) {
                const e = o.map((e => bv({
                        inputs: {
                            input: e
                        },
                        backend: n
                    }))),
                    t = o.map((e => $I({
                        inputs: {
                            input: e
                        },
                        backend: n
                    }))),
                    s = EI({
                        inputs: e,
                        backend: n,
                        attrs: {
                            axis: a
                        }
                    }),
                    r = EI({
                        inputs: t,
                        backend: n,
                        attrs: {
                            axis: a
                        }
                    }),
                    i = mv({
                        inputs: {
                            real: s,
                            imag: r
                        },
                        backend: n
                    });
                return e.forEach((e => n.disposeIntermediateTensorInfo(e))), t.forEach((e => n.disposeIntermediateTensorInfo(e))), n.disposeIntermediateTensorInfo(s), n.disposeIntermediateTensorInfo(r), i
            }
            const u = o.map((e => {
                    const t = O(e.shape.slice(a));
                    return Cv({
                        inputs: {
                            x: e
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, t]
                        }
                    })
                })),
                l = u.map((e => ({
                    vals: n.data.get(e.dataId).values,
                    shape: e.shape
                })));
            i = dc(u.map((e => e.shape)), 1);
            const c = 1 === u[0].shape[0],
                h = TI(l, i, t[0].dtype, c),
                p = dc(o.map((e => e.shape)), a),
                d = n.makeTensorInfo(p, t[0].dtype, h);
            return u.forEach((e => n.disposeIntermediateTensorInfo(e))), d
        }
        const AI = {
            kernelName: He,
            backendName: "cpu",
            kernelFunc: EI
        };

        function RI(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r,
                filter: a
            } = t, {
                strides: i,
                pad: o,
                dataFormat: u,
                dilations: l,
                dimRoundingMode: c
            } = s;
            Hk([r, a], "conv2d");
            const h = Ui(u),
                p = Fi(r.shape, a.shape, i, l, o, c, !1, h),
                d = p.filterHeight,
                f = p.filterWidth,
                m = p.dilationHeight,
                g = p.dilationWidth,
                y = p.padInfo.left,
                b = p.padInfo.top,
                x = "channelsLast" === p.dataFormat,
                w = new ir(p.outShape, r.dtype),
                k = ee(r.shape),
                v = ee(a.shape),
                I = k[0],
                N = x ? k[1] : k[2],
                S = x ? k[2] : 1,
                T = x ? 1 : k[1],
                $ = w.strides[0],
                C = x ? w.strides[1] : w.strides[2],
                E = x ? w.strides[2] : 1,
                A = x ? 1 : w.strides[1],
                R = n.data.get(r.dataId).values,
                F = n.data.get(a.dataId).values,
                D = w.values;
            for (let e = 0; e < p.batchSize; ++e) {
                const t = e * I,
                    n = e * $;
                for (let e = 0; e < p.outHeight; ++e) {
                    const s = n + e * C,
                        r = e * p.strideHeight - b;
                    for (let e = 0; e < d; ++e) {
                        const n = r + e * m;
                        if (n < 0 || n >= p.inHeight) continue;
                        const a = e * v[0],
                            i = t + n * N;
                        for (let e = 0; e < p.outWidth; ++e) {
                            const t = s + e * E,
                                n = e * p.strideWidth - y;
                            for (let e = 0; e < f; ++e) {
                                const s = n + e * g;
                                if (s < 0 || s >= p.inWidth) continue;
                                const r = i + s * S;
                                let o = a + e * v[1];
                                for (let e = 0; e < p.inChannels; ++e) {
                                    const n = R[r + e * T];
                                    for (let e = 0; e < p.outChannels; ++e) D[t + e * A] += n * F[o + e];
                                    o += p.outChannels
                                }
                            }
                        }
                    }
                }
            }
            return n.makeTensorInfo(w.shape, w.dtype, D)
        }
        const FI = {
            kernelName: je,
            backendName: "cpu",
            kernelFunc: RI
        };
        const DI = {
            kernelName: qe,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    dy: a
                } = t, {
                    strides: i,
                    pad: o,
                    dataFormat: u,
                    dimRoundingMode: l,
                    filterShape: c
                } = s;
                Hk([r, a], "conv2dBackpropFilter");
                const h = Ui(u),
                    p = Fi(r.shape, c, i, 1, o, l, !1, h),
                    {
                        strideHeight: d,
                        strideWidth: f,
                        filterHeight: m,
                        filterWidth: g
                    } = p,
                    y = "channelsLast" === p.dataFormat,
                    b = new ir(p.filterShape, "float32"),
                    x = p.padInfo.left,
                    w = p.padInfo.top,
                    k = n.data.get(r.dataId).values,
                    v = n.data.get(a.dataId).values,
                    I = new ir(r.shape, r.dtype, k),
                    N = new ir(a.shape, a.dtype, v);
                for (let e = 0; e < m; ++e) {
                    const t = Math.max(0, Math.ceil((w - e) / d)),
                        n = Math.min(p.outHeight, (p.inHeight + w - e) / d);
                    for (let s = 0; s < g; ++s) {
                        const r = Math.max(0, Math.ceil((x - s) / f)),
                            a = Math.min(p.outWidth, (p.inWidth + x - s) / f);
                        for (let i = 0; i < p.inChannels; ++i)
                            for (let o = 0; o < p.outChannels; ++o) {
                                let u = 0;
                                for (let l = 0; l < p.batchSize; ++l)
                                    for (let c = t; c < n; ++c) {
                                        const t = e + c * d - w;
                                        for (let e = r; e < a; ++e) {
                                            const n = s + e * f - x;
                                            u += y ? I.get(l, t, n, i) * N.get(l, c, e, o) : I.get(l, i, t, n) * N.get(l, o, c, e)
                                        }
                                    }
                                b.set(u, e, s, i, o)
                            }
                    }
                }
                return n.makeTensorInfo(b.shape, b.dtype, b.values)
            }
        };
        const _I = {
            kernelName: Ke,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    filter: a
                } = t, {
                    inputShape: i,
                    strides: o,
                    pad: u,
                    dataFormat: l,
                    dimRoundingMode: c
                } = s;
                Hk([r, a], "conv2dBackpropInput");
                const h = ee(a.shape),
                    p = ee(r.shape);
                let d = Ui(l);
                const f = Fi(i, a.shape, o, 1, u, c, !1, d),
                    m = new ir(f.inShape, "float32"),
                    g = m.values,
                    y = n.data.get(r.dataId).values,
                    b = n.data.get(a.dataId).values,
                    [x, w, k] = h,
                    {
                        batchSize: v,
                        filterHeight: I,
                        filterWidth: N,
                        inChannels: S,
                        inHeight: T,
                        inWidth: $,
                        outChannels: C,
                        outHeight: E,
                        outWidth: A,
                        strideHeight: R,
                        strideWidth: F
                    } = f;
                d = f.dataFormat;
                const D = I - 1 - f.padInfo.top,
                    _ = N - 1 - f.padInfo.left,
                    O = "channelsLast" === d,
                    M = m.strides[0],
                    L = O ? m.strides[1] : m.strides[2],
                    z = O ? m.strides[2] : 1,
                    B = O ? 1 : m.strides[1],
                    P = p[0],
                    U = O ? p[1] : p[2],
                    W = O ? p[2] : 1,
                    V = O ? 1 : p[1];
                for (let e = 0; e < v; ++e)
                    for (let t = 0; t < S; ++t)
                        for (let n = 0; n < T; ++n) {
                            const s = n - D,
                                r = Math.max(0, Math.ceil(s / R)),
                                a = Math.min(E, (I + s) / R);
                            for (let i = 0; i < $; ++i) {
                                const o = i - _,
                                    u = Math.max(0, Math.ceil(o / F)),
                                    l = Math.min(A, (N + o) / F);
                                let c = 0;
                                for (let n = r; n < a; ++n) {
                                    const r = n * R - s;
                                    for (let s = u; s < l; ++s) {
                                        const a = P * e + U * n + W * s,
                                            i = x * (I - 1 - r) + w * (N - 1 - (s * F - o)) + k * t;
                                        for (let e = 0; e < C; ++e) {
                                            c += y[a + V * e] * b[i + e]
                                        }
                                    }
                                }
                                g[M * e + L * n + z * i + B * t] = c
                            }
                        }
                return n.makeTensorInfo(m.shape, m.dtype, m.values)
            }
        };
        const OI = {
            kernelName: Xe,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a
                } = t, {
                    strides: i,
                    pad: o,
                    dilations: u
                } = s;
                Hk([r, a], "conv3d");
                const l = Di(r.shape, a.shape, i, u, o),
                    {
                        filterDepth: c,
                        filterHeight: h,
                        filterWidth: p,
                        dilationDepth: d,
                        dilationHeight: f,
                        dilationWidth: m,
                        padInfo: g
                    } = l,
                    y = g.front,
                    b = g.left,
                    x = g.top,
                    w = new ir(l.outShape, r.dtype),
                    k = n.data.get(r.dataId).values,
                    v = n.data.get(a.dataId).values,
                    I = w.values,
                    N = ee(r.shape),
                    S = ee(a.shape);
                for (let e = 0; e < l.batchSize; ++e) {
                    const t = e * N[0],
                        n = e * w.strides[0];
                    for (let e = 0; e < l.outDepth; ++e) {
                        const s = n + e * w.strides[1],
                            r = e * l.strideDepth - y;
                        for (let e = 0; e < c; ++e) {
                            const n = r + e * d;
                            if (n < 0 || n >= l.inDepth) continue;
                            const a = e * S[0],
                                i = t + n * N[1];
                            for (let e = 0; e < l.outHeight; ++e) {
                                const t = s + e * w.strides[2],
                                    n = e * l.strideHeight - x;
                                for (let e = 0; e < h; ++e) {
                                    const s = n + e * f;
                                    if (s < 0 || s >= l.inHeight) continue;
                                    const r = a + e * S[1],
                                        o = i + s * N[2];
                                    for (let e = 0; e < l.outWidth; ++e) {
                                        const n = t + e * l.outChannels,
                                            s = e * l.strideWidth - b;
                                        for (let e = 0; e < p; ++e) {
                                            const t = s + e * m;
                                            if (t < 0 || t >= l.inWidth) continue;
                                            const a = r + e * S[2],
                                                i = o + t * l.inChannels;
                                            let u = a;
                                            for (let e = 0; e < l.inChannels; ++e) {
                                                const t = k[i + e];
                                                for (let e = 0; e < l.outChannels; ++e) I[n + e] += t * v[u + e];
                                                u += l.outChannels
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return n.makeTensorInfo(w.shape, w.dtype, w.values)
            }
        };
        const MI = {
            kernelName: Ye,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    dy: a
                } = t, {
                    strides: i,
                    pad: o,
                    filterShape: u
                } = s;
                Hk([r, a], "conv3dBackpropFilterV2");
                const l = ee(r.shape),
                    c = ee(a.shape),
                    h = Di(r.shape, u, i, 1, o),
                    p = h.strideDepth,
                    d = h.strideHeight,
                    f = h.strideWidth,
                    m = h.filterDepth,
                    g = h.filterHeight,
                    y = h.filterWidth,
                    b = new ir(h.filterShape, "float32"),
                    x = b.values,
                    [w, k, v, I] = b.strides,
                    N = n.data.get(a.dataId).values,
                    [S, T, $, C] = c,
                    E = n.data.get(r.dataId).values,
                    [A, R, F, D] = l,
                    _ = h.padInfo.front,
                    O = h.padInfo.left,
                    M = h.padInfo.top;
                for (let e = 0; e < m; ++e) {
                    const t = Math.max(0, Math.ceil((_ - e) / p)),
                        n = Math.min(h.outDepth, (h.inDepth + _ - e) / p),
                        s = e * w;
                    for (let r = 0; r < g; ++r) {
                        const a = Math.max(0, Math.ceil((M - r) / d)),
                            i = Math.min(h.outHeight, (h.inHeight + M - r) / d),
                            o = r * k + s;
                        for (let s = 0; s < y; ++s) {
                            const u = Math.max(0, Math.ceil((O - s) / f)),
                                l = Math.min(h.outWidth, (h.inWidth + O - s) / f),
                                c = s * v + o;
                            for (let o = 0; o < h.inChannels; ++o) {
                                const m = o * I + c;
                                for (let c = 0; c < h.outChannels; ++c) {
                                    let g = 0;
                                    for (let m = 0; m < h.batchSize; ++m) {
                                        const h = m * A,
                                            y = m * S;
                                        for (let m = t; m < n; ++m) {
                                            const t = (e + m * p - _) * R + h,
                                                n = m * T + y;
                                            for (let e = a; e < i; ++e) {
                                                const a = (r + e * d - M) * F + t,
                                                    i = e * $ + n;
                                                for (let e = u; e < l; ++e) {
                                                    const t = e * C + i;
                                                    g += E[(s + e * f - O) * D + a + o] * N[t + c]
                                                }
                                            }
                                        }
                                    }
                                    x[m + c] = g
                                }
                            }
                        }
                    }
                }
                return n.makeTensorInfo(b.shape, b.dtype, b.values)
            }
        };
        const LI = {
                kernelName: Je,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        dy: r,
                        filter: a
                    } = t, {
                        pad: i,
                        strides: o,
                        inputShape: u
                    } = s;
                    Hk([r], "conv3dBackpropInputV2");
                    const l = ee(r.shape),
                        c = ee(a.shape),
                        h = Di(u, a.shape, o, 1, i),
                        p = new ir(h.inShape, "float32"),
                        d = p.values,
                        [f, m, g, y] = p.strides,
                        b = n.data.get(r.dataId).values,
                        [x, w, k, v] = l,
                        I = n.data.get(a.dataId).values,
                        [N, S, T, $] = c,
                        {
                            batchSize: C,
                            filterDepth: E,
                            filterHeight: A,
                            filterWidth: R,
                            inChannels: F,
                            inDepth: D,
                            inHeight: _,
                            inWidth: O,
                            outChannels: M,
                            outDepth: L,
                            outHeight: z,
                            outWidth: B,
                            strideDepth: P,
                            strideHeight: U,
                            strideWidth: W
                        } = h,
                        V = E - 1 - h.padInfo.front,
                        G = A - 1 - h.padInfo.top,
                        H = R - 1 - h.padInfo.left;
                    for (let e = 0; e < C; ++e)
                        for (let t = 0; t < F; ++t)
                            for (let n = 0; n < D; ++n) {
                                const s = n - V,
                                    r = Math.max(0, Math.ceil(s / P)),
                                    a = Math.min(L, (E + s) / P);
                                for (let i = 0; i < _; ++i) {
                                    const o = i - G,
                                        u = Math.max(0, Math.ceil(o / U)),
                                        l = Math.min(z, (A + o) / U);
                                    for (let c = 0; c < O; ++c) {
                                        const h = c - H,
                                            p = Math.max(0, Math.ceil(h / W)),
                                            C = Math.min(B, (R + h) / W);
                                        let F = 0;
                                        for (let n = r; n < a; ++n) {
                                            const r = n * P - s;
                                            for (let s = u; s < l; ++s) {
                                                const a = s * U - o;
                                                for (let i = p; i < C; ++i) {
                                                    const o = x * e + w * n + k * s + v * i,
                                                        u = N * (E - 1 - r) + S * (A - 1 - a) + T * (R - 1 - (i * W - h)) + $ * t;
                                                    for (let e = 0; e < M; ++e) {
                                                        F += b[o + e] * I[u + e]
                                                    }
                                                }
                                            }
                                        }
                                        d[f * e + m * n + g * i + y * c + t] = F
                                    }
                                }
                            }
                    return n.makeTensorInfo(p.shape, p.dtype, p.values)
                }
            },
            zI = Kk(Ze, (e => Math.cos(e))),
            BI = {
                kernelName: Ze,
                backendName: "cpu",
                kernelFunc: zI
            },
            PI = Kk(Qe, (e => Math.cosh(e))),
            UI = {
                kernelName: Qe,
                backendName: "cpu",
                kernelFunc: PI
            };
        const WI = {
            kernelName: nt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    image: r,
                    boxes: a,
                    boxInd: i
                } = t, {
                    cropSize: o,
                    method: u,
                    extrapolationValue: l
                } = s, [c, h, p, d] = r.shape, f = a.shape[0], [m, g] = o, y = Aa([f, m, g, d], "float32"), b = n.data.get(a.dataId).values, x = n.data.get(i.dataId).values, w = n.data.get(r.dataId).values, k = ee(r.shape), v = ee(y.shape);
                for (let e = 0; e < f; e++) {
                    const t = 4 * e,
                        n = b[t],
                        s = b[t + 1],
                        r = b[t + 2],
                        a = b[t + 3],
                        i = x[e];
                    if (i >= c) continue;
                    const o = m > 1 ? (r - n) * (h - 1) / (m - 1) : 0,
                        f = g > 1 ? (a - s) * (p - 1) / (g - 1) : 0;
                    for (let t = 0; t < m; t++) {
                        const c = m > 1 ? n * (h - 1) + t * o : .5 * (n + r) * (h - 1);
                        if (c < 0 || c > h - 1)
                            for (let n = 0; n < g; n++)
                                for (let s = 0; s < d; s++) {
                                    const r = s + n * v[2] + t * v[1] + e * v[0];
                                    y.values[r] = l
                                } else if ("bilinear" === u) {
                                    const n = Math.floor(c),
                                        r = Math.ceil(c),
                                        o = c - n;
                                    for (let u = 0; u < g; u++) {
                                        const c = g > 1 ? s * (p - 1) + u * f : .5 * (s + a) * (p - 1);
                                        if (c < 0 || c > p - 1) {
                                            for (let n = 0; n < d; n++) {
                                                const s = n + u * v[2] + t * v[1] + e * v[0];
                                                y.values[s] = l
                                            }
                                            continue
                                        }
                                        const h = Math.floor(c),
                                            m = Math.ceil(c),
                                            b = c - h;
                                        for (let s = 0; s < d; s++) {
                                            let a = s + h * k[2] + n * k[1] + i * k[0];
                                            const l = w[a];
                                            a = s + m * k[2] + n * k[1] + i * k[0];
                                            const c = w[a];
                                            a = s + h * k[2] + r * k[1] + i * k[0];
                                            const p = w[a];
                                            a = s + m * k[2] + r * k[1] + i * k[0];
                                            const d = l + (c - l) * b,
                                                f = p + (w[a] - p) * b;
                                            a = s + u * v[2] + t * v[1] + e * v[0], y.values[a] = d + (f - d) * o
                                        }
                                    }
                                } else
                                    for (let n = 0; n < g; ++n) {
                                        const r = g > 1 ? s * (p - 1) + n * f : .5 * (s + a) * (p - 1);
                                        if (r < 0 || r > p - 1) {
                                            for (let s = 0; s < d; s++) {
                                                const r = s + n * v[2] + t * v[1] + e * v[0];
                                                y.values[r] = l
                                            }
                                            continue
                                        }
                                        const o = Math.round(r),
                                            u = Math.round(c);
                                        for (let s = 0; s < d; s++) {
                                            const r = s + o * k[2] + u * k[1] + i * k[0],
                                                a = s + n * v[2] + t * v[1] + e * v[0];
                                            y.values[a] = w[r]
                                        }
                                    }
                    }
                }
                return n.makeTensorInfo(y.shape, y.dtype, y.values)
            }
        };
        const VI = {
            kernelName: et,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    exclusive: i,
                    reverse: o
                } = s;
                Hk(r, "cumprod");
                const u = Go([a], r.shape.length);
                let l = r;
                null != u && (l = Uv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: u
                    }
                }));
                const c = jo(1, r.shape.length)[0];
                if (c !== l.shape.length - 1) throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);
                const h = xr(l.dtype, "int32"),
                    p = se(O(l.shape), h),
                    d = n.data.get(l.dataId).values,
                    f = l.shape[l.shape.length - 1],
                    m = o ? (e, t) => e + f - t - 1 : (e, t) => e + t;
                for (let e = 0; e < d.length; e += f)
                    for (let t = 0; t < f; t++) {
                        const n = m(e, t);
                        if (0 === t) p[n] = i ? 1 : d[n];
                        else {
                            const s = m(e, t - 1);
                            p[n] = i ? d[s] * p[s] : d[n] * p[s]
                        }
                    }
                const g = n.makeTensorInfo(l.shape, h, p);
                if (null != u) {
                    const e = Uv({
                        inputs: {
                            x: g
                        },
                        backend: n,
                        attrs: {
                            perm: Ho(u)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(l), e
                }
                return g
            }
        };
        const GI = {
            kernelName: tt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    exclusive: i,
                    reverse: o
                } = s;
                Hk(r, "cumsum");
                const u = Go([a], r.shape.length);
                let l = r;
                null != u && (l = Uv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: u
                    }
                }));
                const c = jo(1, r.shape.length)[0];
                if (c !== l.shape.length - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);
                const h = xr(l.dtype, "int32"),
                    p = re(O(l.shape), h),
                    d = n.data.get(l.dataId).values,
                    f = l.shape[l.shape.length - 1],
                    m = o ? (e, t) => e + f - t - 1 : (e, t) => e + t;
                for (let e = 0; e < d.length; e += f)
                    for (let t = 0; t < f; t++) {
                        const n = m(e, t);
                        if (0 === t) p[n] = i ? 0 : d[n];
                        else {
                            const s = m(e, t - 1);
                            p[n] = i ? d[s] + p[s] : d[n] + p[s]
                        }
                    }
                const g = n.makeTensorInfo(l.shape, h, p);
                if (null != u) {
                    const e = Uv({
                        inputs: {
                            x: g
                        },
                        backend: n,
                        attrs: {
                            perm: Ho(u)
                        }
                    });
                    return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(l), e
                }
                return g
            }
        };
        const HI = {
            kernelName: st,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    weights: a
                } = t, {
                    size: i,
                    binaryOutput: o
                } = s;
                if (1 === r.shape.length) {
                    const e = gI(n.data.get(r.dataId).values, n.data.get(a.dataId).values, a.dtype, a.shape, i);
                    return n.makeTensorInfo([i], a.dtype, e)
                }
                if (2 === r.shape.length) {
                    const e = yI(n.bufferSync(r), n.bufferSync(a), i, o);
                    return n.makeTensorInfo(e.shape, a.dtype, e.values)
                }
                throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)
            }
        };
        const jI = {
            kernelName: rt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    blockSize: a,
                    dataFormat: i
                } = s;
                R("NHWC" === i, (() => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));
                const o = r.shape[0],
                    u = r.shape[1],
                    l = r.shape[2],
                    c = r.shape[3],
                    h = u * a,
                    p = l * a,
                    d = c / (a * a),
                    f = n.data.get(r.dataId).values,
                    m = new Float32Array(o * h * p * d);
                let g = 0;
                for (let e = 0; e < o; ++e)
                    for (let t = 0; t < h; ++t) {
                        const n = Math.floor(t / a),
                            s = t % a;
                        for (let t = 0; t < p; ++t) {
                            const r = Math.floor(t / a),
                                i = (s * a + t % a) * d;
                            for (let t = 0; t < d; ++t) {
                                const s = t + i + c * (r + l * (n + u * e));
                                m[g++] = f[s]
                            }
                        }
                    }
                return n.makeTensorInfo([o, h, p, d], r.dtype, m)
            }
        };

        function qI(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r,
                filter: a
            } = t, {
                strides: i,
                pad: o,
                dilations: u,
                dimRoundingMode: l
            } = s;
            Hk([r, a], "depthwiseConv2DNative");
            const c = ee(r.shape),
                h = ee(a.shape);
            let p = u;
            null == p && (p = [1, 1]), R(Pi(i, p), (() => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));
            const d = Fi(r.shape, a.shape, i, p, o, l, !0),
                {
                    filterHeight: f,
                    filterWidth: m,
                    dilationHeight: g,
                    dilationWidth: y,
                    padInfo: b
                } = d,
                x = b.left,
                w = b.top,
                k = d.outChannels / d.inChannels,
                v = new ir(d.outShape, r.dtype),
                I = n.data.get(r.dataId).values,
                N = n.data.get(a.dataId).values,
                S = v.values;
            for (let e = 0; e < d.batchSize; ++e) {
                const t = e * c[0],
                    n = e * v.strides[0];
                for (let e = 0; e < d.outHeight; ++e) {
                    const s = n + e * v.strides[1],
                        r = e * d.strideHeight - w;
                    for (let e = 0; e < f; ++e) {
                        const n = r + e * g;
                        if (n < 0 || n >= d.inHeight) continue;
                        const a = e * h[0],
                            i = t + n * c[1];
                        for (let e = 0; e < d.outWidth; ++e) {
                            const t = s + e * v.strides[2],
                                n = e * d.strideWidth - x;
                            for (let e = 0; e < m; ++e) {
                                const s = n + e * y;
                                if (s < 0 || s >= d.inWidth) continue;
                                const r = a + e * h[1],
                                    o = i + s * d.inChannels;
                                let u = t,
                                    l = r;
                                for (let e = 0; e < d.inChannels; ++e) {
                                    const t = I[o + e];
                                    for (let e = 0; e < k; ++e) S[u + e] += t * N[l + e];
                                    u += k, l += k
                                }
                            }
                        }
                    }
                }
            }
            return n.makeTensorInfo(v.shape, v.dtype, v.values)
        }
        const KI = {
            kernelName: at,
            backendName: "cpu",
            kernelFunc: qI
        };
        const XI = {
            kernelName: it,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    dy: a
                } = t, {
                    strides: i,
                    dilations: o,
                    pad: u,
                    dimRoundingMode: l,
                    filterShape: c
                } = s;
                Hk([r, a], "depthwiseConv2dNativeBackpropFilter");
                const h = Fi(r.shape, c, i, o, u, l, !0),
                    {
                        strideHeight: p,
                        strideWidth: d,
                        filterHeight: f,
                        filterWidth: m
                    } = h,
                    g = new ir(h.filterShape, "float32"),
                    y = h.padInfo.left,
                    b = h.padInfo.top,
                    x = h.outChannels / h.inChannels,
                    w = n.data.get(r.dataId).values,
                    k = new ir(r.shape, r.dtype, w),
                    v = n.data.get(a.dataId).values,
                    I = new ir(a.shape, a.dtype, v);
                for (let e = 0; e < f; ++e) {
                    const t = Math.max(0, Math.ceil((b - e) / p)),
                        n = Math.min(h.outHeight, (h.inHeight + b - e) / p);
                    for (let s = 0; s < m; ++s) {
                        const r = Math.max(0, Math.ceil((y - s) / d)),
                            a = Math.min(h.outWidth, (h.inWidth + y - s) / d);
                        for (let i = 0; i < h.outChannels; ++i) {
                            const o = Math.trunc(i / x),
                                u = i % x;
                            let l = 0;
                            for (let u = 0; u < h.batchSize; ++u)
                                for (let c = t; c < n; ++c) {
                                    const t = e + c * p - b;
                                    for (let e = r; e < a; ++e) {
                                        const n = s + e * d - y;
                                        l += k.get(u, t, n, o) * I.get(u, c, e, i)
                                    }
                                }
                            g.set(l, e, s, o, u)
                        }
                    }
                }
                return n.makeTensorInfo(g.shape, g.dtype, g.values)
            }
        };
        const YI = {
            kernelName: ot,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    filter: a
                } = t, {
                    strides: i,
                    dilations: o,
                    pad: u,
                    dimRoundingMode: l,
                    inputShape: c
                } = s;
                Hk([r, a], "depthwiseConv2DNativeBackpropInput");
                const h = ee(r.shape),
                    p = ee(a.shape),
                    d = Fi(c, a.shape, i, o, u, l, !0),
                    f = new ir(d.inShape, "float32"),
                    m = f.values,
                    [g, y, b] = f.strides,
                    x = n.data.get(r.dataId).values,
                    [w, k, v] = h,
                    I = n.data.get(a.dataId).values,
                    [N, S, T] = p,
                    {
                        batchSize: $,
                        filterHeight: C,
                        filterWidth: E,
                        inChannels: A,
                        inHeight: R,
                        inWidth: F,
                        outChannels: D,
                        outHeight: _,
                        outWidth: O,
                        strideHeight: M,
                        strideWidth: L
                    } = d,
                    z = C - 1 - d.padInfo.top,
                    B = E - 1 - d.padInfo.left,
                    P = D / A;
                for (let e = 0; e < $; ++e)
                    for (let t = 0; t < A; ++t)
                        for (let n = 0; n < R; ++n) {
                            const s = n - z,
                                r = Math.max(0, Math.ceil(s / M)),
                                a = Math.min(_, (C + s) / M);
                            for (let i = 0; i < F; ++i) {
                                const o = i - B,
                                    u = Math.max(0, Math.ceil(o / L)),
                                    l = Math.min(O, (E + o) / L);
                                let c = 0;
                                for (let n = r; n < a; ++n) {
                                    const r = n * M - s;
                                    for (let s = u; s < l; ++s) {
                                        const a = w * e + k * n + v * s,
                                            i = N * (C - 1 - r) + S * (E - 1 - (s * L - o)) + T * t;
                                        for (let e = 0; e < P; ++e) {
                                            c += x[a + (t * P + e)] * I[i + e]
                                        }
                                    }
                                }
                                m[g * e + y * n + b * i + t] = c
                            }
                        }
                return n.makeTensorInfo(f.shape, f.dtype, f.values)
            }
        };
        const JI = {
                kernelName: ut,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        x: s
                    } = t, r = O(s.shape), a = n.data.get(s.dataId).values, i = Aa([r, r], s.dtype), o = i.values;
                    for (let e = 0; e < a.length; e++) o[e * r + e] = a[e];
                    const u = [...s.shape, ...s.shape];
                    return n.makeTensorInfo(u, i.dtype, i.values)
                }
            },
            ZI = {
                kernelName: lt,
                backendName: "cpu",
                kernelFunc: ({
                    inputs: e,
                    backend: t,
                    attrs: n
                }) => {
                    const {
                        x: s,
                        filter: r
                    } = e, {
                        strides: a,
                        pad: i,
                        dilations: o
                    } = n, u = t, l = u.data.get(s.dataId).values, c = s.shape.length, h = u.data.get(r.dataId).values, p = r.shape.length, {
                        batchSize: d,
                        inHeight: f,
                        inWidth: m,
                        inChannels: g,
                        outHeight: y,
                        outWidth: b,
                        padInfo: x,
                        strideHeight: w,
                        strideWidth: k,
                        filterHeight: v,
                        filterWidth: I,
                        dilationHeight: N,
                        dilationWidth: S,
                        outShape: T
                    } = Ei(s.shape, r.shape, a, i, "NHWC", o), $ = O(T), C = T.length, E = H(s.dtype, $);
                    for (let e = 0; e < d; ++e)
                        for (let t = 0; t < y; ++t) {
                            const n = t * w - x.top;
                            for (let a = 0; a < b; ++a) {
                                const i = a * k - x.left;
                                for (let o = 0; o < g; ++o) {
                                    let u = Number.MIN_SAFE_INTEGER;
                                    for (let t = 0; t < v; ++t) {
                                        const a = n + t * N;
                                        if (a >= 0 && a < f)
                                            for (let n = 0; n < I; ++n) {
                                                const d = i + n * S;
                                                if (d >= 0 && d < m) {
                                                    const i = oe([e, a, d, o], c, ee(s.shape)),
                                                        f = oe([t, n, o], p, ee(r.shape)),
                                                        m = l[i] + h[f];
                                                    m > u && (u = m)
                                                }
                                            }
                                    }
                                    E[oe([e, t, a, o], C, ee(T))] = u
                                }
                            }
                        }
                    return {
                        dataId: u.write(Ks(E, s.dtype), T, s.dtype),
                        shape: T,
                        dtype: s.dtype
                    }
                }
            },
            QI = {
                kernelName: ht,
                backendName: "cpu",
                kernelFunc: ({
                    inputs: e,
                    backend: t,
                    attrs: n
                }) => {
                    const {
                        x: s,
                        filter: r,
                        dy: a
                    } = e, {
                        strides: i,
                        pad: o,
                        dilations: u
                    } = n, l = t, c = ne(s.shape, l.data.get(s.dataId).values), h = ne(r.shape, l.data.get(r.dataId).values), {
                        batchSize: p,
                        inHeight: d,
                        inWidth: f,
                        inChannels: m,
                        outHeight: g,
                        outWidth: y,
                        padInfo: b,
                        strideHeight: x,
                        strideWidth: w,
                        filterHeight: k,
                        filterWidth: v,
                        dilationHeight: I,
                        dilationWidth: N,
                        outShape: S
                    } = Ei(s.shape, r.shape, i, o, "NHWC", u);
                    R(a.rank === S.length, (() => `Error in ${ht}, dy must have the same rank as output ${S.length}, but got ${a.rank}`));
                    const T = ne(S, l.data.get(a.dataId).values),
                        $ = ae(r.shape, r.dtype);
                    for (let e = 0; e < p; ++e)
                        for (let t = 0; t < g; ++t) {
                            const n = t * x - b.top;
                            for (let s = 0; s < y; ++s) {
                                const r = s * w - b.left;
                                for (let a = 0; a < m; ++a) {
                                    let i = Number.MIN_SAFE_INTEGER,
                                        o = 0,
                                        u = 0;
                                    for (let t = 0; t < k; ++t) {
                                        const s = n + t * I;
                                        if (s >= 0 && s < d)
                                            for (let n = 0; n < v; ++n) {
                                                const l = r + n * N;
                                                if (l >= 0 && l < f) {
                                                    const r = c[e][s][l][a] + h[t][n][a];
                                                    r > i && (i = r, o = t, u = n)
                                                }
                                            }
                                    }
                                    $[o][u][a] += T[e][t][s][a]
                                }
                            }
                        }
                    return {
                        dataId: l.write(Ks($, s.dtype), r.shape, r.dtype),
                        shape: r.shape,
                        dtype: r.dtype
                    }
                }
            },
            eN = {
                kernelName: ct,
                backendName: "cpu",
                kernelFunc: ({
                    inputs: e,
                    backend: t,
                    attrs: n
                }) => {
                    const {
                        x: s,
                        filter: r,
                        dy: a
                    } = e, {
                        strides: i,
                        pad: o,
                        dilations: u
                    } = n, l = t, c = ne(s.shape, l.data.get(s.dataId).values), h = ne(r.shape, l.data.get(r.dataId).values), {
                        batchSize: p,
                        inHeight: d,
                        inWidth: f,
                        inChannels: m,
                        outHeight: g,
                        outWidth: y,
                        padInfo: b,
                        strideHeight: x,
                        strideWidth: w,
                        filterHeight: k,
                        filterWidth: v,
                        dilationHeight: I,
                        dilationWidth: N,
                        outShape: S
                    } = Ei(s.shape, r.shape, i, o, "NHWC", u);
                    R(a.rank === S.length, (() => `Error in ${ct}, dy must have the same rank as output ${S.length}, but got ${a.rank}`));
                    const T = ne(S, l.data.get(a.dataId).values),
                        $ = ae(s.shape, s.dtype);
                    for (let e = 0; e < p; ++e)
                        for (let t = 0; t < g; ++t) {
                            const n = t * x - b.top;
                            for (let s = 0; s < y; ++s) {
                                const r = s * w - b.left;
                                for (let a = 0; a < m; ++a) {
                                    let i = Number.MIN_SAFE_INTEGER,
                                        o = n < 0 ? 0 : n,
                                        u = r < 0 ? 0 : r;
                                    for (let t = 0; t < k; ++t) {
                                        const s = n + t * I;
                                        if (s >= 0 && s < d)
                                            for (let n = 0; n < v; ++n) {
                                                const l = r + n * N;
                                                if (l >= 0 && l < f) {
                                                    const r = c[e][s][l][a] + h[t][n][a];
                                                    r > i && (i = r, o = s, u = l)
                                                }
                                            }
                                    }
                                    $[e][o][u][a] += T[e][t][s][a]
                                }
                            }
                        }
                    return {
                        dataId: l.write(Ks($, s.dtype), s.shape, s.dtype),
                        shape: s.shape,
                        dtype: s.dtype
                    }
                }
            },
            tN = nv(((e, t) => e * t)),
            nN = Iv(((e, t, n, s) => ({
                real: e * n - t * s,
                imag: e * s + t * n
            }))),
            sN = vv(un, tN, nN),
            rN = {
                kernelName: un,
                backendName: "cpu",
                kernelFunc: sN
            };

        function aN(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                axis: a,
                keepDims: i
            } = s;
            let o;
            Hk(r, "sum"), o = "bool" === r.dtype ? wv({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    dtype: "int32"
                }
            }) : Zk({
                inputs: {
                    x: r
                },
                backend: n
            });
            const u = o.shape.length,
                l = W(a, o.shape),
                c = Go(l, u);
            let h = l,
                p = o;
            null != c && (p = Uv({
                inputs: {
                    x: o
                },
                backend: n,
                attrs: {
                    perm: c
                }
            }), h = jo(h.length, u)), Vo("sum", h, p.shape.length);
            const [d, f] = Uo(p.shape, h);
            let m = yv(n, d, xr(p.dtype, "int32"));
            const g = O(f),
                y = n.data.get(m.dataId).values,
                b = n.data.get(p.dataId).values;
            for (let e = 0; e < y.length; ++e) {
                const t = e * g;
                let n = 0;
                for (let e = 0; e < g; ++e) n += b[t + e];
                y[e] = n
            }
            if (i) {
                const e = m;
                m = Cv({
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: Wo(m.shape, l)
                    }
                }), n.disposeIntermediateTensorInfo(e)
            }
            return n.disposeIntermediateTensorInfo(o), null != c && n.disposeIntermediateTensorInfo(p), m
        }
        const iN = {
            kernelName: Hn,
            backendName: "cpu",
            kernelFunc: aN
        };
        const oN = {
            kernelName: dt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    equation: r
                } = s, a = t, {
                    allDims: i,
                    summedDims: o,
                    idDims: u
                } = jc(r, a.length);
                Kc(i.length, u, a);
                const {
                    path: l,
                    steps: c
                } = Xc(o, u), h = c.length;
                let p = null,
                    d = i.length;
                const f = [];
                for (let e = 0; e < h; ++e) {
                    for (const t of c[e]) {
                        const {
                            permutationIndices: e,
                            expandDims: s
                        } = qc(d, u[t]);
                        let r;
                        Yc(e) ? r = a[t] : (r = Uv({
                            inputs: {
                                x: a[t]
                            },
                            backend: n,
                            attrs: {
                                perm: e
                            }
                        }), f.push(r));
                        const i = r.shape.slice();
                        for (let e = 0; e < s.length; ++e) i.splice(s[e], 0, 1);
                        M(r.shape, i) || (r = Cv({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                shape: i
                            }
                        }), f.push(r)), null === p ? p = r : (p = sN({
                            inputs: {
                                a: r,
                                b: p
                            },
                            backend: n
                        }), f.push(p))
                    }
                    e < h - 1 && (l[e] >= 0 && (p = aN({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            axis: l[e] - (i.length - d),
                            keepDims: !1
                        }
                    }), f.push(p)), d--)
                }
                for (const e of f) e !== p && n.disposeIntermediateTensorInfo(e);
                return p
            }
        };
        const uN = {
                kernelName: mt,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        dy: s,
                        y: r
                    } = t;
                    Hk([s, r], "eluGrad");
                    const a = new Float32Array(O(r.shape)),
                        i = n.data.get(r.dataId).values,
                        o = n.data.get(s.dataId).values;
                    for (let e = 0; e < i.length; ++e) {
                        const t = i[e];
                        a[e] = t >= 1 ? o[e] : o[e] * (t + 1)
                    }
                    return n.makeTensorInfo(r.shape, "float32", a)
                }
            },
            lN = nv(((e, t) => e === t ? 1 : 0)),
            cN = vv(yt, lN, null, "bool"),
            hN = {
                kernelName: yt,
                backendName: "cpu",
                kernelFunc: cN
            },
            pN = Cc,
            dN = Ec,
            fN = Ac,
            mN = Rc,
            gN = Fc,
            yN = Dc,
            bN = Kk(gt, (e => {
                const t = Math.sign(e),
                    n = Math.abs(e),
                    s = 1 / (1 + pN * n);
                return t * (1 - ((((yN * s + gN) * s + mN) * s + fN) * s + dN) * s * Math.exp(-n * n))
            })),
            xN = {
                kernelName: gt,
                backendName: "cpu",
                kernelFunc: bN
            },
            wN = cv((e => Math.exp(e))),
            kN = Xk(bt, wN, "float32"),
            vN = {
                kernelName: bt,
                backendName: "cpu",
                kernelFunc: kN
            };

        function IN(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                input: r
            } = t, {
                dim: a
            } = s, i = r.shape.length, o = r.shape.slice();
            let u = a;
            return a < 0 && (R(-(i + 1) <= a, (() => `Axis must be in the interval [${-(i+1)}, ${i}]`)), u = i + a + 1), o.splice(u, 0, 1), Cv({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    shape: o
                }
            })
        }
        const NN = {
                kernelName: xt,
                backendName: "cpu",
                kernelFunc: IN
            },
            SN = cv((e => Math.expm1(e))),
            TN = Xk(wt, SN),
            $N = {
                kernelName: wt,
                backendName: "cpu",
                kernelFunc: TN
            },
            CN = nv(((e, t) => e / t)),
            EN = vv(pt, CN),
            AN = {
                kernelName: pt,
                backendName: "cpu",
                kernelFunc: EN
            },
            RN = nv(((e, t) => e - t)),
            FN = Iv(((e, t, n, s) => ({
                real: e - n,
                imag: t - s
            }))),
            DN = vv(is, RN, FN),
            _N = {
                kernelName: is,
                backendName: "cpu",
                kernelFunc: DN
            };

        function ON(e, t, n) {
            const s = e.shape,
                r = s[0],
                a = s[1],
                i = n.data.get(e.dataId),
                o = i.complexTensorInfos.real,
                u = i.complexTensorInfos.imag,
                l = [r, a],
                c = O(l),
                h = G("float32", c),
                p = G("float32", c);
            for (let e = 0; e < r; e++) {
                const s = dI({
                        inputs: {
                            x: o
                        },
                        backend: n,
                        attrs: {
                            begin: [e, 0],
                            size: [1, a]
                        }
                    }),
                    r = dI({
                        inputs: {
                            x: u
                        },
                        backend: n,
                        attrs: {
                            begin: [e, 0],
                            size: [1, a]
                        }
                    }),
                    i = mv({
                        inputs: {
                            real: s,
                            imag: r
                        },
                        backend: n
                    }),
                    {
                        real: l,
                        imag: c
                    } = MN(i, t, n),
                    d = _c(l, c);
                for (let t = 0; t < a; t++) {
                    const n = zc(d, t);
                    h[e * a + t] = n.real, p[e * a + t] = n.imag
                }
                n.disposeIntermediateTensorInfo(s), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(i)
            }
            const d = n.makeTensorInfo(l, "float32", h),
                f = n.makeTensorInfo(l, "float32", p),
                m = mv({
                    inputs: {
                        real: d,
                        imag: f
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), m
        }

        function MN(e, t, n) {
            const s = O(e.shape),
                r = n.data.get(e.dataId),
                a = n.data.get(r.complexTensorInfos.real.dataId).values,
                i = n.data.get(r.complexTensorInfos.imag.dataId).values;
            if ((o = s) & o - 1) {
                const e = function(e, t, n) {
                    const s = new Float32Array(2 * t);
                    for (let r = 0; r < t; r++) {
                        let a = 0,
                            i = 0;
                        for (let s = 0; s < t; s++) {
                            const o = Uc(r * s, t, n),
                                u = zc(e, s);
                            a += u.real * o.real - u.imag * o.imag, i += u.real * o.imag + u.imag * o.real
                        }
                        n && (a /= t, i /= t), Bc(s, a, i, r)
                    }
                    return s
                }(_c(a, i), s, t);
                return Oc(e)
            } {
                const r = LN(a, i, s, t, n),
                    o = [e.shape[0], e.shape[1]];
                if (t) {
                    const e = n.makeTensorInfo(o, "float32", r.real),
                        t = n.makeTensorInfo(o, "float32", r.imag),
                        a = n.makeTensorInfo([], "float32", qs(s, "float32")),
                        i = Zk({
                            inputs: {
                                x: a
                            },
                            backend: n
                        }),
                        u = AN.kernelFunc({
                            inputs: {
                                a: e,
                                b: a
                            },
                            backend: n
                        }),
                        l = AN.kernelFunc({
                            inputs: {
                                a: t,
                                b: i
                            },
                            backend: n
                        }),
                        c = n.data.get(u.dataId).values,
                        h = n.data.get(l.dataId).values;
                    return n.disposeIntermediateTensorInfo(e), n.disposeIntermediateTensorInfo(t), n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(l), {
                        real: c,
                        imag: h
                    }
                }
                return r
            }
            var o
        }

        function LN(e, t, n, s, r) {
            if (1 === n) return {
                real: e,
                imag: t
            };
            const a = _c(e, t),
                i = n / 2,
                o = Mc(a),
                u = o.real,
                l = o.imag,
                c = [u.length],
                h = r.makeTensorInfo(c, "float32", u),
                p = r.makeTensorInfo(c, "float32", l),
                d = mv({
                    inputs: {
                        real: h,
                        imag: p
                    },
                    backend: r
                }),
                f = Lc(a),
                m = f.real,
                g = f.imag,
                y = [m.length],
                b = r.makeTensorInfo(y, "float32", m),
                x = r.makeTensorInfo(y, "float32", g),
                w = mv({
                    inputs: {
                        real: b,
                        imag: x
                    },
                    backend: r
                }),
                k = LN(u, l, i, s, r),
                v = k.real,
                I = k.imag,
                N = [v.length],
                S = r.makeTensorInfo(N, "float32", v),
                T = r.makeTensorInfo(N, "float32", I),
                $ = mv({
                    inputs: {
                        real: S,
                        imag: T
                    },
                    backend: r
                }),
                C = LN(m, g, i, s, r),
                E = C.real,
                A = C.imag,
                R = [E.length],
                F = r.makeTensorInfo(R, "float32", E),
                D = r.makeTensorInfo(R, "float32", A),
                _ = mv({
                    inputs: {
                        real: F,
                        imag: D
                    },
                    backend: r
                }),
                O = Pc(n, s),
                M = [O.real.length],
                L = r.makeTensorInfo(M, "float32", O.real),
                z = r.makeTensorInfo(M, "float32", O.imag),
                B = mv({
                    inputs: {
                        real: L,
                        imag: z
                    },
                    backend: r
                }),
                P = sN({
                    inputs: {
                        a: B,
                        b: _
                    },
                    backend: r
                }),
                U = Tv({
                    inputs: {
                        a: $,
                        b: P
                    },
                    backend: r
                }),
                W = DN({
                    inputs: {
                        a: $,
                        b: P
                    },
                    backend: r
                }),
                V = bv({
                    inputs: {
                        input: U
                    },
                    backend: r
                }),
                G = bv({
                    inputs: {
                        input: W
                    },
                    backend: r
                }),
                H = $I({
                    inputs: {
                        input: U
                    },
                    backend: r
                }),
                j = $I({
                    inputs: {
                        input: W
                    },
                    backend: r
                }),
                q = EI({
                    inputs: [V, G],
                    backend: r,
                    attrs: {
                        axis: 0
                    }
                }),
                K = EI({
                    inputs: [H, j],
                    backend: r,
                    attrs: {
                        axis: 0
                    }
                }),
                X = r.data.get(q.dataId).values,
                Y = r.data.get(K.dataId).values;
            return r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(d), r.disposeIntermediateTensorInfo(b), r.disposeIntermediateTensorInfo(x), r.disposeIntermediateTensorInfo(w), r.disposeIntermediateTensorInfo(S), r.disposeIntermediateTensorInfo(T), r.disposeIntermediateTensorInfo($), r.disposeIntermediateTensorInfo(F), r.disposeIntermediateTensorInfo(D), r.disposeIntermediateTensorInfo(_), r.disposeIntermediateTensorInfo(L), r.disposeIntermediateTensorInfo(z), r.disposeIntermediateTensorInfo(B), r.disposeIntermediateTensorInfo(P), r.disposeIntermediateTensorInfo(U), r.disposeIntermediateTensorInfo(W), r.disposeIntermediateTensorInfo(V), r.disposeIntermediateTensorInfo(H), r.disposeIntermediateTensorInfo(G), r.disposeIntermediateTensorInfo(j), r.disposeIntermediateTensorInfo(q), r.disposeIntermediateTensorInfo(K), {
                real: X,
                imag: Y
            }
        }
        const zN = {
            kernelName: kt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    input: s
                } = t, r = O(s.shape), a = s.shape[s.shape.length - 1], i = Cv({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        shape: [r / a, a]
                    }
                }), o = ON(i, !1, n), u = Cv({
                    inputs: {
                        x: o
                    },
                    backend: n,
                    attrs: {
                        shape: s.shape
                    }
                });
                return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), u
            }
        };

        function BN(e) {
            const {
                backend: t,
                attrs: n
            } = e, {
                shape: s,
                value: r,
                dtype: a
            } = n, i = a || J(r), o = H(i, O(s));
            return function(e, t) {
                e.fill(t)
            }(o, r), t.makeTensorInfo(s, i, o)
        }
        const PN = {
            kernelName: vt,
            backendName: "cpu",
            kernelFunc: BN
        };
        const UN = {
                kernelName: It,
                backendName: "cpu",
                kernelFunc: ({
                    inputs: e,
                    attrs: t,
                    backend: n
                }) => {
                    const {
                        image: s
                    } = e, r = n, a = G(s.dtype, O(s.shape)), [i, o, u, l] = s.shape, c = r.data.get(s.dataId).values;
                    for (let e = 0; e < i; e++) {
                        const t = e * u * o * l;
                        for (let e = 0; e < o; e++) {
                            const n = e * (u * l);
                            for (let e = 0; e < u; e++) {
                                const s = e * l;
                                for (let r = 0; r < l; r++) {
                                    const i = Math.round(u - e - 1),
                                        o = t + n + s + r;
                                    let h = c[o];
                                    if (i >= 0 && i < u) {
                                        h = c[t + n + i * l + r]
                                    }
                                    a[o] = h
                                }
                            }
                        }
                    }
                    return {
                        dataId: r.write(a, s.shape, s.dtype),
                        shape: s.shape,
                        dtype: s.dtype
                    }
                }
            },
            WN = cv((e => Math.floor(e))),
            VN = Xk(Nt, WN),
            GN = {
                kernelName: Nt,
                backendName: "cpu",
                kernelFunc: VN
            },
            HN = nv(((e, t) => Math.floor(e / t))),
            jN = vv(St, HN, null, "int32"),
            qN = {
                kernelName: St,
                backendName: "cpu",
                kernelFunc: jN
            };
        const KN = {
            kernelName: ks,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a,
                    bias: i,
                    preluActivationWeights: o
                } = t, {
                    strides: u,
                    pad: l,
                    dataFormat: c,
                    dilations: h,
                    dimRoundingMode: p,
                    activation: d,
                    leakyreluAlpha: f
                } = s;
                let m = RI({
                    inputs: {
                        x: r,
                        filter: a
                    },
                    backend: n,
                    attrs: {
                        strides: u,
                        pad: l,
                        dataFormat: c,
                        dilations: h,
                        dimRoundingMode: p
                    }
                });
                if (i) {
                    const e = m;
                    if ("NCHW" === c && 1 === i.shape.length && 1 !== i.shape[0]) {
                        const e = Cv({
                            inputs: {
                                x: i
                            },
                            backend: n,
                            attrs: {
                                shape: [i.shape[0], 1, 1]
                            }
                        });
                        m = Tv({
                            inputs: {
                                a: m,
                                b: e
                            },
                            backend: n
                        }), n.disposeIntermediateTensorInfo(e)
                    } else m = Tv({
                        inputs: {
                            a: m,
                            b: i
                        },
                        backend: n
                    });
                    n.disposeIntermediateTensorInfo(e)
                }
                if (d) {
                    const e = m;
                    if ("NCHW" === c && "prelu" === d && 1 === o.shape.length && 1 !== o.shape[0]) {
                        const e = Cv({
                            inputs: {
                                x: o
                            },
                            backend: n,
                            attrs: {
                                shape: [o.shape[0], 1, 1]
                            }
                        });
                        m = fv(n, m, d, e, f), n.disposeIntermediateTensorInfo(e)
                    } else m = fv(n, m, d, o, f);
                    n.disposeIntermediateTensorInfo(e)
                }
                return m
            }
        };
        const XN = {
            kernelName: vs,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a,
                    bias: i,
                    preluActivationWeights: o
                } = t, {
                    strides: u,
                    pad: l,
                    dataFormat: c,
                    dilations: h,
                    dimRoundingMode: p,
                    activation: d,
                    leakyreluAlpha: f
                } = s;
                let m = qI({
                    inputs: {
                        x: r,
                        filter: a
                    },
                    backend: n,
                    attrs: {
                        strides: u,
                        pad: l,
                        dataFormat: c,
                        dilations: h,
                        dimRoundingMode: p
                    }
                });
                if (i) {
                    const e = m;
                    m = Tv({
                        inputs: {
                            a: m,
                            b: i
                        },
                        backend: n
                    }), n.disposeIntermediateTensorInfo(e)
                }
                if (d) {
                    const e = m;
                    m = fv(n, m, d, o, f), n.disposeIntermediateTensorInfo(e)
                }
                return m
            }
        };

        function YN(e, t, n, s, r, a, i, o, u) {
            const l = Aa([s, a], n);
            for (let n = 0; n < s; n++) {
                const s = [];
                let c = 0;
                for (let t = 0; t < r; t++) {
                    const a = e[n * r + t];
                    c += a * i[t], s.push(a)
                }
                if (c < 0 || c >= u / a) throw new Error(`Invalid indices: ${s} does not index into ${o}`);
                for (let e = 0; e < a; e++) l.values[n * a + e] = t.get(...t.indexToLoc(c * a + e))
            }
            return l
        }
        const JN = {
            kernelName: Ct,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    params: s,
                    indices: r
                } = t, a = O(s.shape), i = r.shape, o = i[i.length - 1], [u, l, c, h] = vc(s, r);
                if (0 === l) return n.makeTensorInfo(u, s.dtype, []);
                const p = YN(n.data.get(r.dataId).values, n.bufferSync(s), s.dtype, l, o, c, h, s.shape, a);
                return n.makeTensorInfo(u, s.dtype, p.values)
            }
        };

        function ZN(e, t, n) {
            const s = Aa(n, e.dtype);
            for (let n = 0; n < s.size; ++n) {
                const r = s.indexToLoc(n).slice(),
                    a = r[0],
                    i = r[2],
                    o = t.locToIndex([a, i]);
                r[2] = t.values[o];
                const u = e.locToIndex(r);
                0 <= u && u < e.values.length && (s.values[n] = e.values[u])
            }
            return s
        }
        const QN = {
                kernelName: $t,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r,
                        indices: a
                    } = t, {
                        axis: i,
                        batchDims: o
                    } = s;
                    Hk([r, a], "gatherV2");
                    const u = W(i, r.shape)[0],
                        l = n.data.get(a.dataId).values,
                        c = r.shape[u];
                    for (let e = 0; e < l.length; ++e) {
                        const t = l[e];
                        R(t <= c - 1 && t >= 0, (() => `GatherV2: the index value ${t} is not in [0, ${c-1}]`))
                    }
                    let h = o;
                    null == o && (h = 0);
                    const p = O(a.shape),
                        d = dh(r, a, u, h),
                        f = Cv({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                shape: [d.batchSize, d.outerSize, d.dimSize, d.sliceSize]
                            }
                        }),
                        m = Cv({
                            inputs: {
                                x: a
                            },
                            backend: n,
                            attrs: {
                                shape: [d.batchSize, p / d.batchSize]
                            }
                        }),
                        g = [d.batchSize, d.outerSize, p / d.batchSize, d.sliceSize],
                        y = n.bufferSync(m),
                        b = ZN(n.bufferSync(f), y, g);
                    return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), n.makeTensorInfo(d.outputShape, b.dtype, b.values)
                }
            },
            eS = nv(((e, t) => e > t ? 1 : 0)),
            tS = vv(Et, eS, null, "bool"),
            nS = {
                kernelName: Et,
                backendName: "cpu",
                kernelFunc: tS
            },
            sS = nv(((e, t) => e >= t ? 1 : 0)),
            rS = vv(At, sS, null, "bool"),
            aS = {
                kernelName: At,
                backendName: "cpu",
                kernelFunc: rS
            };
        const iS = {
                kernelName: Ft,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        input: s
                    } = t, r = O(s.shape), a = s.shape[s.shape.length - 1], i = Cv({
                        inputs: {
                            x: s
                        },
                        backend: n,
                        attrs: {
                            shape: [r / a, a]
                        }
                    }), o = ON(i, !0, n), u = Cv({
                        inputs: {
                            x: o
                        },
                        backend: n,
                        attrs: {
                            shape: s.shape
                        }
                    });
                    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), u
                }
            },
            oS = Kk(_t, (e => Number.isFinite(e) ? 1 : 0), "bool"),
            uS = {
                kernelName: _t,
                backendName: "cpu",
                kernelFunc: oS
            },
            lS = Kk(Ot, (e => Math.abs(e) === 1 / 0 ? 1 : 0), "bool"),
            cS = {
                kernelName: Ot,
                backendName: "cpu",
                kernelFunc: lS
            },
            hS = Kk(Mt, (e => Number.isNaN(e) ? 1 : 0), "bool"),
            pS = {
                kernelName: Mt,
                backendName: "cpu",
                kernelFunc: hS
            },
            dS = nv(((e, t) => e < t ? 1 : 0)),
            fS = vv(zt, dS, null, "bool"),
            mS = {
                kernelName: zt,
                backendName: "cpu",
                kernelFunc: fS
            },
            gS = nv(((e, t) => e <= t ? 1 : 0)),
            yS = vv(Bt, gS, null, "bool"),
            bS = {
                kernelName: Bt,
                backendName: "cpu",
                kernelFunc: yS
            };

        function xS(e, t, n) {
            const s = (t - e) / (n - 1),
                r = re(n, "float32");
            r[0] = e;
            for (let e = 1; e < r.length; e++) r[e] = r[e - 1] + s;
            return r
        }
        const wS = {
                kernelName: Pt,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        backend: t,
                        attrs: n
                    } = e, {
                        start: s,
                        stop: r,
                        num: a
                    } = n, i = xS(s, r, a);
                    return t.makeTensorInfo([i.length], "float32", i)
                }
            },
            kS = cv((e => Math.log(e))),
            vS = Xk(Ut, kS),
            IS = {
                kernelName: Ut,
                backendName: "cpu",
                kernelFunc: vS
            },
            NS = Kk(Wt, (e => Math.log1p(e))),
            SS = {
                kernelName: Wt,
                backendName: "cpu",
                kernelFunc: NS
            },
            TS = nv(((e, t) => e && t)),
            $S = vv(Vt, TS, null, "bool"),
            CS = {
                kernelName: Vt,
                backendName: "cpu",
                kernelFunc: $S
            },
            ES = Kk(Gt, (e => e ? 0 : 1), "bool"),
            AS = {
                kernelName: Gt,
                backendName: "cpu",
                kernelFunc: ES
            },
            RS = nv(((e, t) => e || t)),
            FS = vv(Ht, RS, null, "bool"),
            DS = {
                kernelName: Ht,
                backendName: "cpu",
                kernelFunc: FS
            };
        const _S = {
            kernelName: jt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    depthRadius: a,
                    bias: i,
                    alpha: o,
                    beta: u
                } = s;
                Hk(r, "LRN");
                const l = r.shape[3],
                    c = l - 1,
                    h = n.data.get(r.dataId).values,
                    p = O(r.shape),
                    d = new Float32Array(p);

                function f(e) {
                    const t = e % l;
                    let n = e - t + Math.max(0, t - a);
                    const s = e - t + Math.min(t + a, c);
                    let r = 0;
                    for (; n <= s; n++) {
                        const e = h[n];
                        r += e * e
                    }
                    return r
                }
                for (let e = 0; e < p; e++) {
                    const t = f(e),
                        n = h[e] * Math.pow(i + o * t, -u);
                    d[e] = n
                }
                return n.makeTensorInfo(r.shape, r.dtype, d)
            }
        };
        const OS = {
            kernelName: qt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    y: a,
                    dy: i
                } = t, {
                    depthRadius: o,
                    bias: u,
                    alpha: l,
                    beta: c
                } = s;
                Hk(i, "LRNGrad");
                const h = O(i.shape),
                    p = i.shape[3],
                    d = n.data.get(i.dataId).values,
                    f = n.data.get(r.dataId).values,
                    m = n.data.get(a.dataId).values,
                    g = new Float32Array(h),
                    y = h;
                for (let e = 0; e < y; e++) {
                    const t = e % p,
                        n = e - t + Math.max(0, t - o),
                        s = e - t + Math.min(p, t + o + 1);
                    let r = 0;
                    for (let e = n; e < s; e++) r += Math.pow(f[e], 2);
                    r = l * r + u;
                    for (let t = n; t < s; t++) {
                        let n = -2 * l * c * f[t] * m[e] / r;
                        e === t && (n += Math.pow(r, -c)), n *= d[e], g[t] += n
                    }
                }
                return n.makeTensorInfo(i.shape, r.dtype, g)
            }
        };

        function MS(e, t, n, s) {
            const r = G(s, O(n));
            for (let n = 0; n < r.length; ++n) {
                const s = n * t;
                let a = e[s];
                for (let n = 0; n < t; ++n) {
                    const t = e[s + n];
                    (Number.isNaN(t) || t > a) && (a = t)
                }
                r[n] = a
            }
            return r
        }

        function LS(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                reductionIndices: a,
                keepDims: i
            } = s, o = n;
            let u = r.shape;
            const l = u.length,
                c = W(a, u);
            let h = c;
            const p = Go(h, l);
            let d = o.data.get(r.dataId).values;
            if (null != p) {
                const e = new Array(l);
                for (let t = 0; t < e.length; t++) e[t] = u[p[t]];
                d = Pv(d, u, r.dtype, p, e), h = jo(h.length, l), u = e
            }
            Hk(r, "max"), Vo("max", h, l);
            const [f, m] = Uo(u, h), g = MS(d, O(m), f, r.dtype), y = o.write(g, f, r.dtype);
            let b = f;
            if (i) {
                b = Wo(f, c)
            }
            return {
                dataId: y,
                shape: b,
                dtype: r.dtype
            }
        }
        const zS = {
                kernelName: Kt,
                backendName: "cpu",
                kernelFunc: LS
            },
            BS = nv(((e, t) => Math.max(e, t))),
            PS = vv(Xt, BS),
            US = {
                kernelName: Xt,
                backendName: "cpu",
                kernelFunc: PS
            };
        const WS = {
            kernelName: Yt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t;
                Hk(r, "maxPool");
                const {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u
                } = s;
                R(Pi(i, 1), (() => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
                const l = Ai(r.shape, a, i, 1, o, u);
                let c;
                if (1 === l.filterWidth && 1 === l.filterHeight && M(l.inShape, l.outShape)) c = Zk({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                else {
                    const e = n.data.get(r.dataId).values,
                        t = ee(r.shape),
                        s = rI(e, r.shape, r.dtype, t, l, "max");
                    c = n.makeTensorInfo(l.outShape, r.dtype, s.values)
                }
                return c
            }
        };
        const VS = {
            kernelName: Zt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u,
                    dataFormat: l
                } = s;
                Hk(r, "maxPool3d");
                const c = Ri(r.shape, a, i, 1, o, u, l),
                    h = iI(n.data.get(r.dataId).values, r.shape, r.dtype, ee(r.shape), c, "max");
                return n.makeTensorInfo(h.shape, "float32", h.values)
            }
        };
        const GS = {
            kernelName: Qt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a
                } = t, {
                    filterSize: i,
                    strides: o,
                    pad: u,
                    dimRoundingMode: l
                } = s;
                Hk([r, a], "maxPool3DGrad");
                const c = Ri(a.shape, i, o, 1, u, l),
                    h = function(e, t) {
                        const n = Aa(t.outShape, "int32"),
                            s = t.strideDepth,
                            r = t.strideHeight,
                            a = t.strideWidth,
                            i = t.dilationDepth,
                            o = t.dilationHeight,
                            u = t.dilationWidth,
                            l = t.effectiveFilterDepth,
                            c = t.effectiveFilterHeight,
                            h = t.effectiveFilterWidth,
                            p = t.padInfo.front,
                            d = t.padInfo.top,
                            f = t.padInfo.left;
                        for (let m = 0; m < t.batchSize; ++m)
                            for (let g = 0; g < t.inChannels; ++g)
                                for (let y = 0; y < t.outDepth; ++y) {
                                    const b = y * s - p;
                                    let x = b;
                                    for (; x < 0;) x += i;
                                    const w = Math.min(t.inDepth, l + b);
                                    for (let s = 0; s < t.outHeight; ++s) {
                                        const l = s * r - d;
                                        let p = l;
                                        for (; p < 0;) p += o;
                                        const k = Math.min(t.inHeight, c + l);
                                        for (let r = 0; r < t.outWidth; ++r) {
                                            const d = r * a - f;
                                            let v = d;
                                            for (; v < 0;) v += u;
                                            const I = Math.min(t.inWidth, h + d);
                                            let N = Number.NEGATIVE_INFINITY,
                                                S = -1;
                                            for (let t = x; t < w; t += i) {
                                                const n = t - b;
                                                for (let s = p; s < k; s += o) {
                                                    const r = s - l;
                                                    for (let a = v; a < I; a += u) {
                                                        const i = a - d,
                                                            o = e.get(m, t, s, a, g);
                                                        o >= N && (N = o, S = n * c * h + r * c + i)
                                                    }
                                                }
                                            }
                                            n.set(S, m, y, s, r, g)
                                        }
                                    }
                                }
                        return n
                    }(n.bufferSync(a), c),
                    p = c.strideDepth,
                    d = c.strideHeight,
                    f = c.strideWidth,
                    m = c.dilationDepth,
                    g = c.dilationHeight,
                    y = c.dilationWidth,
                    b = c.effectiveFilterDepth,
                    x = c.effectiveFilterHeight,
                    w = c.effectiveFilterWidth,
                    k = b - 1 - c.padInfo.front,
                    v = w - 1 - c.padInfo.left,
                    I = x - 1 - c.padInfo.top,
                    N = Aa(a.shape, "float32"),
                    S = n.bufferSync(r);
                for (let e = 0; e < c.batchSize; ++e)
                    for (let t = 0; t < c.inChannels; ++t)
                        for (let n = 0; n < c.inDepth; ++n)
                            for (let s = 0; s < c.inHeight; ++s)
                                for (let r = 0; r < c.inWidth; ++r) {
                                    const a = n - k,
                                        i = s - I,
                                        o = r - v;
                                    let u = 0;
                                    for (let n = 0; n < b; n += m) {
                                        const s = (a + n) / p;
                                        if (!(s < 0 || s >= c.outDepth || Math.floor(s) !== s))
                                            for (let r = 0; r < x; r += g) {
                                                const a = (i + r) / d;
                                                if (!(a < 0 || a >= c.outHeight || Math.floor(a) !== a))
                                                    for (let i = 0; i < w; i += y) {
                                                        const l = (o + i) / f;
                                                        if (l < 0 || l >= c.outWidth || Math.floor(l) !== l) continue;
                                                        const p = b * x * w - 1 - h.get(e, s, a, l, t) === n * x * w + r * w + i ? 1 : 0;
                                                        if (0 === p) continue;
                                                        u += S.get(e, s, a, l, t) * p
                                                    }
                                            }
                                    }
                                    N.set(u, e, n, s, r, t)
                                }
                return n.makeTensorInfo(N.shape, N.dtype, N.values)
            }
        };
        const HS = {
            kernelName: Jt,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a,
                    output: i
                } = t, o = a;
                Hk([a, i], "maxPoolGrad");
                const {
                    filterSize: u,
                    strides: l,
                    pad: c,
                    dimRoundingMode: h
                } = s, p = Ai(o.shape, u, l, 1, c, h), d = n.data.get(o.dataId).values, f = Aa(p.outShape, o.dtype, aI(d, o.shape, o.dtype, p).values), m = p.strideHeight, g = p.strideWidth, y = p.dilationHeight, b = p.dilationWidth, x = p.effectiveFilterHeight, w = p.effectiveFilterWidth, k = w - 1 - p.padInfo.left, v = x - 1 - p.padInfo.top, I = Aa(o.shape, "float32"), N = n.data.get(r.dataId).values, S = Aa(r.shape, "float32", N);
                for (let e = 0; e < p.batchSize; ++e)
                    for (let t = 0; t < p.inChannels; ++t)
                        for (let n = 0; n < p.inHeight; ++n)
                            for (let s = 0; s < p.inWidth; ++s) {
                                const r = n - v,
                                    a = s - k;
                                let i = 0;
                                for (let n = 0; n < x; n += y) {
                                    const s = (r + n) / m;
                                    if (!(s < 0 || s >= p.outHeight || Math.floor(s) !== s))
                                        for (let r = 0; r < w; r += b) {
                                            const o = (a + r) / g;
                                            if (o < 0 || o >= p.outWidth || Math.floor(o) !== o) continue;
                                            const u = x * w - 1 - f.get(e, s, o, t) === n * w + r ? 1 : 0;
                                            if (0 === u) continue;
                                            i += S.get(e, s, o, t) * u
                                        }
                                }
                                I.set(i, e, n, s, t)
                            }
                return n.makeTensorInfo(I.shape, I.dtype, I.values)
            }
        };
        const jS = {
            kernelName: en,
            backendName: "cpu",
            kernelFunc: ({
                inputs: e,
                attrs: t,
                backend: n
            }) => {
                const {
                    x: s
                } = e, {
                    filterSize: r,
                    strides: a,
                    pad: i,
                    includeBatchInIndex: o
                } = t, u = n;
                Hk(s, "MaxPoolWithArgmax");
                const l = u.data.get(s.dataId).values,
                    c = Ai(s.shape, r, a, [1, 1], i),
                    [h, p] = function(e, t, n, s, r) {
                        const a = rI(e, 0, n, ee(t), r, "max"),
                            i = aI(e, t, n, r, !0, s);
                        return [a.values, i.values]
                    }(l, s.shape, s.dtype, o, c),
                    d = u.write(h, c.outShape, s.dtype),
                    f = u.write(p, c.outShape, s.dtype);
                return [{
                    dataId: d,
                    shape: c.outShape,
                    dtype: s.dtype
                }, {
                    dataId: f,
                    shape: c.outShape,
                    dtype: "int32"
                }]
            }
        };
        const qS = {
            kernelName: tn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    keepDims: i
                } = s, o = W(a, r.shape), u = O(Uo(r.shape, o)[1]), l = [], c = n.makeTensorInfo([], "float32", new Float32Array([u]));
                l.push(c);
                const h = wv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        dtype: "float32"
                    }
                });
                l.push(h);
                const p = EN({
                    inputs: {
                        a: h,
                        b: c
                    },
                    backend: n
                });
                l.push(p);
                const d = aN({
                    inputs: {
                        x: p
                    },
                    backend: n,
                    attrs: {
                        axis: a,
                        keepDims: i
                    }
                });
                return l.forEach((e => n.disposeIntermediateTensorInfo(e))), d
            }
        };
        const KS = {
                kernelName: nn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        axis: a,
                        keepDims: i
                    } = s;
                    Hk(r, "min");
                    const o = W(a, r.shape);
                    let u = o;
                    const l = Go(u, r.shape.length);
                    let c = r;
                    null != l && (c = Uv({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            perm: l
                        }
                    }), u = jo(u.length, r.shape.length)), Vo("min", u, c.shape.length);
                    const [h, p] = Uo(c.shape, u), d = O(p), f = re(O(h), c.dtype), m = n.data.get(c.dataId).values;
                    for (let e = 0; e < f.length; ++e) {
                        const t = e * d;
                        let n = m[t];
                        for (let e = 0; e < d; ++e) {
                            const s = m[t + e];
                            (Number.isNaN(s) || s < n) && (n = s)
                        }
                        f[e] = n
                    }
                    null != l && n.disposeIntermediateTensorInfo(c);
                    const g = n.makeTensorInfo(h, c.dtype, f);
                    if (i) {
                        const e = Cv({
                            inputs: {
                                x: g
                            },
                            backend: n,
                            attrs: {
                                shape: Wo(h, o)
                            }
                        });
                        return n.disposeIntermediateTensorInfo(g), e
                    }
                    return g
                }
            },
            XS = nv(((e, t) => Math.min(e, t))),
            YS = vv(sn, XS),
            JS = {
                kernelName: sn,
                backendName: "cpu",
                kernelFunc: YS
            };
        const ZS = {
                kernelName: rn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        paddings: a,
                        mode: i
                    } = s;
                    Hk(r, "mirrorPad");
                    const o = a.map(((e, t) => e[0] + r.shape[t] + e[1])),
                        u = a.map((e => e[0])),
                        l = a.map(((e, t) => e[0] + r.shape[t])),
                        c = "reflect" === i ? 0 : 1,
                        h = n.data.get(r.dataId).values,
                        p = r.shape.length,
                        d = ee(r.shape),
                        f = O(o),
                        m = o.length,
                        g = ee(o),
                        y = G(r.dtype, f);
                    for (let e = 0; e < f; e++) {
                        let t = ue(e, m, g);
                        for (let e = 0; e < m; e++) t[e] < u[e] ? t[e] = 2 * u[e] - t[e] - c : t[e] >= l[e] && (t[e] = 2 * (l[e] - 1) - t[e] + c);
                        t = t.map(((e, t) => e - u[t]));
                        const n = oe(t, p, d);
                        y[e] = h[n]
                    }
                    return {
                        dataId: n.write(y, o, r.dtype),
                        shape: o,
                        dtype: r.dtype
                    }
                }
            },
            QS = nv(((e, t) => {
                const n = e % t;
                return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t
            })),
            eT = vv(an, QS),
            tT = {
                kernelName: an,
                backendName: "cpu",
                kernelFunc: eT
            };
        var nT = n(546);

        function sT(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                logits: r
            } = t, {
                dim: a
            } = s, i = r.shape.length;
            let o = a;
            if (-1 === o && (o = i - 1), o !== i - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);
            const u = W([o], r.shape),
                l = LS({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        reductionIndices: u,
                        keepDims: !1
                    }
                }),
                c = Wo(l.shape, u),
                h = Cv({
                    inputs: {
                        x: l
                    },
                    backend: n,
                    attrs: {
                        shape: c
                    }
                }),
                p = DN({
                    inputs: {
                        a: r,
                        b: h
                    },
                    backend: n
                }),
                d = kN({
                    inputs: {
                        x: p
                    },
                    backend: n
                }),
                f = aN({
                    inputs: {
                        x: d
                    },
                    backend: n,
                    attrs: {
                        axis: u,
                        keepDims: !1
                    }
                }),
                m = Cv({
                    inputs: {
                        x: f
                    },
                    backend: n,
                    attrs: {
                        shape: c
                    }
                }),
                g = EN({
                    inputs: {
                        a: d,
                        b: m
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), g
        }
        const rT = {
            kernelName: Kn,
            backendName: "cpu",
            kernelFunc: sT
        };
        const aT = {
            kernelName: on,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    logits: r
                } = t, {
                    numSamples: a,
                    seed: i,
                    normalized: o
                } = s;
                Hk(r, "multinomial");
                const u = o ? r : sT({
                        inputs: {
                            logits: r
                        },
                        backend: n,
                        attrs: {
                            dim: -1
                        }
                    }),
                    l = u.shape[0],
                    c = u.shape[1],
                    h = n.data.get(u.dataId).values,
                    p = [l, a],
                    d = re(O(p), "int32");
                for (let e = 0; e < l; ++e) {
                    const t = e * c,
                        n = new Float32Array(c - 1);
                    n[0] = h[t];
                    for (let e = 1; e < n.length; ++e) n[e] = n[e - 1] + h[t + e];
                    const s = nT.alea(i.toString()),
                        r = e * a;
                    for (let e = 0; e < a; ++e) {
                        const t = s();
                        d[r + e] = n.length;
                        for (let s = 0; s < n.length; s++)
                            if (t < n[s]) {
                                d[r + e] = s;
                                break
                            }
                    }
                }
                return o || n.disposeIntermediateTensorInfo(u), n.makeTensorInfo(p, "int32", d)
            }
        };

        function iT(e, t, n) {
            const s = qs(-1, n);
            return tN([], t, s, e, n)
        }
        const oT = {
                kernelName: ln,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        x: s
                    } = t;
                    Hk(s, "neg");
                    const r = n.data.get(s.dataId).values,
                        [a, i] = iT(r, s.shape, s.dtype);
                    return n.makeTensorInfo(i, s.dtype, a)
                }
            },
            uT = hl;
        const lT = {
                kernelName: hn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        boxes: r,
                        scores: a
                    } = t, {
                        maxOutputSize: i,
                        iouThreshold: o,
                        scoreThreshold: u
                    } = s;
                    Hk(r, "NonMaxSuppression");
                    const l = n.data.get(r.dataId).values,
                        c = n.data.get(a.dataId).values,
                        {
                            selectedIndices: h
                        } = uT(l, c, i, o, u);
                    return n.makeTensorInfo([h.length], "int32", new Int32Array(h))
                }
            },
            cT = pl;
        const hT = {
                kernelName: pn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        boxes: r,
                        scores: a
                    } = t, {
                        maxOutputSize: i,
                        iouThreshold: o,
                        scoreThreshold: u,
                        padToMaxOutputSize: l
                    } = s;
                    Hk(r, "NonMaxSuppressionPadded");
                    const c = n.data.get(r.dataId).values,
                        h = n.data.get(a.dataId).values,
                        {
                            selectedIndices: p,
                            validOutputs: d
                        } = cT(c, h, i, o, u, l);
                    return [n.makeTensorInfo([p.length], "int32", new Int32Array(p)), n.makeTensorInfo([], "int32", new Int32Array([d]))]
                }
            },
            pT = dl;
        const dT = {
                kernelName: dn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        boxes: r,
                        scores: a
                    } = t, {
                        maxOutputSize: i,
                        iouThreshold: o,
                        scoreThreshold: u,
                        softNmsSigma: l
                    } = s;
                    Hk(r, "NonMaxSuppressionWithScore");
                    const c = n.data.get(r.dataId).values,
                        h = n.data.get(a.dataId).values,
                        p = i,
                        d = o,
                        f = u,
                        m = l,
                        {
                            selectedIndices: g,
                            selectedScores: y
                        } = pT(c, h, p, d, f, m);
                    return [n.makeTensorInfo([g.length], "int32", new Int32Array(g)), n.makeTensorInfo([y.length], "float32", new Float32Array(y))]
                }
            },
            fT = nv(((e, t) => e !== t ? 1 : 0)),
            mT = vv(cn, fT, null, "bool"),
            gT = {
                kernelName: cn,
                backendName: "cpu",
                kernelFunc: mT
            };
        const yT = {
            kernelName: mn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    indices: r
                } = t, {
                    depth: a,
                    onValue: i,
                    offValue: o
                } = s;
                Hk(r, "oneHot");
                const u = O(r.shape),
                    l = new Float32Array(u * a);
                l.fill(o);
                const c = n.data.get(r.dataId).values;
                for (let e = 0; e < u; ++e) c[e] >= 0 && c[e] < a && (l[e * a + c[e]] = i);
                return n.makeTensorInfo([...r.shape, a], "int32", l)
            }
        };

        function bT(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                x: s
            } = t;
            if ("string" === s.dtype) throw new Error("zerosLike is not supported for string tensors");
            if ("complex64" === s.dtype) {
                const e = bv({
                        inputs: {
                            input: s
                        },
                        backend: n
                    }),
                    t = bT({
                        inputs: {
                            x: e
                        },
                        backend: n
                    }),
                    r = $I({
                        inputs: {
                            input: s
                        },
                        backend: n
                    }),
                    a = bT({
                        inputs: {
                            x: r
                        },
                        backend: n
                    }),
                    i = mv({
                        inputs: {
                            real: t,
                            imag: a
                        },
                        backend: n
                    });
                return n.disposeIntermediateTensorInfo(e), n.disposeIntermediateTensorInfo(t), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(a), i
            }
            return BN({
                backend: n,
                attrs: {
                    shape: s.shape,
                    value: 0,
                    dtype: s.dtype
                }
            })
        }
        const xT = {
            kernelName: gs,
            backendName: "cpu",
            kernelFunc: bT
        };
        const wT = {
            kernelName: fn,
            backendName: "cpu",
            kernelFunc: function e(t) {
                const {
                    inputs: n,
                    backend: s
                } = t, {
                    x: r
                } = n;
                if ("string" === r.dtype) throw new Error("onesLike is not supported for string tensors");
                if ("complex64" === r.dtype) {
                    const t = bv({
                            inputs: {
                                input: r
                            },
                            backend: s
                        }),
                        n = e({
                            inputs: {
                                x: t
                            },
                            backend: s
                        }),
                        a = $I({
                            inputs: {
                                input: r
                            },
                            backend: s
                        }),
                        i = bT({
                            inputs: {
                                x: a
                            },
                            backend: s
                        }),
                        o = mv({
                            inputs: {
                                real: n,
                                imag: i
                            },
                            backend: s
                        });
                    return s.disposeIntermediateTensorInfo(t), s.disposeIntermediateTensorInfo(n), s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o
                }
                return BN({
                    backend: s,
                    attrs: {
                        shape: r.shape,
                        value: 1,
                        dtype: r.dtype
                    }
                })
            }
        };

        function kT(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                axis: r
            } = s;
            if (1 === t.length) return IN({
                inputs: {
                    input: t[0]
                },
                backend: n,
                attrs: {
                    dim: r
                }
            });
            const a = t[0].shape,
                i = t[0].dtype;
            t.forEach((e => {
                F(a, e.shape, "All tensors passed to stack must have matching shapes"), R(i === e.dtype, (() => "All tensors passed to stack must have matching dtypes"))
            }));
            const o = [],
                u = EI({
                    inputs: t.map((e => {
                        const t = IN({
                            inputs: {
                                input: e
                            },
                            backend: n,
                            attrs: {
                                dim: r
                            }
                        });
                        return o.push(t), t
                    })),
                    backend: n,
                    attrs: {
                        axis: r
                    }
                });
            return o.forEach((e => n.disposeIntermediateTensorInfo(e))), u
        }
        const vT = {
            kernelName: gn,
            backendName: "cpu",
            kernelFunc: kT
        };
        const IT = {
                kernelName: yn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        paddings: a,
                        constantValue: i
                    } = s;
                    Hk(r, "pad");
                    const o = a.map(((e, t) => e[0] + r.shape[t] + e[1])),
                        u = a.map((e => e[0])),
                        l = n.data.get(r.dataId).values,
                        c = O(r.shape),
                        h = r.shape.length,
                        p = ee(r.shape),
                        d = O(o),
                        f = o.length,
                        m = ee(o),
                        g = G(r.dtype, d);
                    0 !== i && g.fill(i);
                    for (let e = 0; e < c; e++) {
                        g[oe(ue(e, h, p).map(((e, t) => e + u[t])), f, m)] = l[e]
                    }
                    return {
                        dataId: n.write(g, o, r.dtype),
                        shape: o,
                        dtype: r.dtype
                    }
                }
            },
            NT = nv(((e, t) => Math.pow(e, t))),
            ST = vv(bn, NT),
            TT = {
                kernelName: bn,
                backendName: "cpu",
                kernelFunc: ST
            };

        function $T(e, t, n, s) {
            const [r, a] = Uo(e, s), i = xr(t, "int32"), o = re(O(r), i), u = O(a);
            for (let e = 0; e < o.length; ++e) {
                const t = e * u;
                let s = 1;
                for (let e = 0; e < u; ++e) s *= n[t + e];
                o[e] = s
            }
            return {
                outVals: o,
                outShape: r,
                outDtype: i
            }
        }
        const CT = {
            kernelName: wn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    keepDims: i
                } = s;
                Hk(r, "prod");
                const o = r.shape.length,
                    u = W(a, r.shape),
                    l = Go(u, o);
                let c = u,
                    h = r;
                const p = [];
                null != l && (h = Uv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), p.push(h), c = jo(c.length, o));
                const d = n.data.get(h.dataId).values,
                    {
                        outVals: f,
                        outShape: m,
                        outDtype: g
                    } = $T(h.shape, h.dtype, d, c);
                let y = m;
                return i && (y = Wo(m, u)), p.forEach((e => n.disposeIntermediateTensorInfo(e))), n.makeTensorInfo(y, g, f)
            }
        };

        function ET(e, t, n, s) {
            if (e === t || e < t && n < 0 || t < e && n > 1) return re(0, s);
            const r = re(Math.abs(Math.ceil((t - e) / n)), s);
            t < e && 1 === n && (n = -1), r[0] = e;
            for (let e = 1; e < r.length; e++) r[e] = r[e - 1] + n;
            return r
        }
        const AT = {
                kernelName: kn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        backend: t,
                        attrs: n
                    } = e, {
                        start: s,
                        stop: r,
                        dtype: a,
                        step: i
                    } = n, o = ET(s, r, i, a);
                    return t.makeTensorInfo([o.length], a, o)
                }
            },
            RT = Kk(In, (e => 1 / e)),
            FT = {
                kernelName: In,
                backendName: "cpu",
                kernelFunc: RT
            };
        const DT = {
            kernelName: Cn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r
                } = t, {
                    alignCorners: a,
                    halfPixelCenters: i,
                    size: o
                } = s;
                Hk(r, "resizeBilinear");
                const u = ee(r.shape),
                    [l, c] = o,
                    [h, p, d, f] = r.shape,
                    m = n.data.get(r.dataId).values,
                    g = new Float32Array(O([h, l, c, f])),
                    y = [a && l > 1 ? p - 1 : p, a && c > 1 ? d - 1 : d],
                    b = [a && l > 1 ? l - 1 : l, a && c > 1 ? c - 1 : c];
                let x = 0;
                const w = y[0] / b[0],
                    k = y[1] / b[1];
                for (let e = 0; e < h; e++)
                    for (let t = 0; t < l; t++) {
                        let n;
                        n = i ? w * (t + .5) - .5 : w * t;
                        const s = Math.max(0, Math.floor(n)),
                            r = n - s,
                            a = Math.min(p - 1, Math.ceil(n)),
                            o = e * u[0] + s * u[1],
                            l = e * u[0] + a * u[1];
                        for (let e = 0; e < c; e++) {
                            let t;
                            t = i ? k * (e + .5) - .5 : k * e;
                            const n = Math.max(0, Math.floor(t)),
                                s = t - n,
                                a = Math.min(d - 1, Math.ceil(t)),
                                c = o + n * u[2],
                                h = l + n * u[2],
                                p = o + a * u[2],
                                y = l + a * u[2];
                            for (let e = 0; e < f; e++) {
                                const t = m[c + e],
                                    n = m[h + e],
                                    a = t + (m[p + e] - t) * s,
                                    i = a + (n + (m[y + e] - n) * s - a) * r;
                                g[x++] = i
                            }
                        }
                    }
                return n.makeTensorInfo([h, l, c, f], "float32", g)
            }
        };
        const _T = {
            kernelName: En,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r,
                    dy: a
                } = t, {
                    alignCorners: i
                } = s;
                Hk([a, r], "resizeBilinearGrad");
                const o = ee(r.shape),
                    [u, l, c, h] = r.shape,
                    [, p, d] = a.shape,
                    f = new Float32Array(u * l * c * h),
                    m = [i && p > 1 ? l - 1 : l, i && d > 1 ? c - 1 : c],
                    g = [i && p > 1 ? p - 1 : p, i && d > 1 ? d - 1 : d],
                    y = m[0] / g[0],
                    b = m[1] / g[1],
                    x = n.data.get(a.dataId).values;
                let w = 0;
                for (let e = 0; e < u; e++) {
                    const t = e * o[0];
                    for (let e = 0; e < p; e++) {
                        const n = e * y,
                            s = Math.floor(n),
                            r = Math.min(Math.ceil(n), l - 1),
                            a = t + s * o[1],
                            i = t + r * o[1],
                            u = n - s,
                            p = 1 - u;
                        for (let e = 0; e < d; e++) {
                            const t = e * b,
                                n = Math.floor(t),
                                s = Math.min(Math.ceil(t), c - 1),
                                r = t - n,
                                l = 1 - r,
                                d = a + n * o[2],
                                m = a + s * o[2],
                                g = i + n * o[2],
                                y = i + s * o[2],
                                k = p * l,
                                v = p * r,
                                I = u * l,
                                N = u * r;
                            for (let e = 0; e < h; e++) {
                                const t = x[w++];
                                f[d + e] += t * k, f[m + e] += t * v, f[g + e] += t * I, f[y + e] += t * N
                            }
                        }
                    }
                }
                return n.makeTensorInfo([u, c, l, h], "float32", f)
            }
        };
        const OT = {
            kernelName: Tn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r
                } = t, {
                    alignCorners: a,
                    halfPixelCenters: i,
                    size: o
                } = s;
                Hk(r, "resizeNearestNeighbor");
                const u = ee(r.shape),
                    [l, c] = o,
                    [h, p, d, f] = r.shape,
                    m = n.data.get(r.dataId).values,
                    g = new Float32Array(h * l * c * f),
                    y = [a && l > 1 ? p - 1 : p, a && c > 1 ? d - 1 : d],
                    b = [a && l > 1 ? l - 1 : l, a && c > 1 ? c - 1 : c],
                    x = y[0] / b[0],
                    w = y[1] / b[1];
                let k = 0;
                for (let e = 0; e < h; e++) {
                    const t = e * u[0];
                    for (let e = 0; e < l; e++) {
                        const n = i ? x * (e + .5) : x * e;
                        let s = Math.min(p - 1, a ? Math.round(n) : Math.floor(n));
                        i && (s = Math.max(0, s));
                        const r = t + s * u[1];
                        for (let e = 0; e < c; e++) {
                            const t = i ? w * (e + .5) : w * e;
                            let n = Math.min(d - 1, a ? Math.round(t) : Math.floor(t));
                            i && (n = Math.max(0, n));
                            const s = r + n * u[2];
                            for (let e = 0; e < f; e++) {
                                const t = m[s + e];
                                g[k++] = t
                            }
                        }
                    }
                }
                return n.makeTensorInfo([h, l, c, f], r.dtype, g)
            }
        };
        const MT = {
            kernelName: $n,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r,
                    dy: a
                } = t, {
                    alignCorners: i
                } = s;
                Hk([a, r], "resizeNearestNeighborGrad");
                const o = ee(r.shape),
                    u = ee(a.shape),
                    [l, c, h, p] = r.shape,
                    [, d, f] = a.shape,
                    m = new Float32Array(l * c * h * p),
                    g = n.data.get(a.dataId).values,
                    y = [i && d > 1 ? c - 1 : c, i && f > 1 ? h - 1 : h],
                    b = [i && d > 1 ? d - 1 : d, i && f > 1 ? f - 1 : f],
                    x = y[0] / b[0],
                    w = y[1] / b[1],
                    k = 1 / x,
                    v = 1 / w,
                    I = 2 * Math.ceil(k) + 2,
                    N = 2 * Math.ceil(v) + 2;
                for (let e = 0; e < l; e++) {
                    const t = e * o[0];
                    for (let e = 0; e < c; e++) {
                        const n = t + e * o[1],
                            s = Math.floor(e * k),
                            r = Math.floor(s - I / 2);
                        for (let s = 0; s < h; s++) {
                            const a = n + s * o[2],
                                l = Math.floor(s * v),
                                y = Math.floor(l - N / 2);
                            for (let n = 0; n < p; n++) {
                                let o = 0;
                                for (let a = 0; a < I; a++) {
                                    const l = a + r;
                                    if (l < 0 || l >= d) continue;
                                    const p = t + l * u[1],
                                        m = l * x;
                                    if (e === Math.min(c - 1, i ? Math.round(m) : Math.floor(m)))
                                        for (let e = 0; e < N; e++) {
                                            const t = e + y;
                                            if (t < 0 || t >= f) continue;
                                            const r = p + t * u[2],
                                                a = t * w;
                                            s === Math.min(h - 1, i ? Math.round(a) : Math.floor(a)) && (o += g[r + n])
                                        }
                                }
                                m[a + n] = o
                            }
                        }
                    }
                }
                return n.makeTensorInfo(r.shape, r.dtype, m)
            }
        };
        const LT = {
                kernelName: Rn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        dims: a
                    } = s;
                    Hk(r, "reverse");
                    const i = r.shape.length,
                        o = W(a, r.shape);
                    if (0 === i) return Zk({
                        inputs: {
                            x: r
                        },
                        backend: n
                    });
                    const u = new ir(r.shape, r.dtype),
                        l = n.bufferSync(r);
                    for (let e = 0; e < u.size; e++) {
                        const t = u.indexToLoc(e),
                            n = t.slice();
                        o.forEach((e => n[e] = r.shape[e] - 1 - n[e])), u.set(l.get(...n), ...t)
                    }
                    return n.makeTensorInfo(u.shape, u.dtype, u.values)
                }
            },
            zT = {
                kernelName: xs,
                backendName: "cpu",
                kernelFunc: ({
                    inputs: e,
                    attrs: t,
                    backend: n
                }) => {
                    const {
                        image: s
                    } = e, {
                        radians: r,
                        fillValue: a,
                        center: i
                    } = t, o = n, u = G(s.dtype, O(s.shape)), [l, c, h, p] = s.shape, [d, f] = gc(i, c, h), m = Math.sin(r), g = Math.cos(r), y = o.data.get(s.dataId).values;
                    for (let e = 0; e < l; e++) {
                        const t = e * h * c * p;
                        for (let e = 0; e < c; e++) {
                            const n = e * (h * p);
                            for (let s = 0; s < h; s++) {
                                const r = s * p;
                                for (let i = 0; i < p; i++) {
                                    const o = [l, e, s, i],
                                        b = o[2],
                                        x = o[1];
                                    let w = (b - d) * g - (x - f) * m,
                                        k = (b - d) * m + (x - f) * g;
                                    w = Math.round(w + d), k = Math.round(k + f);
                                    let v = a;
                                    if ("number" != typeof a && (v = 3 === i ? 255 : a[i]), w >= 0 && w < h && k >= 0 && k < c) {
                                        v = y[t + k * (h * p) + w * p + i]
                                    }
                                    u[t + n + r + i] = v
                                }
                            }
                        }
                    }
                    return {
                        dataId: o.write(u, s.shape, s.dtype),
                        shape: s.shape,
                        dtype: s.dtype
                    }
                }
            },
            BT = Kk(Fn, (e => {
                const t = Math.floor(e);
                return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1
            })),
            PT = {
                kernelName: Fn,
                backendName: "cpu",
                kernelFunc: BT
            },
            UT = cv((e => 1 / Math.sqrt(e))),
            WT = Xk(Dn, UT),
            VT = {
                kernelName: Dn,
                backendName: "cpu",
                kernelFunc: WT
            };

        function GT(e, t, n, s, r, a, i, o, u, l) {
            const c = [s / r, r],
                h = e.values,
                p = t.values;
            if (0 === s) return Aa(n, t.dtype);
            const d = Aa(c, t.dtype);
            "string" == typeof u || "number" == typeof u ? d.values.fill(u) : "boolean" == typeof u && d.values.fill(+u);
            for (let e = 0; e < a; e++) {
                const a = [];
                let u = 0;
                for (let t = 0; t < i; t++) {
                    const n = h[e * i + t];
                    a.push(n), u += n * o[t]
                }
                if (u < 0 || u >= s / r) throw new Error(`Invalid indices: ${a} does not index into ${n}`);
                for (let n = 0; n < r; n++) l ? d.values[u * r + n] += p[e * r + n] : d.values[u * r + n] = 0 === t.rank ? p[0] : p[e * r + n]
            }
            return d
        }
        const HT = {
            kernelName: _n,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    indices: r,
                    updates: a
                } = t, {
                    shape: i
                } = s, {
                    sliceRank: o,
                    numUpdates: u,
                    sliceSize: l,
                    strides: c,
                    outputSize: h
                } = Sc(0, r, i), p = GT(n.bufferSync(r), n.bufferSync(a), i, h, l, u, o, c, 0, !0);
                return n.makeTensorInfo(i, p.dtype, p.values)
            }
        };

        function jT(e, t) {
            let n = 0,
                s = e.length,
                r = 0;
            for (; n < s;) r = Math.floor((n + s) / 2), e[r] < t ? n = r + 1 : s = r;
            return s
        }

        function qT(e, t) {
            let n = 0,
                s = e.length,
                r = 0;
            for (; n < s;) r = Math.floor((n + s) / 2), e[r] <= t ? n = r + 1 : s = r;
            return s
        }
        const KT = {
            kernelName: On,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    sortedSequence: r,
                    values: a
                } = t, {
                    side: i
                } = s, o = function(e, t, n, s, r, a) {
                    const i = H("int32", n * r);
                    for (let o = 0; o < n; ++o) {
                        const n = e.slice(o * s, (o + 1) * s),
                            u = o * r;
                        for (let e = 0; e < r; ++e) i[u + e] = "left" === a ? jT(n, t[e + u]) : qT(n, t[e + u])
                    }
                    return i
                }(n.data.get(r.dataId).values, n.data.get(a.dataId).values, r.shape[0], r.shape[1], a.shape[1], i);
                return n.makeTensorInfo(a.shape, "int32", o)
            }
        };
        const XT = {
                kernelName: Mn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        condition: s,
                        t: r,
                        e: a
                    } = t;
                    Hk([s, r, a], "select");
                    const i = s.shape.length,
                        o = n.data.get(s.dataId).values,
                        u = n.data.get(r.dataId).values,
                        l = n.data.get(a.dataId).values,
                        c = xr(r.dtype, a.dtype),
                        h = re(O(r.shape), c);
                    let p = 0;
                    const d = 0 === i || i > 1 || 1 === r.shape.length ? 1 : O(r.shape.slice(1));
                    for (let e = 0; e < o.length; e++)
                        for (let t = 0; t < d; t++) 1 === o[e] ? h[p++] = u[e] : h[p++] = l[e];
                    return n.makeTensorInfo(r.shape, c, h)
                }
            },
            YT = Tc,
            JT = $c,
            ZT = Kk(Ln, (e => e >= 0 ? JT * e : YT * (Math.exp(e) - 1))),
            QT = {
                kernelName: Ln,
                backendName: "cpu",
                kernelFunc: ZT
            },
            e$ = Kk(Un, (e => e < 0 ? -1 : e > 0 ? 1 : 0)),
            t$ = {
                kernelName: Un,
                backendName: "cpu",
                kernelFunc: e$
            },
            n$ = Kk(Bn, (e => Math.sin(e))),
            s$ = {
                kernelName: Bn,
                backendName: "cpu",
                kernelFunc: n$
            },
            r$ = Kk(Pn, (e => Math.sinh(e))),
            a$ = {
                kernelName: Pn,
                backendName: "cpu",
                kernelFunc: r$
            },
            i$ = Math.log(1.1920928955078125e-7) + 2,
            o$ = Kk(Vn, (e => {
                const t = e > -i$,
                    n = e < i$,
                    s = Math.exp(e);
                let r;
                return r = n ? s : t ? e : Math.log(1 + s), r
            })),
            u$ = {
                kernelName: Vn,
                backendName: "cpu",
                kernelFunc: o$
            };
        const l$ = {
            kernelName: jn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    blockShape: a,
                    paddings: i
                } = s;
                Hk([r], "spaceToBatchND");
                const o = O(a),
                    u = [
                        [0, 0]
                    ];
                u.push(...i);
                for (let e = 1 + a.length; e < r.shape.length; ++e) u.push([0, 0]);
                const l = IT.kernelFunc({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            paddings: u,
                            constantValue: 0
                        }
                    }),
                    c = yc(l.shape, a, o, !1),
                    h = bc(c.length, a.length, !1),
                    p = xc(l.shape, a, o, !1),
                    d = Cv({
                        inputs: {
                            x: l
                        },
                        backend: n,
                        attrs: {
                            shape: c
                        }
                    }),
                    f = Uv({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            perm: h
                        }
                    }),
                    m = Cv({
                        inputs: {
                            x: f
                        },
                        backend: n,
                        attrs: {
                            shape: p
                        }
                    });
                return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), m
            }
        };

        function c$(e, t, n, s, r, a, i) {
            const o = t[0],
                u = a[0],
                l = new Array(u),
                c = new Array(o),
                h = t[1];
            if (0 === u) {
                if (0 !== o) throw new Error(Qc(o));
                return [H(n, 0), [0, h], H(r, 0), l, c]
            }
            let p = !0,
                d = 0;
            const f = new Array(u).fill(0);
            for (let t = 0; t < o; ++t) {
                const n = e[t * h];
                if (n < 0) throw new Error(eh(t, n));
                if (n >= u) throw new Error(th(t, n, u));
                ++f[n], p = p && n >= d, d = n
            }
            let m = !0;
            for (let e = 0; e < u; ++e) {
                const t = 0 === f[e];
                l[e] = t, m = m && !t, f[e] = Math.max(f[e], 1), e > 0 && (f[e] += f[e - 1])
            }
            if (m && p) {
                const t = e,
                    n = s;
                for (let e = 0; e < o; ++e) c[e] = e;
                return [t, [o, h], n, l, c]
            } {
                const t = f[u - 1],
                    a = H(n, t * h),
                    p = H(r, t),
                    d = new Array(u).fill(0);
                for (let t = 0; t < o; ++t) {
                    const n = e[t * h],
                        r = d[n],
                        i = (0 === n ? 0 : f[n - 1]) + r;
                    d[n]++;
                    for (let n = 0; n < h; ++n) a[i * h + n] = e[t * h + n];
                    p[i] = s[t], c[t] = i
                }
                for (let e = 0; e < u; ++e) {
                    if (0 === d[e]) {
                        const t = 0 === e ? 0 : f[e - 1];
                        a[t * h + 0] = e;
                        for (let e = 1; e < h; ++e) a[t * h + e] = 0;
                        p[t] = i
                    }
                }
                return [a, [t, h], p, l, c]
            }
        }
        const h$ = {
            kernelName: Xn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    indices: s,
                    values: r,
                    denseShape: a,
                    defaultValue: i
                } = t;
                if (1 !== a.shape.length) throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);
                if (2 !== s.shape.length) throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);
                if (1 !== r.shape.length) throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);
                if (0 !== i.shape.length) throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);
                const o = n.data.get(s.dataId).values,
                    u = n.data.get(r.dataId).values,
                    l = n.data.get(a.dataId).values,
                    c = n.data.get(i.dataId).values[0],
                    [h, p, d, f, m] = c$(o, s.shape, s.dtype, u, r.dtype, l, c);
                return [n.makeTensorInfo(p, s.dtype, h), n.makeTensorInfo([p[0]], r.dtype, d), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((e => Number(e))))), n.makeTensorInfo([m.length], s.dtype, new Int32Array(m))]
            }
        };

        function p$(e, t, n, s, r) {
            const a = O(s),
                i = t[0],
                o = r.length,
                u = [];
            let l = 1,
                c = -1;
            for (let e = 0; e < o; ++e) {
                const t = r[e];
                if (-1 === t) {
                    if (-1 !== c) throw new Error(nh(c, e));
                    c = e, u.push(1)
                } else {
                    if (t < 0) throw new Error(sh(e, t));
                    l *= t, u.push(t)
                }
            }
            if (-1 !== c) {
                if (l <= 0) throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
                const e = Math.trunc(a / l);
                if (l * e !== a) throw new Error(ah(s, u));
                u[c] = e
            }
            if (O(u) !== a) throw new Error(ih(s, u));
            const h = s.length,
                p = [];
            if (h > 0) {
                p[h - 1] = 1;
                for (let e = h - 2; e >= 0; --e) p[e] = p[e + 1] * s[e + 1]
            }
            const d = [];
            if (o > 0) {
                d[o - 1] = 1;
                for (let e = o - 2; e >= 0; --e) d[e] = d[e + 1] * u[e + 1]
            }
            const f = H(n, i * o);
            for (let t = 0; t < i; ++t) {
                let n = 0;
                for (let s = 0; s < h; ++s) n += e[t * h + s] * p[s];
                for (let e = 0; e < o; ++e) f[t * o + e] = Math.trunc(n / d[e]), n %= d[e]
            }
            return [f, [i, o], u]
        }
        const d$ = {
            kernelName: Yn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    inputIndices: s,
                    inputShape: r,
                    newShape: a
                } = t;
                if (2 !== s.shape.length) throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);
                if (1 !== r.shape.length) throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);
                if (1 !== a.shape.length) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
                const i = Array.from(n.data.get(r.dataId).values),
                    o = n.data.get(s.dataId).values,
                    u = Array.from(n.data.get(a.dataId).values),
                    [l, c, h] = p$(o, s.shape, s.dtype, i, u);
                return [n.makeTensorInfo(c, s.dtype, l), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))]
            }
        };

        function f$(e, t, n, s, r, a = !1, i = 0) {
            const o = s.length,
                u = [t[0], e.length / t[0]],
                l = u[1],
                c = o > 0 ? r[o - 1] + 1 : 0;
            if (c < 0) throw new Error("segment ids must be >= 0");
            const h = t.slice();
            h[0] = c;
            const p = H(n, h.reduce(((e, t) => e * t), 1));
            if (0 === o) return c > 0 && p.fill(i), [p, h];
            if (c <= 0) throw new Error("segment ids must be >= 0");
            let d = 0,
                f = 1,
                m = 0,
                g = r[d];
            for (;;) {
                let t = 0;
                if (f < o) {
                    if (t = r[f], g === t) {
                        ++f;
                        continue
                    }
                    if (g >= t) throw new Error("segment ids are not increasing")
                }
                if (g < 0 || g >= c) throw new Error(lh(g, c));
                g > m && p.fill(i, m * l, g * l);
                for (let t = d; t < f; ++t) {
                    const n = s[t];
                    if (n < 0 || n >= u[0]) throw new Error(ch(t, s[t], u[0]));
                    for (let t = 0; t < l; t++) p[g * l + t] += e[n * l + t]
                }
                if (a)
                    for (let e = 0; e < l; e++) p[g * l + e] /= f - d;
                if (d = f, ++f, m = g + 1, g = t, f > o) break
            }
            return m < c && p.fill(i, m * l, c * l), [p, h]
        }
        const m$ = {
            kernelName: Jn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    data: s,
                    indices: r,
                    segmentIds: a
                } = t;
                if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
                if (1 !== r.shape.length) throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);
                if (1 !== a.shape.length) throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);
                if (r.shape[0] !== a.shape[0]) throw new Error("segmentIds and indices should have same size.");
                const i = n.data.get(s.dataId).values,
                    o = n.data.get(r.dataId).values,
                    u = n.data.get(a.dataId).values,
                    [l, c] = f$(i, s.shape, s.dtype, o, u, !0);
                return n.makeTensorInfo(c, s.dtype, l)
            }
        };
        const g$ = {
            kernelName: Zn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    data: s,
                    indices: r,
                    segmentIds: a
                } = t;
                if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
                if (1 !== r.shape.length) throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);
                if (1 !== a.shape.length) throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);
                if (r.shape[0] !== a.shape[0]) throw new Error("segmentIds and indices should have same size.");
                const i = n.data.get(s.dataId).values,
                    o = n.data.get(r.dataId).values,
                    u = n.data.get(a.dataId).values,
                    [l, c] = f$(i, s.shape, s.dtype, o, u);
                return n.makeTensorInfo(c, s.dtype, l)
            }
        };
        const y$ = {
            kernelName: Qn,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    sparseIndices: r,
                    sparseValues: a,
                    defaultValue: i
                } = t, {
                    outputShape: o
                } = s, {
                    sliceRank: u,
                    numUpdates: l,
                    sliceSize: c,
                    strides: h,
                    outputSize: p
                } = Sc(0, r, o), d = !1, f = n.bufferSync(r);
                let m;
                switch (a.dtype) {
                    case "bool":
                        m = GT(f, n.bufferSync(a), o, p, c, l, u, h, Boolean(n.data.get(i.dataId).values[0]), d);
                        break;
                    case "float32":
                        m = GT(f, n.bufferSync(a), o, p, c, l, u, h, n.data.get(i.dataId).values[0], d);
                        break;
                    case "int32":
                        m = GT(f, n.bufferSync(a), o, p, c, l, u, h, n.data.get(i.dataId).values[0], d);
                        break;
                    case "string":
                        m = GT(f, n.bufferSync(a), o, p, c, l, u, h, Js(n.data.get(i.dataId).values[0]), d);
                        break;
                    default:
                        throw new Error(`Unsupported type ${a.dtype}`)
                }
                return n.makeTensorInfo(o, m.dtype, m.values)
            }
        };
        const b$ = {
                kernelName: qn,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        numOrSizeSplits: a,
                        axis: i
                    } = s, o = W(i, r.shape)[0], u = Zc(r, a, o), l = new Array(r.shape.length).fill(0), c = r.shape.slice();
                    return u.map((e => {
                        const t = [...c];
                        t[o] = e;
                        const s = dI({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                begin: l,
                                size: t
                            }
                        });
                        return l[o] += e, s
                    }))
                }
            },
            x$ = cv((e => Math.sqrt(e))),
            w$ = Kk(Gn, (e => Math.sqrt(e))),
            k$ = {
                kernelName: Gn,
                backendName: "cpu",
                kernelFunc: w$
            },
            v$ = {
                kernelName: ts,
                backendName: "cpu",
                kernelFunc: ({
                    inputs: e,
                    backend: t
                }) => {
                    const {
                        x: n
                    } = e, s = t;
                    Hk(n, "square");
                    const r = s.data.get(n.dataId).values,
                        a = new Float32Array(r.length);
                    for (let e = 0; e < r.length; ++e) {
                        const t = r[e];
                        a[e] = t * t
                    }
                    return {
                        dataId: s.write(a, n.shape, n.dtype),
                        shape: n.shape,
                        dtype: n.dtype
                    }
                }
            },
            I$ = nv(((e, t) => {
                const n = e - t;
                return n * n
            })),
            N$ = vv(es, I$),
            S$ = {
                kernelName: es,
                backendName: "cpu",
                kernelFunc: N$
            },
            T$ = Kk(ys, ((e, t) => {
                const n = t;
                return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha
            })),
            $$ = {
                kernelName: ys,
                backendName: "cpu",
                kernelFunc: T$
            };

        function C$(e, t, n, s) {
            const r = Aa(e, t.dtype);
            for (let e = 0; e < r.size; e++) {
                const a = r.indexToLoc(e),
                    i = new Array(a.length);
                for (let e = 0; e < i.length; e++) i[e] = a[e] * n[e] + s[e];
                r.set(t.get(...i), ...a)
            }
            return r
        }
        const E$ = {
            kernelName: ns,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    begin: a,
                    end: i,
                    strides: o,
                    beginMask: u,
                    endMask: l,
                    ellipsisMask: c,
                    newAxisMask: h,
                    shrinkAxisMask: p
                } = s;
                Hk(r, "stridedSlice");
                const {
                    finalShapeSparse: d,
                    finalShape: f,
                    isIdentity: m,
                    sliceDim0: g,
                    isSimpleSlice: y,
                    begin: b,
                    end: x,
                    strides: w
                } = ci(r.shape, a, i, o, u, l, c, h, p);
                let k;
                if (m) k = Cv({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: f
                    }
                });
                else if (g || y) {
                    R(r.shape.length >= 1, (() => `Input must have rank at least 1, got: ${r.shape.length}`));
                    const e = Ja(b, x, w),
                        t = dI({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                begin: b,
                                size: e
                            }
                        });
                    k = Cv({
                        inputs: {
                            x: t
                        },
                        backend: n,
                        attrs: {
                            shape: f
                        }
                    }), n.disposeIntermediateTensorInfo(t)
                } else {
                    const e = C$(d, n.bufferSync(r), w, b);
                    k = n.makeTensorInfo(f, e.dtype, e.values)
                }
                return k
            }
        };
        class A$ {
            constructor(e, t, n, s, r, a) {
                this.separator = Ys(e), this.nGramWidths = t, this.leftPad = Ys(n), this.rightPad = Ys(s), this.padWidth = r, this.preserveShort = a
            }
            getPadWidth(e) {
                return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1)
            }
            getNumNGrams(e, t) {
                const n = this.getPadWidth(t);
                return Math.max(0, e + 2 * n - t + 1)
            }
            createNGrams(e, t, n, s, r, a) {
                for (let i = 0; i < r; ++i) {
                    const o = this.getPadWidth(a),
                        u = Math.max(0, o - i),
                        l = Math.max(0, o - (r - (i + 1))),
                        c = a - (u + l),
                        h = t + (u > 0 ? 0 : i - o);
                    let p = 0;
                    p += u * this.leftPad.length;
                    for (let t = 0; t < c; ++t) p += e[h + t].length;
                    p += l * this.rightPad.length;
                    p += (u + l + c - 1) * this.separator.length, n[s + i] = new Uint8Array(p);
                    const d = n[s + i];
                    let f = 0;
                    const m = e => e.forEach((e => d[f++] = e));
                    for (let e = 0; e < u; ++e) m(this.leftPad), m(this.separator);
                    for (let t = 0; t < c - 1; ++t) m(e[h + t]), m(this.separator);
                    if (c > 0) {
                        m(e[h + c - 1]);
                        for (let e = 0; e < l; ++e) m(this.separator), m(this.rightPad)
                    } else {
                        for (let e = 0; e < l - 1; ++e) m(this.rightPad), m(this.separator);
                        m(this.rightPad)
                    }
                }
            }
            compute(e, t) {
                const n = e.length,
                    s = t.length;
                if (s > 0) {
                    let e = t[0];
                    if (0 !== e) throw new Error(`First split value must be 0, got ${e}`);
                    for (let r = 1; r < s; ++r) {
                        let s = t[r] >= e;
                        if (s = s && t[r] <= n, !s) throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);
                        e = t[r]
                    }
                    if (e !== n) throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)
                }
                const r = s - 1,
                    a = H("int32", s);
                if (0 === n || 0 === s) {
                    const e = new Array(n);
                    for (let e = 0; e <= r; ++e) a[e] = 0;
                    return [e, a]
                }
                a[0] = 0;
                for (let e = 1; e <= r; ++e) {
                    const n = t[e] - t[e - 1];
                    let s = 0;
                    this.nGramWidths.forEach((e => {
                        s += this.getNumNGrams(n, e)
                    })), this.preserveShort && n > 0 && 0 === s && (s = 1), a[e] = a[e - 1] + s
                }
                const i = new Array(a[r]);
                for (let n = 0; n < r; ++n) {
                    const s = t[n];
                    let r = a[n];
                    if (this.nGramWidths.forEach((a => {
                            const o = t[n + 1] - t[n],
                                u = this.getNumNGrams(o, a);
                            this.createNGrams(e, s, i, r, u, a), r += u
                        })), this.preserveShort && r === a[n]) {
                        const a = t[n + 1] - t[n];
                        if (0 === a) continue;
                        const o = a + 2 * this.padWidth,
                            u = 1;
                        this.createNGrams(e, s, i, r, u, o)
                    }
                }
                return [i, a]
            }
        }

        function R$(e, t, n, s, r, a, i, o) {
            return new A$(n, s, r, a, i, o).compute(e, t)
        }
        const F$ = {
            kernelName: ss,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    separator: r,
                    nGramWidths: a,
                    leftPad: i,
                    rightPad: o,
                    padWidth: u,
                    preserveShortSequences: l
                } = s, {
                    data: c,
                    dataSplits: h
                } = t, p = n.data.get(c.dataId).values, d = n.data.get(h.dataId).values, [f, m] = R$(p, d, r, a, i, o, u, l);
                return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", m)]
            }
        };

        function D$(e, t, n, s) {
            if (!e.length) return;
            if (0 === t.length) {
                for (let t = 0; t < e.length; ++t) s.push(e.subarray(t, t + 1));
                return
            }
            if (1 === t.length) {
                const r = t[0];
                let a = e.indexOf(r);
                for (; - 1 !== a;) {
                    const t = e.subarray(0, a);
                    n && 0 === t.length || s.push(t), a = (e = e.subarray(a + 1)).indexOf(r)
                }
                return void(n && 0 === e.length || s.push(e))
            }
            let r = 0;
            for (let a = 0; a < e.length + 1; a++)
                if (a === e.length || -1 !== t.indexOf(e[a])) {
                    const t = e.subarray(r, a);
                    n && 0 === t.length || s.push(t), r = a + 1
                }
        }

        function _$(e, t, n) {
            const s = e.length,
                r = [];
            let a = 0,
                i = 0;
            const o = new Array(s);
            for (let u = 0; u < s; ++u) {
                const s = r.length;
                D$(e[u], t, n, r);
                const l = r.length - s;
                o[u] = l, a += l, i = Math.max(i, l)
            }
            const u = H("int32", 2 * a),
                l = new Array(a),
                c = [s, i];
            let h = 0;
            for (let e = 0; e < s; ++e)
                for (let t = 0; t < o[e]; ++t) u[2 * h] = e, u[2 * h + 1] = t, l[h] = r[h], ++h;
            return [u, l, c]
        }
        const O$ = {
            kernelName: rs,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    skipEmpty: r
                } = s, {
                    input: a,
                    delimiter: i
                } = t;
                if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
                if (1 !== a.shape.length) throw new Error(`Input must be a vector, got shape: ${a.shape}`);
                if (0 !== i.shape.length) throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
                const o = n.data.get(a.dataId).values,
                    u = n.data.get(i.dataId).values[0],
                    [l, c, h] = _$(o, u, r),
                    p = c.length;
                return [n.makeTensorInfo([p, 2], "int32", l), n.makeTensorInfo([p], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))]
            }
        };

        function M$(e, t) {
            const n = H("int32", e.length);
            for (let s = 0; s < e.length; ++s) n[s] = js(e[s]).modulo(t).getLowBitsUnsigned();
            return n
        }
        const L$ = {
                kernelName: as,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        numBuckets: r
                    } = s, {
                        input: a
                    } = t;
                    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
                    if (r <= 0) throw new Error("Number of buckets must be at least 1");
                    const i = M$(n.data.get(a.dataId).values, r);
                    return n.makeTensorInfo(a.shape, "int32", i)
                }
            },
            z$ = Kk(os, (e => Math.tan(e))),
            B$ = {
                kernelName: os,
                backendName: "cpu",
                kernelFunc: z$
            },
            P$ = Kk(us, (e => Math.tanh(e)));

        function U$(e, t) {
            const n = new Array(e.rank);
            for (let s = 0; s < n.length; s++) n[s] = e.shape[s] * t[s];
            const s = Aa(n, e.dtype);
            for (let t = 0; t < s.values.length; ++t) {
                const n = s.indexToLoc(t),
                    r = new Array(e.rank);
                for (let t = 0; t < r.length; t++) r[t] = n[t] % e.shape[t];
                const a = e.locToIndex(r);
                s.values[t] = e.values[a]
            }
            return s
        }
        const W$ = {
                kernelName: ls,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        reps: a
                    } = s;
                    Hk(r, "tile");
                    const i = U$(n.bufferSync(r), a);
                    return n.makeTensorInfo(i.shape, i.dtype, i.values)
                }
            },
            V$ = (e, t) => {
                const n = t.value - e.value;
                return 0 === n ? e.index - t.index : n
            };

        function G$(e, t, n = 0, s = e.length - 1) {
            for (; s > n;) {
                if (s - n > 600) {
                    const r = s - n + 1,
                        a = t - n + 1,
                        i = Math.log(r),
                        o = .5 * Math.exp(2 * i / 3),
                        u = .5 * Math.sqrt(i * o * (r - o) / r) * Math.sign(a - r / 2);
                    G$(e, t, Math.max(n, Math.floor(t - a * o / r + u)), Math.min(s, Math.floor(t + (r - a) * o / r + u)))
                }
                const r = e[t];
                let a = n,
                    i = s;
                for (A(e, n, t), V$(e[s], r) > 0 && A(e, n, s); a < i;) {
                    for (A(e, a, i), a++, i--; V$(e[a], r) < 0;) a += 1;
                    for (; V$(e[i], r) > 0;) i -= 1
                }
                0 === V$(e[n], r) ? A(e, n, i) : (i += 1, A(e, i, s)), i <= t && (n = i + 1), t <= i && (s = i - 1)
            }
        }

        function H$(e, t, n, s, r) {
            const a = t[t.length - 1],
                [i, o] = [e.length / a, a],
                u = G(n, i * s),
                l = G("int32", i * s);
            for (let t = 0; t < i; t++) {
                const n = t * o,
                    a = e.subarray(n, n + o);
                let i = new Array(a.length);
                a.forEach(((e, t) => i[t] = {
                    value: e,
                    index: t
                })), s < i.length && (G$(i, s), i = i.slice(0, s)), r && i.sort(V$);
                const c = t * s,
                    h = u.subarray(c, c + s),
                    p = l.subarray(c, c + s);
                for (let e = 0; e < s; e++) h[e] = i[e].value, p[e] = i[e].index
            }
            const c = t.slice();
            return c[c.length - 1] = s, [Aa(c, n, u), Aa(c, "int32", l)]
        }
        const j$ = {
            kernelName: cs,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    k: a,
                    sorted: i
                } = s;
                Hk(r, "topk");
                const o = n.data.get(r.dataId).values,
                    [u, l] = H$(o, r.shape, r.dtype, a, i);
                return [n.makeTensorInfo(u.shape, u.dtype, u.values), n.makeTensorInfo(l.shape, l.dtype, l.values)]
            }
        };
        const q$ = {
            kernelName: hs,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    attrs: n,
                    backend: s
                } = e, {
                    image: r,
                    transforms: a
                } = t, {
                    interpolation: i,
                    fillMode: o,
                    fillValue: u,
                    outputShape: l
                } = n, [c, h, p, d] = r.shape, [f, m] = null != l ? l : [h, p], g = [c, f, m, d], y = ee(r.shape), b = y[0], x = y[1], w = y[2], k = G(r.dtype, O(g));
                k.fill(u);
                const v = s.data.get(r.dataId).values,
                    I = s.data.get(a.dataId).values;
                for (let e = 0; e < c; ++e) {
                    const t = 1 === a.shape[0] ? I : I.subarray(8 * e, 8 * e + 8);
                    for (let n = 0; n < f; ++n)
                        for (let s = 0; s < m; ++s)
                            for (let r = 0; r < d; ++r) {
                                let a;
                                const l = t[6] * s + t[7] * n + 1;
                                if (0 === l) continue;
                                const c = (t[0] * s + t[1] * n + t[2]) / l,
                                    d = (t[3] * s + t[4] * n + t[5]) / l,
                                    f = K$(c, p, o),
                                    m = K$(d, h, o);
                                switch (i) {
                                    case "nearest":
                                        a = Y$(v, h, p, b, x, w, e, m, f, r, u);
                                        break;
                                    case "bilinear":
                                        a = J$(v, h, p, b, x, w, e, m, f, r, u);
                                        break;
                                    default:
                                        throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)
                                }
                                k[e * b + n * x + s * w + r] = a
                            }
                    return s.makeTensorInfo(g, r.dtype, k)
                }
                return {
                    dataId: s.write(k, g, r.dtype),
                    shape: r.shape,
                    dtype: r.dtype
                }
            }
        };

        function K$(e, t, n) {
            switch (n) {
                case "reflect":
                    return function(e, t) {
                        let n = e;
                        if (n < 0)
                            if (t <= 1) n = 0;
                            else {
                                const e = 2 * t;
                                n < e && (n = e * Math.trunc(-n / e) + n), n = n < -t ? n + e : -n - 1
                            }
                        else if (n > t - 1)
                            if (t <= 1) n = 0;
                            else {
                                const e = 2 * t;
                                n -= e * Math.trunc(n / e), n >= t && (n = e - n - 1)
                            } return C(0, n, t - 1)
                    }(e, t);
                case "wrap":
                    return function(e, t) {
                        let n = e;
                        if (n < 0)
                            if (t <= 1) n = 0;
                            else {
                                const e = t - 1;
                                n += t * (Math.trunc(-n / e) + 1)
                            }
                        else if (n > t - 1)
                            if (t <= 1) n = 0;
                            else {
                                const e = t - 1;
                                n -= t * Math.trunc(n / e)
                            } return C(0, n, t - 1)
                    }(e, t);
                case "nearest":
                    return function(e, t) {
                        return C(0, e, t - 1)
                    }(e, t);
                default:
                    return function(e) {
                        return e
                    }(e)
            }
        }

        function X$(e, t, n, s, r, a, i, o, u, l, c) {
            return 0 <= o && o < t && 0 <= u && u < n ? e[i * s + o * r + u * a + l] : c
        }

        function Y$(e, t, n, s, r, a, i, o, u, l, c) {
            return X$(e, t, n, s, r, a, i, Math.round(o), Math.round(u), l, c)
        }

        function J$(e, t, n, s, r, a, i, o, u, l, c) {
            const h = Math.floor(o),
                p = Math.floor(u),
                d = h + 1,
                f = p + 1;
            return (d - o) * ((f - u) * X$(e, t, n, s, r, a, i, h, p, l, c) + (u - p) * X$(e, t, n, s, r, a, i, h, f, l, c)) + (o - h) * ((f - u) * X$(e, t, n, s, r, a, i, d, p, l, c) + (u - p) * X$(e, t, n, s, r, a, i, d, f, l, c))
        }

        function Z$(e, t, n, s) {
            const r = W(t, n)[0],
                a = [1, n[0], 1];
            for (let e = 0; e < r; e++) a[0] *= n[e];
            a[1] = n[r];
            for (let e = r + 1; e < n.length; e++) a[2] *= n[e];
            const i = {},
                o = new Int32Array(n[r]),
                u = new ir(a, s, e),
                l = [],
                c = 1 === a[0] && 1 === a[2];
            for (let t = 0; t < n[r]; t++) {
                let n;
                if (c) n = e[t].toString();
                else {
                    const e = [];
                    for (let n = 0; n < a[0]; n++)
                        for (let s = 0; s < a[2]; s++) e.push(u.get(n, t, s));
                    n = e.join(",")
                }
                if (void 0 !== i[n]) o[t] = i[n];
                else {
                    const e = Object.keys(i).length;
                    i[n] = e, o[t] = e, l.push(t)
                }
            }
            const h = a.slice();
            h[1] = Object.keys(i).length;
            const p = new ir(h, s);
            l.forEach(((e, t) => {
                for (let n = 0; n < a[0]; n++)
                    for (let s = 0; s < a[2]; s++) p.set(u.get(n, e, s), n, t, s)
            }));
            const d = n.slice();
            return d[r] = h[1], {
                outputValues: p.values,
                outputShape: d,
                indices: o
            }
        }
        const Q$ = {
            kernelName: ds,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    attrs: n,
                    backend: s
                } = e, {
                    axis: r
                } = n, {
                    x: a
                } = t;
                Hk(a, "unique");
                const i = s.data.get(a.dataId).values,
                    {
                        outputValues: o,
                        outputShape: u,
                        indices: l
                    } = Z$(i, r, a.shape, a.dtype);
                return [s.makeTensorInfo(u, a.dtype, o), s.makeTensorInfo([l.length], "int32", l)]
            }
        };
        const eC = {
            kernelName: fs,
            backendName: "cpu",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    value: r
                } = t;
                let {
                    axis: a
                } = s;
                a < 0 && (a += r.shape.length);
                const i = r.shape.length,
                    o = r.shape[a],
                    u = new Array(i - 1);
                let l = 0;
                for (let e = 0; e < i; e++) e !== a && (u[l++] = r.shape[e]);
                const c = new Array(i).fill(0),
                    h = r.shape.slice();
                h[a] = 1;
                const p = new Array(o);
                for (let e = 0; e < p.length; e++) {
                    c[a] = e;
                    const t = dI({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            begin: c,
                            size: h
                        }
                    });
                    p[e] = Cv({
                        inputs: {
                            x: t
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    }), n.disposeIntermediateTensorInfo(t)
                }
                return p
            }
        };
        const tC = {
                kernelName: ms,
                backendName: "cpu",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r,
                        segmentIds: a
                    } = t, {
                        numSegments: i
                    } = s;
                    Hk(r, "unsortedSegmentSum");
                    const o = [],
                        u = [],
                        l = r.shape.length - a.shape.length;
                    let c = a;
                    for (let e = 0; e < l; ++e) {
                        const t = IN({
                            inputs: {
                                input: c
                            },
                            backend: n,
                            attrs: {
                                dim: e + 1
                            }
                        });
                        c = t, u.push(t)
                    }
                    for (let e = 0; e < i; ++e) {
                        const t = qs(e, "int32"),
                            s = n.makeTensorInfo([], "int32", t),
                            a = cN({
                                inputs: {
                                    a: s,
                                    b: c
                                },
                                backend: n
                            }),
                            i = wv({
                                inputs: {
                                    x: a
                                },
                                backend: n,
                                attrs: {
                                    dtype: "float32"
                                }
                            }),
                            l = sN({
                                inputs: {
                                    a: i,
                                    b: r
                                },
                                backend: n
                            }),
                            h = aN({
                                inputs: {
                                    x: l
                                },
                                backend: n,
                                attrs: {
                                    axis: 0,
                                    keepDims: !1
                                }
                            });
                        o.push(h), u.push(s), u.push(a), u.push(i), u.push(l), u.push(h)
                    }
                    const h = kT({
                        inputs: o,
                        backend: n,
                        attrs: {
                            axis: 0
                        }
                    });
                    return u.forEach((e => n.disposeIntermediateTensorInfo(e))), h
                }
            },
            nC = [Fv, _v, Mv, zv, $v, Bv, Vv, Gv, Hv, jv, Kv, Yv, Zv, tI, sI, oI, uI, lI, cI, Rv, hI, mI, bI, xI, kv, vI, NI, gv, SI, AI, FI, DI, _I, OI, MI, LI, BI, UI, WI, VI, GI, HI, jI, KI, XI, YI, JI, ZI, QI, eN, oN, Jk, uN, hN, xN, vN, NN, $N, zN, PN, UN, GN, qN, KN, XN, JN, QN, nS, aS, Qk, iS, CI, uS, cS, pS, tv, mS, bS, wS, IS, SS, CS, AS, DS, _S, OS, zS, US, WS, VS, GS, HS, jS, qS, KS, JS, ZS, tT, aT, rN, oT, lT, hT, dT, gT, yT, wT, vT, IT, TT, av, CT, AT, xv, AN, FT, ov, lv, Ev, DT, _T, OT, MT, LT, zT, PT, VT, HT, KT, XT, QT, dv, t$, s$, a$, fI, rT, u$, l$, h$, d$, m$, g$, y$, b$, k$, v$, S$, $$, E$, F$, O$, L$, _N, iN, B$, {
                kernelName: us,
                backendName: "cpu",
                kernelFunc: P$
            }, W$, j$, q$, Wv, Q$, eC, tC, xT];
        for (const e of nC) As(e);
        const sC = {},
            rC = {
                alpha: !1,
                antialias: !1,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                depth: !1,
                stencil: !1,
                failIfMajorPerformanceCaveat: !0
            };

        function aC(e, t) {
            if (!(e in sC) || null != t) {
                const n = function(e, t) {
                    if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
                    const n = null == t ? function(e) {
                        if ("undefined" != typeof OffscreenCanvas && 2 === e) return new OffscreenCanvas(300, 150);
                        if ("undefined" != typeof document) return document.createElement("canvas");
                        throw new Error("Cannot create a canvas in this context")
                    }(e) : t;
                    if (n.addEventListener("webglcontextlost", (t => {
                            t.preventDefault(), delete sC[e]
                        }), !1), 1 === e) return n.getContext("webgl", rC) || n.getContext("experimental-webgl", rC);
                    return n.getContext("webgl2", rC)
                }(e, t);
                if (null === n) return console.log("Could not get context for WebGL version", e), null;
                sC[e] = n
            }
            const n = sC[e];
            return null == n || n.isContextLost() ? (delete sC[e], aC(e)) : (n.disable(n.DEPTH_TEST), n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), n.cullFace(n.BACK), sC[e])
        }
        var iC, oC, uC;

        function lC(e, t) {
            return [t, e]
        }

        function cC(e) {
            const t = O(e);
            return z(Math.ceil(t / 4))
        }

        function hC(e, t) {
            return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))]
        }

        function pC(e, t) {
            const n = e;
            let s, r, a, i, o, u, l, c, h, p;
            return 2 === de().getNumber("WEBGL_VERSION") ? (s = n.R32F, r = n.R16F, a = n.RGBA16F, i = n.RGBA32F, o = n.RED, l = 4, c = 1, h = n.HALF_FLOAT, p = n.FLOAT, u = n.RGBA8) : (s = e.RGBA, r = e.RGBA, a = e.RGBA, i = n.RGBA, o = e.RGBA, l = 4, c = 4, h = null != t ? t.HALF_FLOAT_OES : null, p = e.FLOAT, u = e.RGBA), {
                internalFormatFloat: s,
                internalFormatHalfFloat: r,
                internalFormatPackedHalfFloat: a,
                internalFormatPackedFloat: i,
                textureFormatFloat: o,
                downloadTextureFormat: u,
                downloadUnpackNumChannels: l,
                defaultNumChannels: c,
                textureTypeHalfFloat: h,
                textureTypeFloat: p
            }
        }

        function dC(e, t) {
            const n = t();
            return de().getBool("DEBUG") && function(e) {
                const t = e.getError();
                if (t !== e.NO_ERROR) throw new Error("WebGL Error: " + function(e, t) {
                    switch (t) {
                        case e.NO_ERROR:
                            return "NO_ERROR";
                        case e.INVALID_ENUM:
                            return "INVALID_ENUM";
                        case e.INVALID_VALUE:
                            return "INVALID_VALUE";
                        case e.INVALID_OPERATION:
                            return "INVALID_OPERATION";
                        case e.INVALID_FRAMEBUFFER_OPERATION:
                            return "INVALID_FRAMEBUFFER_OPERATION";
                        case e.OUT_OF_MEMORY:
                            return "OUT_OF_MEMORY";
                        case e.CONTEXT_LOST_WEBGL:
                            return "CONTEXT_LOST_WEBGL";
                        default:
                            return `Unknown error code ${t}`
                    }
                }(e, t))
            }(e), n
        }! function(e) {
            e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH"
        }(iC || (iC = {})),
        function(e) {
            e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD"
        }(oC || (oC = {})),
        function(e) {
            e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
        }(uC || (uC = {}));

        function fC(e) {
            return !!(de().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e || 5.96e-8 < Math.abs(e) && Math.abs(e) < 65504)
        }

        function mC(e, t) {
            return NC(e, (() => e.getExtension(t)), 'Extension "' + t + '" not supported on this browser.')
        }
        const gC = /ERROR: [0-9]+:([0-9]+):/g;

        function yC(e, t) {
            const n = gC.exec(t);
            if (null == n) return console.log(`Couldn't parse line number in error: ${t}`), void console.log(e);
            const s = +n[1],
                r = e.split("\n"),
                a = r.length.toString().length + 2,
                i = r.map(((e, t) => B((t + 1).toString(), a) + e));
            let o = 0;
            for (let e = 0; e < i.length; e++) o = Math.max(i[e].length, o);
            const u = i.slice(0, s - 1),
                l = i.slice(s - 1, s),
                c = i.slice(s);
            console.log(u.join("\n")), console.log(t.split("\n")[0]), console.log(`%c ${B(l[0],o)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(c.join("\n"))
        }

        function bC(e, t) {
            if (dC(e, (() => e.validateProgram(t))), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.")
        }

        function xC(e, t, n, s, r, a, i) {
            const o = e.getAttribLocation(t, n);
            return -1 !== o && (dC(e, (() => e.bindBuffer(e.ARRAY_BUFFER, s))), dC(e, (() => e.vertexAttribPointer(o, r, e.FLOAT, !1, a, i))), dC(e, (() => e.enableVertexAttribArray(o))), !0)
        }

        function wC(e, t, n, s) {
            dC(e, (() => function(e, t, n) {
                SC(e, n), dC(e, (() => e.activeTexture(e.TEXTURE0 + n))), dC(e, (() => e.bindTexture(e.TEXTURE_2D, t)))
            }(e, t, s))), dC(e, (() => e.uniform1i(n, s)))
        }

        function kC(e, t, n) {
            dC(e, (() => e.bindFramebuffer(e.FRAMEBUFFER, n))), dC(e, (() => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)))
        }

        function vC(e, t) {
            dC(e, (() => e.bindFramebuffer(e.FRAMEBUFFER, t))), dC(e, (() => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)))
        }

        function IC(e) {
            const t = e.checkFramebufferStatus(e.FRAMEBUFFER);
            if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + function(e, t) {
                switch (t) {
                    case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
                    case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
                    case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
                    case e.FRAMEBUFFER_UNSUPPORTED:
                        return "FRAMEBUFFER_UNSUPPORTED";
                    default:
                        return `unknown error ${t}`
                }
            }(e, t))
        }

        function NC(e, t, n) {
            const s = dC(e, (() => t()));
            if (null == s) throw new Error(n);
            return s
        }

        function SC(e, t) {
            const n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
                s = t + e.TEXTURE0;
            if (s < e.TEXTURE0 || s > n) {
                throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)
            }
        }

        function TC(e, t = 2) {
            return O(e.slice(0, e.length - t))
        }

        function $C(e) {
            if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
            return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]]
        }

        function CC(e) {
            let t = [1, 1, 1];
            return 0 === e.length || 1 === e.length && 1 === e[0] || (t = [TC(e), ...$C(e)]), t
        }

        function EC(e) {
            return e % 2 == 0
        }

        function AC(e, t) {
            if (M(e = e.slice(-2), t = t.slice(-2))) return !0;
            if (!e.length || !t.length) return !0;
            if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;
            if (e.length !== t.length) {
                const n = e.slice(-1)[0],
                    s = t.slice(-1)[0];
                if (n === s) return !0;
                if (EC(n) && EC(s) && (1 === e[0] || 1 === t[0])) return !0
            }
            return e[1] === t[1] && EC(e[0]) && EC(t[0])
        }
        let RC, FC;

        function DC(e, t) {
            return null != e.getExtension(t)
        }

        function _C(e) {
            try {
                if (null != aC(e)) return !0
            } catch (e) {
                return console.log("Error when getting WebGL context: ", e), !1
            }
            return !1
        }

        function OC(e) {
            if (0 === e) return !1;
            const t = aC(e);
            if (1 !== e) {
                if (DC(t, "EXT_color_buffer_float")) return MC(t);
                const e = "EXT_color_buffer_half_float";
                if (DC(t, e)) {
                    const n = t.getExtension(e);
                    return function(e, t) {
                        const n = pC(e, t),
                            s = e.createTexture();
                        e.bindTexture(e.TEXTURE_2D, s);
                        const r = 1,
                            a = 1;
                        e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, r, a, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
                        const i = e.createFramebuffer();
                        e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, s, 0);
                        const o = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
                        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(s), e.deleteFramebuffer(i), o
                    }(t, n)
                }
                return !1
            }
            if (!DC(t, "OES_texture_float")) return !1;
            if (!DC(t, "WEBGL_color_buffer_float")) return !1;
            return MC(t)
        }

        function MC(e) {
            const t = pC(e),
                n = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, n);
            e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
            const s = e.createFramebuffer();
            e.bindFramebuffer(e.FRAMEBUFFER, s), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
            const r = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
            return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(s), r
        }

        function LC(e, t) {
            Array.isArray(e) || (e = [e]), e.forEach((e => {
                null != e && R("complex64" !== e.dtype, (() => `${t} does not support complex64 tensors in the WebGL backend.`))
            }))
        }
        const zC = de();

        function BC() {
            let e, t, n, s, r, a, i, o, u, l;
            return 2 === de().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", t = "in", n = "out", s = "in", r = "texture", a = "outputColor", i = "out vec4 outputColor;", o = "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", u = "", l = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", t = "attribute", n = "varying", s = "varying", r = "texture2D", a = "gl_FragColor", i = "", o = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", u = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
                version: e,
                attribute: t,
                varyingVs: n,
                varyingFs: s,
                texture2D: r,
                output: a,
                defineOutput: i,
                defineSpecialNaN: o,
                defineSpecialInf: u,
                defineRound: l
            }
        }

        function PC(e, t, n = "index") {
            const s = ee(t);
            return s.map(((t, r) => `${`int ${e[r]} = ${n} / ${t}`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`)).join("")
        }

        function UC(e, t, n = "index") {
            const s = ee(t);
            return s.map(((t, r) => `${`int ${e[r]} = ${n} / outShapeStrides[${r}]`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * outShapeStrides[${r}]`:`index -= ${e[r]} * outShapeStrides[${r}]`};`)).join("")
        }

        function WC(e, t, n = "index") {
            const s = function(e, t) {
                const n = e.length,
                    s = e.map((e => `${t}[${e}]`)),
                    r = new Array(n - 1);
                r[n - 2] = s[n - 1];
                for (let e = n - 3; e >= 0; --e) r[e] = `(${r[e+1]} * ${s[e+1]})`;
                return r
            }(e.map(((e, t) => t)), t);
            return s.map(((t, r) => `${`int ${e[r]} = ${n} / ${s[r]}`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${s[r]}`:`index -= ${e[r]} * ${s[r]}`};`)).join("")
        }

        function VC(e) {
            const t = ee(e).map((e => e.toString()));
            return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`
        }
        zC.registerFlag("HAS_WEBGL", (() => zC.getNumber("WEBGL_VERSION") > 0)), zC.registerFlag("WEBGL_VERSION", (() => _C(2) ? 2 : _C(1) ? 1 : 0)), zC.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", (() => !1)), zC.registerFlag("WEBGL_BUFFER_SUPPORTED", (() => 2 === zC.get("WEBGL_VERSION"))), zC.registerFlag("WEBGL_CPU_FORWARD", (() => !0)), zC.registerFlag("WEBGL_FORCE_F16_TEXTURES", (() => !1)), zC.registerFlag("WEBGL_PACK", (() => zC.getBool("HAS_WEBGL"))), zC.registerFlag("WEBGL_PACK_NORMALIZATION", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_CLIP", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_DEPTHWISECONV", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_PACK_REDUCE", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_LAZILY_UNPACK", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_CONV_IM2COL", (() => zC.getBool("WEBGL_PACK"))), zC.registerFlag("WEBGL_MAX_TEXTURE_SIZE", (() => function(e) {
            if (null == RC) {
                const t = aC(e);
                RC = t.getParameter(t.MAX_TEXTURE_SIZE)
            }
            return RC
        }(zC.getNumber("WEBGL_VERSION")))), zC.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", (() => function(e) {
            if (null == FC) {
                const t = aC(e);
                FC = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
            }
            return Math.min(16, FC)
        }(zC.getNumber("WEBGL_VERSION")))), zC.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", (() => {
            const e = zC.getNumber("WEBGL_VERSION");
            return 0 === e ? 0 : function(e) {
                if (0 === e) return 0;
                let t;
                const n = aC(e);
                return t = DC(n, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : DC(n, "EXT_disjoint_timer_query") ? 1 : 0, t
            }(e)
        })), zC.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", (() => zC.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !Fr())), zC.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", (() => function(e) {
            if (0 === e) return !1;
            const t = aC(e);
            if (1 === e) {
                if (!DC(t, "OES_texture_float")) return !1
            } else if (!DC(t, "EXT_color_buffer_float")) return !1;
            return MC(t)
        }(zC.getNumber("WEBGL_VERSION")))), zC.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", (() => !zC.getBool("WEBGL_FORCE_F16_TEXTURES") && zC.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))), zC.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", (() => OC(zC.getNumber("WEBGL_VERSION")))), zC.registerFlag("WEBGL_FENCE_API_ENABLED", (() => {
            return 2 === (e = zC.getNumber("WEBGL_VERSION")) && null != aC(e).fenceSync;
            var e
        })), zC.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", (() => zC.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0)), zC.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", (() => -1), (e => {
            if (e < 0 && -1 !== e) throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)
        })), zC.registerFlag("WEBGL_FLUSH_THRESHOLD", (() => Fr() ? 1 : -1), (e => {
            if (e < 0 && -1 !== e) throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)
        })), zC.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", (() => 128)), zC.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", (() => !1)), zC.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", (() => 1e5)), zC.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", (() => 128));
        const GC = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",
            {
                getBroadcastDims: HC
            } = s;

        function jC(e, t, n) {
            const s = [];
            if (e.forEach((e => {
                    const t = O(e.shapeInfo.logicalShape);
                    if (e.shapeInfo.isUniform ? s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`) : (s.push(`uniform sampler2D ${e.name};`), s.push(`uniform int offset${e.name};`)), n.enableShapeUniforms) {
                        const {
                            uniformShape: t
                        } = sE(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape);
                        switch (t.length) {
                            case 1:
                                s.push(`uniform int ${e.name}Shape;`);
                                break;
                            case 2:
                                s.push(`uniform ivec2 ${e.name}Shape;`);
                                break;
                            case 3:
                                s.push(`uniform ivec3 ${e.name}Shape;`);
                                break;
                            case 4:
                                s.push(`uniform ivec4 ${e.name}Shape;`)
                        }
                        s.push(`uniform ivec2 ${e.name}TexShape;`)
                    }
                })), n.enableShapeUniforms) {
                switch (t.logicalShape.length) {
                    case 1:
                        s.push("uniform int outShape;");
                        break;
                    case 2:
                        s.push("uniform ivec2 outShape;"), s.push("uniform int outShapeStrides;");
                        break;
                    case 3:
                        s.push("uniform ivec3 outShape;"), s.push("uniform ivec2 outShapeStrides;");
                        break;
                    case 4:
                        s.push("uniform ivec4 outShape;"), s.push("uniform ivec3 outShapeStrides;")
                }
                s.push("uniform ivec2 outTexShape;")
            }
            n.customUniforms && n.customUniforms.forEach((e => {
                s.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)
            }));
            const r = s.join("\n"),
                a = e.map((e => function(e, t, n = !1, s) {
                    let r = "";
                    r += n ? KC(e, s) : qC(e, s);
                    const a = e.shapeInfo.logicalShape,
                        i = t.logicalShape;
                    a.length <= i.length && (r += n ? function(e, t) {
                        const n = e.name,
                            s = n.charAt(0).toUpperCase() + n.slice(1),
                            r = "get" + s + "AtOutCoords",
                            a = e.shapeInfo.logicalShape.length,
                            i = t.logicalShape.length,
                            o = HC(e.shapeInfo.logicalShape, t.logicalShape),
                            u = nE(i),
                            l = i - a;
                        let c;
                        const h = ["x", "y", "z", "w", "u", "v"];
                        c = 0 === a ? "" : i < 2 && o.length >= 1 ? "coords = 0;" : o.map((e => `coords.${h[e+l]} = 0;`)).join("\n");
                        let p = "";
                        p = i < 2 && a > 0 ? "coords" : e.shapeInfo.logicalShape.map(((e, t) => `coords.${h[t+l]}`)).join(", ");
                        let d = "return outputValue;";
                        const f = 1 === O(e.shapeInfo.logicalShape),
                            m = O(t.logicalShape),
                            g = 1 === m;
                        if (1 !== a || f || g) {
                            if (f && !g) d = 1 === i ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
                            else if (o.length) {
                                const e = a - 2,
                                    t = a - 1;
                                o.indexOf(e) > -1 && o.indexOf(t) > -1 ? d = "return vec4(outputValue.x);" : o.indexOf(e) > -1 ? d = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : o.indexOf(t) > -1 && (d = "return vec4(outputValue.xx, outputValue.zz);")
                            }
                        } else d = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
                        return `\n    vec4 ${r}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${p});\n      ${d}\n    }\n  `
                    }(e, t) : function(e, t) {
                        const n = e.name,
                            s = n.charAt(0).toUpperCase() + n.slice(1),
                            r = "get" + s + "AtOutCoords",
                            a = t.texShape,
                            i = e.shapeInfo.texShape,
                            o = e.shapeInfo.logicalShape.length,
                            u = t.logicalShape.length;
                        if (!e.shapeInfo.isUniform && o === u && null == e.shapeInfo.flatOffset && M(i, a)) return `\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;
                        const l = nE(u),
                            c = HC(e.shapeInfo.logicalShape, t.logicalShape),
                            h = u - o;
                        let p;
                        const d = ["x", "y", "z", "w", "u", "v"];
                        p = 0 === o ? "" : u < 2 && c.length >= 1 ? "coords = 0;" : c.map((e => `coords.${d[e+h]} = 0;`)).join("\n");
                        let f = "";
                        f = u < 2 && o > 0 ? "coords" : e.shapeInfo.logicalShape.map(((e, t) => `coords.${d[t+h]}`)).join(", ");
                        return `\n    float ${r}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      return get${s}(${f});\n    }\n  `
                    }(e, t));
                    return r
                }(e, t, n.packedInputs, n.enableShapeUniforms))).join("\n"),
                i = t.texShape,
                o = BC(),
                u = function(e) {
                    return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `
                }(o);
            let l, c, h = function(e) {
                const t = `${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${XC}\n    ${YC}\n    ${JC}\n  `;
                return t
            }(o);
            t.isPacked ? (l = function(e, t, n) {
                switch (e.length) {
                    case 0:
                        return QC();
                    case 1:
                        return function(e, t, n) {
                            const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                            if (1 === s[0]) return n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `;
                            if (1 === s[1]) return n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `;
                            if (n) return "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";
                            return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `
                        }(0, t, n);
                    case 2:
                        return function(e, t, n) {
                            const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                            if (M(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `;
                            const r = Math.ceil(e[1] / 2);
                            if (n) return "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";
                            return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `
                        }(e, t, n);
                    case 3:
                        return function(e, t, n) {
                            if (n) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
                            const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
                                r = Math.ceil(e[2] / 2),
                                a = r * Math.ceil(e[1] / 2);
                            return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `
                        }(e, t, n);
                    default:
                        return function(e, t, n) {
                            if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
                            const s = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
                                r = Math.ceil(e[e.length - 1] / 2),
                                a = r * Math.ceil(e[e.length - 2] / 2);
                            let i = a,
                                o = "",
                                u = "b, r, c";
                            for (let t = 2; t < e.length - 1; t++) i *= e[e.length - t - 1], o = `\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    ` + o, u = `b${t}, ` + u;
                            return `\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `
                        }(e, t, n)
                }
            }(t.logicalShape, i, n.enableShapeUniforms), c = function(e) {
                return `\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `
            }(o)) : (l = function(e, t, n) {
                switch (e.length) {
                    case 0:
                        return QC();
                    case 1:
                        return function(e, t, n) {
                            if (1 === t[0]) return n ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : `\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;
                            if (1 === t[1]) return n ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : `\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;
                            if (n) return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";
                            return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `
                        }(0, t, n);
                    case 2:
                        return function(e, t, n) {
                            if (M(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;
                            if (1 === e[1]) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;
                            if (1 === e[0]) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;
                            if (n) return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";
                            return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `
                        }(e, t, n);
                    case 3:
                        return function(e, t, n) {
                            if (n) {
                                return `\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${UC(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`
                            }
                            const s = PC(["r", "c", "d"], e);
                            return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `
                        }(e, t, n);
                    case 4:
                        return function(e, t, n) {
                            if (n) {
                                return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${UC(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `
                            }
                            const s = PC(["r", "c", "d", "d2"], e);
                            return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `
                        }(e, t, n);
                    case 5:
                        return function(e, t) {
                            const n = PC(["r", "c", "d", "d2", "d3"], e);
                            return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `
                        }(e, t);
                    case 6:
                        return function(e, t) {
                            const n = PC(["r", "c", "d", "d2", "d3", "d4"], e);
                            return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `
                        }(e, t);
                    default:
                        throw new Error(`${e.length}-D output sampling is not yet supported`)
                }
            }(t.logicalShape, i, n.enableShapeUniforms), c = function(e) {
                return `\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `
            }(o)), n.packedInputs && (h += ZC);
            return [h, u, c, r, l, a, n.userCode].join("\n")
        }

        function qC(e, t = !1) {
            const n = e.shapeInfo.logicalShape;
            switch (n.length) {
                case 0:
                    return function(e, t) {
                        const n = e.name,
                            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
                        if (e.shapeInfo.isUniform) return `float ${s}() {return ${n};}`;
                        const [r, a] = e.shapeInfo.texShape;
                        if (1 === r && 1 === a) return `\n      float ${s}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;
                        const i = eE(n);
                        if (t) return `\n    float ${s}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;
                        const [o, u] = e.shapeInfo.texShape;
                        return `\n    float ${s}() {\n      vec2 uv = uvFromFlat(${o}, ${u}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `
                    }(e, t);
                case 1:
                    return function(e, t) {
                        const n = e.name,
                            s = "get" + n.charAt(0).toUpperCase() + n.slice(1);
                        if (e.shapeInfo.isUniform) return `\n      float ${s}(int index) {\n        ${tE(e)}\n      }\n    `;
                        const r = e.shapeInfo.texShape,
                            a = r[0],
                            i = r[1];
                        if (1 === i && 1 === a) return `\n      float ${s}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;
                        const o = eE(n);
                        if (1 === i) return t ? `\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    ` : `\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;
                        if (1 === a) return t ? `\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    ` : `\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;
                        if (t) return `\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;
                        return `\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `
                    }(e, t);
                case 2:
                    return function(e, t) {
                        const n = e.shapeInfo.logicalShape,
                            s = e.name,
                            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
                            a = e.shapeInfo.texShape;
                        if (null != a && M(n, a)) {
                            if (t) return `\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                            const e = a[0];
                            return `\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `
                        }
                        const {
                            newShape: i,
                            keptDims: o
                        } = V(n), u = i;
                        if (u.length < n.length) {
                            const n = ["row", "col"];
                            return `\n      ${qC(rE(e,u),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${aE(n,o)});\n      }\n    `
                        }
                        if (e.shapeInfo.isUniform) return `\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${tE(e)}\n      }\n    `;
                        const l = a[0],
                            c = a[1],
                            h = eE(s);
                        if (1 === c) return t ? `\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;
                        if (1 === l) return t ? `\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `;
                        if (t) return `\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                        return `\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${s}, uv);\n  }\n`
                    }(e, t);
                case 3:
                    return function(e, t) {
                        const n = e.shapeInfo.logicalShape,
                            s = e.name,
                            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
                            a = n[1] * n[2],
                            i = n[2],
                            {
                                newShape: o,
                                keptDims: u
                            } = V(n),
                            l = o;
                        if (l.length < n.length) {
                            const n = ["row", "col", "depth"];
                            return `\n        ${qC(rE(e,l),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${aE(n,u)});\n        }\n      `
                        }
                        if (e.shapeInfo.isUniform) return `\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${tE(e)}\n      }\n    `;
                        const c = e.shapeInfo.texShape,
                            h = c[0],
                            p = c[1],
                            d = e.shapeInfo.flatOffset;
                        if (p === a && null == d) return t ? `\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${h}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `;
                        if (p === i && null == d) return t ? `\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;
                        const f = eE(s);
                        if (t) return `\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * ${a} + col * ${i} + depth + ${f};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `;
                        return `\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${p}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `
                    }(e, t);
                case 4:
                    return function(e, t) {
                        const n = e.shapeInfo.logicalShape,
                            s = e.name,
                            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
                            a = n[3],
                            i = n[2] * a,
                            o = n[1] * i,
                            {
                                newShape: u,
                                keptDims: l
                            } = V(n);
                        if (u.length < n.length) {
                            const n = ["row", "col", "depth", "depth2"];
                            return `\n      ${qC(rE(e,u),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${aE(n,l)});\n      }\n    `
                        }
                        if (e.shapeInfo.isUniform) return `\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${tE(e)}\n      }\n    `;
                        const c = e.shapeInfo.flatOffset,
                            h = e.shapeInfo.texShape,
                            p = h[0],
                            d = h[1],
                            f = `int stride2 = ${s}Shape[3];`,
                            m = `int stride1 = ${s}Shape[2] * stride2;`,
                            g = `int stride0 = ${s}Shape[1] * stride1;`;
                        if (d === o && null == c) return t ? `\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${p}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                        if (d === a && null == c) return t ? `\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    ` : `\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${p}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;
                        const y = eE(s);
                        if (t) return `\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});\n      return sampleTexture(${s}, uv);\n    }\n  `;
                        return `\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${d}, index + ${y});\n      return sampleTexture(${s}, uv);\n    }\n  `
                    }(e, t);
                case 5:
                    return function(e) {
                        const t = e.shapeInfo.logicalShape,
                            n = e.name,
                            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                            r = t[4],
                            a = t[3] * r,
                            i = t[2] * a,
                            o = t[1] * i,
                            {
                                newShape: u,
                                keptDims: l
                            } = V(t);
                        if (u.length < t.length) {
                            const t = ["row", "col", "depth", "depth2", "depth3"];
                            return `\n      ${qC(rE(e,u))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${aE(t,l)});\n      }\n    `
                        }
                        if (e.shapeInfo.isUniform) return `\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${r})) +\n          depth3;\n        ${tE(e)}\n      }\n    `;
                        const c = e.shapeInfo.flatOffset,
                            h = e.shapeInfo.texShape,
                            p = h[0],
                            d = h[1];
                        if (d === o && null == c) return `\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;
                        if (d === r && null == c) return `\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;
                        const f = eE(n);
                        return `\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${r} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${p}, ${d}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `
                    }(e);
                case 6:
                    return function(e) {
                        const t = e.shapeInfo.logicalShape,
                            n = e.name,
                            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                            {
                                newShape: r,
                                keptDims: a
                            } = V(t);
                        if (r.length < t.length) {
                            const t = ["row", "col", "depth", "depth2", "depth3", "depth4"];
                            return `\n      ${qC(rE(e,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${aE(t,a)});\n      }\n    `
                        }
                        const i = t[5],
                            o = t[4] * i,
                            u = t[3] * o,
                            l = t[2] * u,
                            c = t[1] * l;
                        if (e.shapeInfo.isUniform) return `\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${tE(e)}\n      }\n    `;
                        const h = e.shapeInfo.flatOffset,
                            p = e.shapeInfo.texShape,
                            d = p[0],
                            f = p[1];
                        if (f === c && null == h) return `\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;
                        if (f === i && null == h) return `\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;
                        const m = eE(n);
                        return `\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${d}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `
                    }(e);
                default:
                    throw new Error(`${n.length}-D input sampling is not yet supported`)
            }
        }

        function KC(e, t) {
            switch (e.shapeInfo.logicalShape.length) {
                case 0:
                    return function(e) {
                        const t = e.name,
                            n = "get" + t.charAt(0).toUpperCase() + t.slice(1),
                            s = BC();
                        return `\n    vec4 ${n}() {\n      return ${s.texture2D}(${t}, halfCR);\n    }\n  `
                    }(e);
                case 1:
                    return function(e, t) {
                        const n = e.name,
                            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                            r = e.shapeInfo.texShape,
                            a = BC();
                        if (t) return `\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;
                        const i = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)];
                        return `\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `
                    }(e, t);
                case 2:
                    return function(e, t) {
                        const n = e.shapeInfo.logicalShape,
                            s = e.name,
                            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
                            a = e.shapeInfo.texShape,
                            i = a[0],
                            o = a[1],
                            u = BC();
                        if (null != a && M(n, a)) return t ? `\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${u.texture2D}(${s}, uv);\n      }\n    ` : `\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${u.texture2D}(${s}, uv);\n      }\n    `;
                        if (t) return `\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${s}, uv);\n    }\n  `;
                        const l = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)],
                            c = Math.ceil(n[1] / 2);
                        return `\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${s}, uv);\n    }\n  `
                    }(e, t);
                case 3:
                    return function(e, t) {
                        const n = e.shapeInfo.logicalShape,
                            s = e.name,
                            r = "get" + s.charAt(0).toUpperCase() + s.slice(1),
                            a = e.shapeInfo.texShape,
                            i = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
                        if (1 === n[0]) {
                            const s = [1, 2],
                                a = ["b", "row", "col"];
                            return `\n        ${KC(rE(e,n.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${aE(a,s)});\n        }\n      `
                        }
                        const o = BC();
                        if (t) return `\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${s}, uv);\n    }\n  `;
                        const u = i[0],
                            l = i[1],
                            c = Math.ceil(n[2] / 2),
                            h = c * Math.ceil(n[1] / 2);
                        return `\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${h}, ${c}, b, row, col);\n      return ${o.texture2D}(${s}, uv);\n    }\n  `
                    }(e, t);
                default:
                    return function(e, t) {
                        const n = e.name,
                            s = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                            r = BC();
                        if (t) return `\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;
                        const a = e.shapeInfo.logicalShape,
                            i = a.length,
                            o = e.shapeInfo.texShape,
                            u = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],
                            l = u[0],
                            c = u[1],
                            h = Math.ceil(a[i - 1] / 2);
                        let p = h * Math.ceil(a[i - 2] / 2),
                            d = "int b, int row, int col",
                            f = `b * ${p} + (row / 2) * ${h} + (col / 2)`;
                        for (let e = 2; e < i - 1; e++) d = `int b${e}, ` + d, p *= a[i - e - 1], f = `b${e} * ${p} + ` + f;
                        return `\n    vec4 ${s}(${d}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `
                    }(e, t)
            }
        }
        const XC = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
            YC = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
            JC = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
            ZC = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

        function QC() {
            return "\n    int getOutputCoords() {\n      return 0;\n    }\n  "
        }

        function eE(e) {
            return `offset${e}`
        }

        function tE(e) {
            const t = e.name,
                n = O(e.shapeInfo.logicalShape);
            return n < 2 ? `return ${t};` : `\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `
        }

        function nE(e) {
            if (e <= 1) return "int";
            if (2 === e) return "ivec2";
            if (3 === e) return "ivec3";
            if (4 === e) return "ivec4";
            if (5 === e) return "ivec5";
            if (6 === e) return "ivec6";
            throw Error(`GPU for rank ${e} is not yet supported`)
        }

        function sE(e, t, n) {
            const {
                newShape: s,
                keptDims: r
            } = V(t), a = t.length, i = e && 3 === a && 1 === t[0], o = i ? t.slice(1) : s, u = !e && a > 1 && !M(t, n) && s.length < a || i;
            return {
                useSqueezeShape: u,
                uniformShape: u ? o : t,
                keptDims: r
            }
        }

        function rE(e, t) {
            const n = JSON.parse(JSON.stringify(e));
            return n.shapeInfo.logicalShape = t, n
        }

        function aE(e, t) {
            return t.map((t => e[t])).join(", ")
        }

        function iE(e, t, n, s) {
            const r = n.map(((e, n) => {
                    const s = {
                        logicalShape: e.shape,
                        texShape: e.isUniform ? null : e.texData.texShape,
                        isUniform: e.isUniform,
                        isPacked: !e.isUniform && e.texData.isPacked,
                        flatOffset: null
                    };
                    return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (s.flatOffset = e.texData.slice.flatOffset), {
                        name: t.variableNames[n],
                        shapeInfo: s
                    }
                })),
                a = r.map((e => e.shapeInfo)),
                i = {
                    logicalShape: s.shape,
                    texShape: s.texData.texShape,
                    isUniform: !1,
                    isPacked: s.texData.isPacked,
                    flatOffset: null
                },
                o = jC(r, i, t),
                u = function(e, t) {
                    const n = NC(e, (() => e.createShader(e.FRAGMENT_SHADER)), "Unable to create fragment WebGLShader.");
                    if (dC(e, (() => e.shaderSource(n, t))), dC(e, (() => e.compileShader(n))), de().get("ENGINE_COMPILE_ONLY")) return n;
                    if (!1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw yC(t, e.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
                    return n
                }(e.gl, o),
                l = e.createProgram(u);
            return de().get("ENGINE_COMPILE_ONLY") ? {
                program: t,
                fragmentShader: u,
                source: o,
                webGLProgram: l,
                inShapeInfos: a,
                outShapeInfo: i,
                uniformLocations: null,
                customUniformLocations: null,
                infLoc: null,
                nanLoc: null,
                inShapesLocations: null,
                inTexShapesLocations: null,
                outShapeLocation: null,
                outShapeStridesLocation: null,
                outTexShapeLocation: null
            } : Object.assign({
                program: t,
                fragmentShader: u,
                source: o,
                webGLProgram: l,
                inShapeInfos: a,
                outShapeInfo: i
            }, oE(e, t, l))
        }

        function oE(e, t, n) {
            const s = {},
                r = {},
                a = {},
                i = [];
            let o, u, l, c = null,
                h = null;
            h = e.getUniformLocation(n, "NAN", !1), 1 === de().getNumber("WEBGL_VERSION") && (c = e.getUniformLocation(n, "INFINITY", !1));
            const p = !1;
            for (let i = 0; i < t.variableNames.length; i++) {
                const o = t.variableNames[i];
                s[o] = e.getUniformLocation(n, o, p), s[`offset${o}`] = e.getUniformLocation(n, `offset${o}`, p), t.enableShapeUniforms && (r[`${o}Shape`] = e.getUniformLocation(n, `${o}Shape`, p), a[`${o}TexShape`] = e.getUniformLocation(n, `${o}TexShape`, p))
            }
            return t.enableShapeUniforms && (o = e.getUniformLocation(n, "outShape", p), l = e.getUniformLocation(n, "outShapeStrides", p), u = e.getUniformLocation(n, "outTexShape", p)), t.customUniforms && t.customUniforms.forEach(((t, s) => {
                i[s] = e.getUniformLocation(n, t.name, p)
            })), {
                uniformLocations: s,
                customUniformLocations: i,
                infLoc: c,
                nanLoc: h,
                inShapesLocations: r,
                inTexShapesLocations: a,
                outShapeLocation: o,
                outShapeStridesLocation: l,
                outTexShapeLocation: u
            }
        }

        function uE(e, t) {
            if (e.length !== t.length) throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);
            e.forEach(((e, n) => {
                const s = e.logicalShape,
                    r = t[n],
                    a = r.shape;
                if (!M(s, a)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);
                if (e.isUniform && r.isUniform) return;
                const i = e.texShape,
                    o = r.isUniform ? null : r.texData.texShape;
                if (!M(i, o)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)
            }))
        }

        function lE(e) {
            return de().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4
        }
        class cE {
            constructor(e) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = iC.DENSE, this.customUniforms = [{
                    name: "texShape",
                    type: "ivec2"
                }];
                const t = BC();
                this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length), this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?UC(["r","c","d"],e):PC(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `
            }
        }
        class hE {
            constructor(e) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = iC.DENSE, this.customUniforms = [{
                    name: "texShape",
                    type: "ivec2"
                }];
                const t = BC();
                this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length), this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?UC(["r","c","d"],e):PC(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `
            }
        }
        class pE {
            constructor(e) {
                this.variableNames = ["A"], this.outTexUsage = oC.DOWNLOAD;
                const t = BC();
                this.outputShape = e, this.userCode = `\n      ${GC}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `
            }
        }
        class dE {
            constructor(e) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = oC.DOWNLOAD;
                const t = BC();
                this.outputShape = e, this.userCode = `\n      ${GC}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `
            }
        }
        class fE {
            constructor(e, t = !1) {
                this.variableNames = ["A"], this.customUniforms = [{
                    name: "texShape",
                    type: "ivec2"
                }];
                const n = BC();
                this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length);
                let s = "result";
                t && (s = "floor(result * 255. + 0.5)"), this.userCode = `\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":VC(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `
            }
        }
        class mE {
            constructor(e, t = !1) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.customUniforms = [{
                    name: "texShape",
                    type: "ivec2"
                }];
                const n = BC();
                this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length);
                let s = "",
                    r = "result";
                t && (r = "floor(result * 255. + 0.5)");
                for (let t = 0; t <= 1; t++)
                    for (let r = 0; r <= 1; r++) {
                        const a = 2 * t + r;
                        s += `\n          localCoords = coords;\n          if(localCoords[2] + ${r} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${r};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `
                    }
                this.userCode = `\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":VC(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${n.output} = ${r};\n        }\n    `
            }
        }

        function gE(e) {
            const t = BC();
            return function(e, t) {
                const n = NC(e, (() => e.createShader(e.VERTEX_SHADER)), "Unable to create vertex WebGLShader.");
                if (dC(e, (() => e.shaderSource(n, t))), dC(e, (() => e.compileShader(n))), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
                return n
            }(e, `${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)
        }

        function yE(e) {
            return function(e, t) {
                const n = NC(e, (() => e.createBuffer()), "Unable to create WebGLBuffer");
                return dC(e, (() => e.bindBuffer(e.ARRAY_BUFFER, n))), dC(e, (() => e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW))), n
            }(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
        }

        function bE(e) {
            return function(e, t) {
                const n = NC(e, (() => e.createBuffer()), "Unable to create WebGLBuffer");
                return dC(e, (() => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n))), dC(e, (() => e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW))), n
            }(e, new Uint16Array([0, 1, 2, 2, 1, 3]))
        }

        function xE(e, t, n, s, r, a) {
            ! function(e, t) {
                const n = de().getNumber("WEBGL_MAX_TEXTURE_SIZE");
                if (e <= 0 || t <= 0) throw new Error(`Requested texture size [${e}x${t}] is invalid.`);
                if (e > n || t > n) throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)
            }(t, n);
            const i = function(e) {
                    return NC(e, (() => e.createTexture()), "Unable to create WebGLTexture.")
                }(e),
                o = e.TEXTURE_2D;
            return dC(e, (() => e.bindTexture(o, i))), dC(e, (() => e.texParameteri(o, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE))), dC(e, (() => e.texParameteri(o, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE))), dC(e, (() => e.texParameteri(o, e.TEXTURE_MIN_FILTER, e.NEAREST))), dC(e, (() => e.texParameteri(o, e.TEXTURE_MAG_FILTER, e.NEAREST))), 1 === de().getNumber("WEBGL_VERSION") ? dC(e, (() => e.texImage2D(o, 0, s, t, n, 0, r, a, null))) : dC(e, (() => e.texStorage2D(o, 1, s, t, n))), dC(e, (() => e.bindTexture(e.TEXTURE_2D, null))), {
                texture: i,
                texShape: [n, t]
            }
        }

        function wE(e) {
            return e.internalFormatFloat
        }

        function kE(e) {
            return e.internalFormatHalfFloat
        }

        function vE(e) {
            return e.downloadTextureFormat
        }

        function IE(e) {
            return e.internalFormatPackedFloat
        }

        function NE(e) {
            return e.internalFormatPackedHalfFloat
        }

        function SE(e, t, n, s, r, a, i, o) {
            const u = e,
                l = new Float32Array(function(e, t) {
                    const [n, s] = hC(e, t);
                    return n * s * 4
                }(a, i));
            return u.bindBuffer(u.PIXEL_PACK_BUFFER, t), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), l
        }
        class TE {
            constructor(e) {
                this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
                const t = de().getNumber("WEBGL_VERSION");
                null != e ? (this.gl = e, function(e, t) {
                    sC[e] = t
                }(t, e)) : this.gl = aC(t);
                let n = "WEBGL_color_buffer_float";
                const s = "EXT_color_buffer_half_float";
                if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), 1 === de().getNumber("WEBGL_VERSION")) {
                    const e = "OES_texture_float",
                        t = "OES_texture_half_float";
                    if (this.textureFloatExtension = mC(this.gl, e), DC(this.gl, t)) this.textureHalfFloatExtension = mC(this.gl, t);
                    else if (de().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
                    if (this.colorBufferFloatExtension = this.gl.getExtension(n), DC(this.gl, s)) this.colorBufferHalfFloatExtension = mC(this.gl, s);
                    else if (de().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
                } else if (n = "EXT_color_buffer_float", DC(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);
                else {
                    if (!DC(this.gl, s)) throw new Error("GL context does not support color renderable floats");
                    this.colorBufferHalfFloatExtension = this.gl.getExtension(s)
                }
                this.vertexBuffer = yE(this.gl), this.indexBuffer = bE(this.gl), this.framebuffer = function(e) {
                    return NC(e, (() => e.createFramebuffer()), "Unable to create WebGLFramebuffer.")
                }(this.gl), this.textureConfig = pC(this.gl, this.textureHalfFloatExtension)
            }
            get debug() {
                return de().getBool("DEBUG")
            }
            dispose() {
                if (this.disposed) return;
                null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
                const e = this.gl;
                dC(e, (() => e.finish())), dC(e, (() => e.bindFramebuffer(e.FRAMEBUFFER, null))), dC(e, (() => e.deleteFramebuffer(this.framebuffer))), dC(e, (() => e.bindBuffer(e.ARRAY_BUFFER, null))), dC(e, (() => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null))), dC(e, (() => e.deleteBuffer(this.indexBuffer))), this.disposed = !0
            }
            createFloat32MatrixTexture(e, t) {
                return this.throwIfDisposed(),
                    function(e, t, n, s) {
                        const [r, a] = lC(t, n);
                        return xE(e, r, a, wE(s), s.textureFormatFloat, e.FLOAT)
                    }(this.gl, e, t, this.textureConfig)
            }
            createFloat16MatrixTexture(e, t) {
                return this.throwIfDisposed(),
                    function(e, t, n, s) {
                        const [r, a] = lC(t, n);
                        return xE(e, r, a, kE(s), s.textureFormatFloat, s.textureTypeHalfFloat)
                    }(this.gl, e, t, this.textureConfig)
            }
            createUnsignedBytesMatrixTexture(e, t) {
                return this.throwIfDisposed(),
                    function(e, t, n, s) {
                        const [r, a] = lC(t, n);
                        return xE(e, r, a, vE(s), e.RGBA, e.UNSIGNED_BYTE)
                    }(this.gl, e, t, this.textureConfig)
            }
            uploadPixelDataToTexture(e, t) {
                this.throwIfDisposed(),
                    function(e, t, n) {
                        dC(e, (() => e.bindTexture(e.TEXTURE_2D, t))), n.data instanceof Uint8Array ? 2 === de().getNumber("WEBGL_VERSION") ? dC(e, (() => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n.width, n.height, e.RGBA, e.UNSIGNED_BYTE, n.data))) : dC(e, (() => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data))) : 2 === de().getNumber("WEBGL_VERSION") ? dC(e, (() => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, e.RGBA, e.UNSIGNED_BYTE, n))) : dC(e, (() => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n))), dC(e, (() => e.bindTexture(e.TEXTURE_2D, null)))
                    }(this.gl, e, t)
            }
            uploadDenseMatrixToTexture(e, t, n, s) {
                this.throwIfDisposed(),
                    function(e, t, n, s, r, a) {
                        let i, o, u;
                        dC(e, (() => e.bindTexture(e.TEXTURE_2D, t))), r instanceof Uint8Array ? (i = new Uint8Array(n * s * 4), o = e.UNSIGNED_BYTE, u = e.RGBA) : (i = new Float32Array(n * s * 4), o = e.FLOAT, u = a.internalFormatPackedFloat), i.set(r), 2 === de().getNumber("WEBGL_VERSION") ? dC(e, (() => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n, s, e.RGBA, o, i))) : dC(e, (() => e.texImage2D(e.TEXTURE_2D, 0, u, n, s, 0, e.RGBA, o, i))), dC(e, (() => e.bindTexture(e.TEXTURE_2D, null)))
                    }(this.gl, e, t, n, s, this.textureConfig)
            }
            createFloat16PackedMatrixTexture(e, t) {
                return this.throwIfDisposed(),
                    function(e, t, n, s) {
                        const [r, a] = hC(t, n);
                        return xE(e, r, a, NE(s), e.RGBA, s.textureTypeHalfFloat)
                    }(this.gl, e, t, this.textureConfig)
            }
            createPackedMatrixTexture(e, t) {
                return this.throwIfDisposed(),
                    function(e, t, n, s) {
                        const [r, a] = hC(t, n);
                        return xE(e, r, a, IE(s), e.RGBA, e.FLOAT)
                    }(this.gl, e, t, this.textureConfig)
            }
            deleteMatrixTexture(e) {
                this.throwIfDisposed(), this.outputTexture === e && (vC(this.gl, this.framebuffer), this.outputTexture = null), dC(this.gl, (() => this.gl.deleteTexture(e)))
            }
            downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n) {
                return this.downloadMatrixDriver(e, (() => function(e, t, n, s) {
                    const [r, a] = lC(t, n), i = new Uint8Array(t * n * 4);
                    return dC(e, (() => e.readPixels(0, 0, r, a, s.downloadTextureFormat, e.UNSIGNED_BYTE, i))), new Float32Array(i.buffer)
                }(this.gl, t, n, this.textureConfig)))
            }
            downloadPackedMatrixFromBuffer(e, t, n, s, r, a) {
                return SE(this.gl, e, 0, 0, 0, r, a, this.textureConfig)
            }
            downloadFloat32MatrixFromBuffer(e, t) {
                return function(e, t, n) {
                    const s = e,
                        r = new Float32Array(n);
                    return s.bindBuffer(s.PIXEL_PACK_BUFFER, t), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, r), s.bindBuffer(s.PIXEL_PACK_BUFFER, null), r
                }(this.gl, e, t)
            }
            createBufferFromTexture(e, t, n) {
                this.bindTextureToFrameBuffer(e);
                const s = function(e, t, n) {
                    const s = e.createBuffer();
                    dC(e, (() => e.bindBuffer(e.PIXEL_PACK_BUFFER, s)));
                    const r = 16 * t * n;
                    return dC(e, (() => e.bufferData(e.PIXEL_PACK_BUFFER, r, e.STREAM_READ))), dC(e, (() => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0))), dC(e, (() => e.bindBuffer(e.PIXEL_PACK_BUFFER, null))), s
                }(this.gl, t, n, this.textureConfig);
                return this.unbindTextureToFrameBuffer(), s
            }
            createAndWaitForFence() {
                const e = this.createFence(this.gl);
                return this.pollFence(e)
            }
            createFence(e) {
                let t, n;
                if (de().getBool("WEBGL_FENCE_API_ENABLED")) {
                    const s = e,
                        r = s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    e.flush(), n = () => {
                        const e = s.clientWaitSync(r, 0, 0);
                        return e === s.ALREADY_SIGNALED || e === s.CONDITION_SATISFIED
                    }, t = r
                } else de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n = () => this.isQueryAvailable(t, de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n = () => !0;
                return {
                    query: t,
                    isFencePassed: n
                }
            }
            downloadMatrixFromPackedTexture(e, t, n) {
                return this.downloadMatrixDriver(e, (() => function(e, t, n) {
                    const s = new Float32Array(t * n * 4);
                    return dC(e, (() => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, s))), s
                }(this.gl, t, n)))
            }
            createProgram(e) {
                this.throwIfDisposed();
                const t = this.gl;
                null == this.vertexShader && (this.vertexShader = gE(t));
                const n = function(e) {
                    return NC(e, (() => e.createProgram()), "Unable to create WebGLProgram.")
                }(t);
                return dC(t, (() => t.attachShader(n, this.vertexShader))), dC(t, (() => t.attachShader(n, e))),
                    function(e, t) {
                        if (dC(e, (() => e.linkProgram(t))), !de().get("ENGINE_COMPILE_ONLY") && !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.")
                    }(t, n), this.debug && bC(t, n), this.vertexAttrsAreBound || (this.setProgram(n), this.vertexAttrsAreBound = function(e, t, n) {
                        return dC(e, (() => e.bindBuffer(e.ARRAY_BUFFER, n))), xC(e, t, "clipSpacePos", n, 3, 20, 0) && xC(e, t, "uv", n, 2, 20, 12)
                    }(t, this.program, this.vertexBuffer)), n
            }
            deleteProgram(e) {
                this.throwIfDisposed(), e === this.program && (this.program = null), null != e && dC(this.gl, (() => this.gl.deleteProgram(e)))
            }
            setProgram(e) {
                this.throwIfDisposed(), this.program = e, null != this.program && this.debug && bC(this.gl, this.program), dC(this.gl, (() => this.gl.useProgram(e)))
            }
            getUniformLocation(e, t, n = !0) {
                return this.throwIfDisposed(), n ? function(e, t, n) {
                    return NC(e, (() => e.getUniformLocation(t, n)), 'uniform "' + n + '" not present in program.')
                }(this.gl, e, t) : function(e, t, n) {
                    return e.getUniformLocation(t, n)
                }(this.gl, e, t)
            }
            getAttributeLocation(e, t) {
                return this.throwIfDisposed(), dC(this.gl, (() => this.gl.getAttribLocation(e, t)))
            }
            getUniformLocationNoThrow(e, t) {
                return this.throwIfDisposed(), this.gl.getUniformLocation(e, t)
            }
            setInputMatrixTexture(e, t, n) {
                this.throwIfDisposed(), this.throwIfNoProgram(), wC(this.gl, e, t, n)
            }
            setOutputMatrixTexture(e, t, n) {
                this.setOutputMatrixTextureDriver(e, n, t)
            }
            setOutputPackedMatrixTexture(e, t, n) {
                this.throwIfDisposed();
                const [s, r] = hC(t, n);
                this.setOutputMatrixTextureDriver(e, s, r)
            }
            setOutputMatrixWriteRegion(e, t, n, s) {
                this.setOutputMatrixWriteRegionDriver(n, e, s, t)
            }
            setOutputPackedMatrixWriteRegion(e, t, n, s) {
                throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
            }
            debugValidate() {
                null != this.program && bC(this.gl, this.program), IC(this.gl)
            }
            executeProgram() {
                this.throwIfDisposed(), this.throwIfNoProgram();
                const e = this.gl;
                this.debug && this.debugValidate(), dC(e, (() => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0)))
            }
            blockUntilAllProgramsCompleted() {
                this.throwIfDisposed(), dC(this.gl, (() => this.gl.finish()))
            }
            getQueryTimerExtension() {
                return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = mC(this.gl, 2 === de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
            }
            getQueryTimerExtensionWebGL2() {
                return this.getQueryTimerExtension()
            }
            getQueryTimerExtensionWebGL1() {
                return this.getQueryTimerExtension()
            }
            beginQuery() {
                if (2 === de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                    const e = this.gl,
                        t = this.getQueryTimerExtensionWebGL2(),
                        n = e.createQuery();
                    return e.beginQuery(t.TIME_ELAPSED_EXT, n), n
                }
                const e = this.getQueryTimerExtensionWebGL1(),
                    t = e.createQueryEXT();
                return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t
            }
            endQuery() {
                if (2 === de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                    const e = this.gl,
                        t = this.getQueryTimerExtensionWebGL2();
                    return void e.endQuery(t.TIME_ELAPSED_EXT)
                }
                const e = this.getQueryTimerExtensionWebGL1();
                e.endQueryEXT(e.TIME_ELAPSED_EXT)
            }
            async waitForQueryAndGetTime(e) {
                return await P((() => this.disposed || this.isQueryAvailable(e, de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))), this.getQueryTime(e, de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
            }
            getQueryTime(e, t) {
                if (0 === t) return null;
                if (2 === t) {
                    const t = this.gl;
                    return t.getQueryParameter(e, t.QUERY_RESULT) / 1e6
                } {
                    const t = this.getQueryTimerExtensionWebGL1();
                    return t.getQueryObjectEXT(e, t.QUERY_RESULT_EXT) / 1e6
                }
            }
            isQueryAvailable(e, t) {
                if (0 === t) return !0;
                if (2 === t) {
                    const t = this.gl,
                        n = this.getQueryTimerExtensionWebGL2(),
                        s = t.getQueryParameter(e, t.QUERY_RESULT_AVAILABLE);
                    return null == this.disjoint && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)), s && !this.disjoint
                } {
                    const t = this.getQueryTimerExtensionWebGL1(),
                        n = t.getQueryObjectEXT(e, t.QUERY_RESULT_AVAILABLE_EXT);
                    return null == this.disjoint && (this.disjoint = this.gl.getParameter(t.GPU_DISJOINT_EXT)), n && !this.disjoint
                }
            }
            pollFence(e) {
                return new Promise((t => {
                    this.addItemToPoll((() => e.isFencePassed()), (() => t()))
                }))
            }
            pollItems() {
                const e = function(e) {
                    let t = 0;
                    for (; t < e.length; ++t) {
                        if (!e[t]()) break
                    }
                    return t - 1
                }(this.itemsToPoll.map((e => e.isDoneFn)));
                for (let t = 0; t <= e; ++t) {
                    const {
                        resolveFn: e
                    } = this.itemsToPoll[t];
                    e()
                }
                this.itemsToPoll = this.itemsToPoll.slice(e + 1)
            }
            addItemToPoll(e, t) {
                this.itemsToPoll.push({
                    isDoneFn: e,
                    resolveFn: t
                }), this.itemsToPoll.length > 1 || P((() => (this.pollItems(), 0 === this.itemsToPoll.length)))
            }
            bindTextureToFrameBuffer(e) {
                this.throwIfDisposed(), kC(this.gl, e, this.framebuffer), this.debug && IC(this.gl)
            }
            unbindTextureToFrameBuffer() {
                null != this.outputTexture ? (kC(this.gl, this.outputTexture, this.framebuffer), this.debug && IC(this.gl)) : vC(this.gl, this.framebuffer)
            }
            downloadMatrixDriver(e, t) {
                this.bindTextureToFrameBuffer(e);
                const n = t();
                return this.unbindTextureToFrameBuffer(), n
            }
            setOutputMatrixTextureDriver(e, t, n) {
                this.throwIfDisposed();
                const s = this.gl;
                kC(s, e, this.framebuffer), this.debug && IC(s), this.outputTexture = e, dC(s, (() => s.viewport(0, 0, t, n))), dC(s, (() => s.scissor(0, 0, t, n)))
            }
            setOutputMatrixWriteRegionDriver(e, t, n, s) {
                this.throwIfDisposed(), dC(this.gl, (() => this.gl.scissor(e, t, n, s)))
            }
            throwIfDisposed() {
                if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
            }
            throwIfNoProgram() {
                if (null == this.program) throw new Error("No GPU program is currently set.")
            }
        }
        const {
            mx: $E,
            XI: CE,
            Nk: EE,
            YG: AE,
            hH: RE,
            z3: FE,
            sG: DE,
            uM: _E,
            vS: OE,
            qB: ME,
            GG: LE,
            rq: zE,
            lg: BE,
            WR: PE,
            cu: UE,
            GE: WE,
            px: VE,
            jC: GE,
            He: HE,
            hE: jE,
            BF: qE,
            Dk: KE,
            cl: XE,
            _B: YE,
            qy: JE,
            Zy: ZE,
            bu: QE,
            zv: eA,
            dH: tA,
            HS: nA,
            yH: sA,
            l3: rA,
            z9: aA,
            x6: iA,
            eW: oA,
            GK: uA,
            SP: lA,
            f6: cA,
            dl: hA,
            Dw: pA,
            xT: dA,
            _X: fA,
            wz: mA
        } = I;

        function gA(e, t) {
            return ["x", "y", "z", "w", "u", "v"].slice(0, t).map((t => `${e}.${t}`))
        }

        function yA(e, t) {
            return 1 === t ? [e] : gA(e, t)
        }
        class bA {
            constructor(e) {
                if (this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.enableShapeUniforms = lE(this.outputShape.length), 0 === this.rank) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
                else {
                    const e = yA("rc", this.rank),
                        t = nE(this.rank),
                        n = this.getOutOfBoundsCondition(e),
                        s = this.getSetup(e),
                        r = this.getOutput(e);
                    this.userCode = `\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${r}));\n          }\n        }\n      `
                }
            }
            getSourceCoordsArr(e) {
                const t = [];
                for (let n = 0; n <= 1; n++)
                    for (let s = 0; s <= 1; s++) {
                        let r = `${0===n?"r":"rp1"}, ${0===s?"c":"cp1"}`;
                        for (let t = 2; t < this.rank; t++) r = `${e[e.length-1-t]},` + r;
                        t.push(r)
                    }
                return t
            }
            getOutOfBoundsCondition(e) {
                if (1 === this.rank) return `rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;
                let t = "";
                for (let n = this.rank - 2; n < this.rank; n++) t += `${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`, n < this.rank - 1 && (t += "||");
                return t
            }
            getSetup(e) {
                if (1 === this.rank) return "";
                const t = e.slice(-2),
                    n = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1],
                    s = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
                return `\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${s};\n    `
            }
            getOutput(e) {
                const t = this.getSourceCoordsArr(e);
                if (1 === this.rank) {
                    return `getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`
                }
                return `getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`
            }
        }
        class xA {
            constructor(e, t) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                    name: "inputShape",
                    type: "ivec3"
                }], this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length);
                let n = "";
                for (let e = 0; e < 4; e++) {
                    let t = "thisRC = rc;";
                    e % 2 == 1 && (t += "thisRC.z += 1;"), e > 1 && (t += "thisRC.y += 1;"), n += `\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `
                }
                var s, r;
                this.userCode = `\n      ${s=t,r=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${r?WC(["r","c","d"],"inputShape"):PC(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":VC(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `
            }
        }
        class wA {
            constructor(e) {
                this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {}
            }
            acquireTexture(e, t, n) {
                const s = vA(t, n),
                    r = IA(e, s, n);
                r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
                const a = kA(e, s, this.gpgpu.gl, this.gpgpu.textureConfig, n);
                if (this.freeTextures[r].length > 0) {
                    this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= a, this.log();
                    const e = this.freeTextures[r].shift();
                    return this.usedTextures[r].push(e), e
                }
                let i;
                return s === uC.PACKED_2X2_FLOAT32 ? i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : s === uC.PACKED_2X2_FLOAT16 ? i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : s === uC.UNPACKED_FLOAT32 ? i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : s === uC.UNPACKED_FLOAT16 ? i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : s === uC.PACKED_4X1_UNSIGNED_BYTE && (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[r].push(i), this.numUsedTextures++, this._numBytesAllocated += a, this.log(), i
            }
            releaseTexture(e, t, n, s) {
                if (null == this.freeTextures) return;
                const r = vA(n, s),
                    a = IA(t, r, s);
                a in this.freeTextures || (this.freeTextures[a] = []);
                const i = kA(t, r, this.gpgpu.gl, this.gpgpu.textureConfig, s),
                    o = de().get("WEBGL_DELETE_TEXTURE_THRESHOLD"); - 1 !== o && this._numBytesAllocated > o ? (this.gpgpu.deleteMatrixTexture(e.texture), this._numBytesAllocated -= i) : (this.freeTextures[a].push(e), this.numFreeTextures++, this._numBytesFree += i), this.numUsedTextures--;
                const u = this.usedTextures[a],
                    l = u.indexOf(e);
                if (l < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
                u.splice(l, 1), this.log()
            }
            log() {
                if (!this.logEnabled) return;
                const e = this.numFreeTextures + this.numUsedTextures;
                console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${e})`);
                const t = this._numBytesFree / this._numBytesAllocated;
                console.log(`Bytes allocated: ${this._numBytesAllocated}`), console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)
            }
            get numBytesAllocated() {
                return this._numBytesAllocated
            }
            get numBytesFree() {
                return this._numBytesFree
            }
            getNumUsedTextures() {
                return this.numUsedTextures
            }
            getNumFreeTextures() {
                return this.numFreeTextures
            }
            dispose() {
                if (null != this.freeTextures) {
                    for (const e in this.freeTextures) this.freeTextures[e].forEach((e => {
                        this.gpgpu.deleteMatrixTexture(e.texture)
                    }));
                    for (const e in this.usedTextures) this.usedTextures[e].forEach((e => {
                        this.gpgpu.deleteMatrixTexture(e.texture)
                    }));
                    this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0
                }
            }
        }

        function kA(e, t, n, s, r) {
            const a = function(e, t) {
                switch (e) {
                    case uC.PACKED_2X2_FLOAT32:
                        return IE(t);
                    case uC.PACKED_2X2_FLOAT16:
                        return NE(t);
                    case uC.UNPACKED_FLOAT32:
                        return wE(t);
                    case uC.UNPACKED_FLOAT16:
                        return kE(t);
                    case uC.PACKED_4X1_UNSIGNED_BYTE:
                        return vE(t);
                    default:
                        throw new Error(`Unknown physical texture type ${e}`)
                }
            }(t, s);
            let i;
            if (r) {
                const [t, n] = hC(e[0], e[1]);
                i = t * n
            } else {
                const [t, n] = lC(e[0], e[1]);
                i = t * n
            }
            const o = function(e, t) {
                const n = e;
                if (t === n.R32F) return 4;
                if (t === n.R16F) return 2;
                if (t === n.RGBA32F) return 16;
                if (t === e.RGBA) return 16;
                if (t === n.RGBA16F) return 8;
                if (t === n.RGBA8) return 4;
                throw new Error(`Unknown internal format ${t}`)
            }(n, a);
            return i * o
        }

        function vA(e, t) {
            if (e === oC.UPLOAD) return uC.PACKED_2X2_FLOAT32;
            if (e === oC.RENDER || null == e) return function(e) {
                return de().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? uC.PACKED_2X2_FLOAT32 : uC.UNPACKED_FLOAT32 : e ? uC.PACKED_2X2_FLOAT16 : uC.UNPACKED_FLOAT16
            }(t);
            if (e === oC.DOWNLOAD || e === oC.PIXELS) return uC.PACKED_4X1_UNSIGNED_BYTE;
            throw new Error(`Unknown logical texture type ${e}`)
        }

        function IA(e, t, n) {
            return `${e[0]}_${e[1]}_${t}_${n}`
        }
        class NA {
            constructor(e, t) {
                this.variableNames = ["A"], this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length), this.userCode = `\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `
            }
        }
        const SA = "if (isnan(x)) return x;",
            TA = "return abs(x);";
        const $A = SA + "\n  return (x < 0.0) ? 0.0 : x;\n",
            CA = SA + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
            EA = "return x;";
        class AA {
            constructor(e, t) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length), this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `
            }
        }
        class RA {
            constructor(e) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length);
                const t = e.length,
                    n = yA("rc", t),
                    s = nE(t),
                    r = function(e, t) {
                        if (1 === e) return "rc";
                        let n = "";
                        for (let s = 0; s < e; s++) n += t[s], s < e - 1 && (n += ",");
                        return n
                    }(t, n),
                    a = n.slice(-2),
                    i = t <= 1 ? "rc" : `vec2(${a.join(",")})`;
                this.userCode = `\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `
            }
        }
        const FA = gh,
            DA = {};
        const _A = de().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
        class OA extends S {
            constructor(e) {
                if (super(), this.pendingRead = new WeakMap, this.pendingDisposal = new WeakSet, this.dataRefCount = new WeakMap, this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = !1, this.pendingDeletes = 0, this.disposed = !1, !de().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
                let t;
                if (null != e) {
                    if (e instanceof TE) t = e;
                    else {
                        const n = aC(de().getNumber("WEBGL_VERSION"), e);
                        t = new TE(n)
                    }
                    this.binaryCache = {}, this.gpgpuCreatedLocally = !1
                } else {
                    const e = aC(de().getNumber("WEBGL_VERSION"));
                    t = new TE(e), this.binaryCache = ((n = de().getNumber("WEBGL_VERSION")) in DA || (DA[n] = {}), DA[n]), this.gpgpuCreatedLocally = !0
                }
                var n;
                this.gpgpu = t, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new wA(this.gpgpu), this.numMBBeforeWarning = null == de().global.screen ? 1024 : de().global.screen.height * de().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, this.texData = new N(this, mi())
            }
            nextDataId() {
                return OA.nextDataId++
            }
            numDataIds() {
                return this.texData.numDataIds() - this.pendingDeletes
            }
            write(e, t, n) {
                if ((de().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || de().getBool("DEBUG")) && this.checkNumericalProblems(e), "complex64" === n && null != e) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                const s = {
                    id: this.nextDataId()
                };
                return this.texData.set(s, {
                    shape: t,
                    dtype: n,
                    values: e,
                    usage: oC.UPLOAD,
                    refCount: 1
                }), s
            }
            refCount(e) {
                if (this.texData.has(e)) {
                    return this.texData.get(e).refCount
                }
                return 0
            }
            incRef(e) {
                this.texData.get(e).refCount++
            }
            decRef(e) {
                if (this.texData.has(e)) {
                    this.texData.get(e).refCount--
                }
            }
            move(e, t, n, s, r) {
                if (de().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === s) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                this.texData.set(e, {
                    shape: n,
                    dtype: s,
                    values: t,
                    usage: oC.UPLOAD,
                    refCount: r
                })
            }
            disposeIntermediateTensorInfo(e) {
                this.disposeData(e.dataId)
            }
            readSync(e) {
                const t = this.texData.get(e),
                    {
                        values: n,
                        dtype: s,
                        complexTensorInfos: r,
                        slice: a,
                        shape: i,
                        isPacked: o
                    } = t;
                if (null != a) {
                    let t;
                    t = o ? new AA(i, EA) : new NA(i, EA);
                    const n = this.runWebGLProgram(t, [{
                            dataId: e,
                            shape: i,
                            dtype: s
                        }], s),
                        r = this.readSync(n.dataId);
                    return this.disposeIntermediateTensorInfo(n), r
                }
                if (null != n) return this.convertAndCacheOnCPU(e);
                if ("string" === s) return n;
                const u = null != this.activeTimers;
                let l, c;
                if (u && (l = Xs()), "complex64" === s) {
                    c = _c(this.readSync(r.real.dataId), this.readSync(r.imag.dataId))
                } else c = this.getValuesFromTexture(e);
                return u && (this.downloadWaitMs += Xs() - l), this.convertAndCacheOnCPU(e, c)
            }
            async read(e) {
                if (this.pendingRead.has(e)) {
                    const t = this.pendingRead.get(e);
                    return new Promise((e => t.push(e)))
                }
                const t = this.texData.get(e),
                    {
                        values: n,
                        shape: s,
                        slice: r,
                        dtype: a,
                        complexTensorInfos: i,
                        isPacked: o
                    } = t;
                if (null != r) {
                    let t;
                    t = o ? new AA(s, EA) : new NA(s, EA);
                    const n = this.runWebGLProgram(t, [{
                            dataId: e,
                            shape: s,
                            dtype: a
                        }], a),
                        r = this.read(n.dataId);
                    return this.disposeIntermediateTensorInfo(n), r
                }
                if (null != n) return this.convertAndCacheOnCPU(e);
                if (de().getBool("DEBUG") && !de().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === de().getNumber("WEBGL_VERSION")) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                let u, l, c = null;
                if ("complex64" !== a && de().get("WEBGL_BUFFER_SUPPORTED")) {
                    u = this.decode(e);
                    const t = this.texData.get(u.dataId);
                    c = this.gpgpu.createBufferFromTexture(t.texture.texture, ...cC(s))
                }
                if (this.pendingRead.set(e, []), "complex64" !== a && await this.gpgpu.createAndWaitForFence(), "complex64" === a) {
                    const e = await Promise.all([this.read(i.real.dataId), this.read(i.imag.dataId)]);
                    l = _c(e[0], e[1])
                } else if (null == c) l = this.getValuesFromTexture(e);
                else {
                    const e = O(s);
                    l = this.gpgpu.downloadFloat32MatrixFromBuffer(c, e)
                }
                if (null != u && this.disposeIntermediateTensorInfo(u), null != c) {
                    const e = this.gpgpu.gl;
                    dC(e, (() => e.deleteBuffer(c)))
                }
                const h = this.convertAndCacheOnCPU(e, l),
                    p = this.pendingRead.get(e);
                return this.pendingRead.delete(e), p.forEach((e => e(h))), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e) && mi().removeDataId(e, this), this.pendingDeletes--), h
            }
            readToGPU(e, t = {}) {
                const n = this.texData.get(e),
                    {
                        values: s,
                        shape: r,
                        slice: a,
                        dtype: i,
                        isPacked: o,
                        texture: u
                    } = n;
                if ("complex64" === i) throw new Error("Does not support reading texture for complex64 dtype.");
                if (null != a) {
                    let n;
                    n = o ? new AA(r, EA) : new NA(r, EA);
                    const s = this.runWebGLProgram(n, [{
                            dataId: e,
                            shape: r,
                            dtype: i
                        }], i),
                        a = this.readToGPU(s, t);
                    return this.disposeIntermediateTensorInfo(s), a
                }
                if (null == u) throw null != s ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
                const l = this.decode(e, t.customTexShape),
                    c = mi().makeTensorFromTensorInfo(l),
                    h = this.texData.get(l.dataId);
                return Object.assign({
                    tensorRef: c
                }, h.texture)
            }
            bufferSync(e) {
                const t = this.readSync(e.dataId);
                if ("string" === e.dtype) try {
                    const n = t.map((e => Js(e)));
                    return Aa(e.shape, e.dtype, n)
                } catch (e) {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
                return Aa(e.shape, e.dtype, t)
            }
            checkNumericalProblems(e) {
                if (null != e)
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        if (!fC(n)) {
                            if (de().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
                            throw Error(`The value ${n} cannot be represented on this device.`)
                        }
                    }
            }
            getValuesFromTexture(e) {
                const {
                    shape: t,
                    dtype: n,
                    isPacked: s
                } = this.texData.get(e), r = O(t);
                if (de().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
                    const n = this.decode(e),
                        s = this.texData.get(n.dataId),
                        a = this.gpgpu.downloadMatrixFromPackedTexture(s.texture.texture, ...cC(t)).subarray(0, r);
                    return this.disposeIntermediateTensorInfo(n), a
                }
                const a = de().getBool("WEBGL_PACK") && !0 === s,
                    i = a ? CC(t) : t,
                    o = a ? new dE(i) : new pE(i),
                    u = this.runWebGLProgram(o, [{
                        shape: i,
                        dtype: n,
                        dataId: e
                    }], "float32"),
                    l = this.texData.get(u.dataId),
                    c = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture, l.texShape[0], l.texShape[1]).subarray(0, r);
                return this.disposeIntermediateTensorInfo(u), c
            }
            timerAvailable() {
                return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0
            }
            time(e) {
                const t = this.activeTimers,
                    n = [];
                let s = !1;
                null == this.programTimersStack ? (this.programTimersStack = n, s = !0) : this.activeTimers.push(n), this.activeTimers = n, e();
                const r = _(this.activeTimers.map((e => e.query))).filter((e => null != e)),
                    a = _(this.activeTimers.map((e => e.name))).filter((e => null != e));
                this.activeTimers = t, s && (this.programTimersStack = null);
                const i = {
                    uploadWaitMs: this.uploadWaitMs,
                    downloadWaitMs: this.downloadWaitMs,
                    kernelMs: null,
                    wallMs: null
                };
                return (async () => {
                    if (de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
                        const e = await Promise.all(r);
                        i.kernelMs = function(e) {
                            let t = 0;
                            for (let n = 0; n < e.length; n++) t += e[n];
                            return t
                        }(e), i.getExtraProfileInfo = () => e.map(((e, t) => ({
                            name: a[t],
                            ms: e
                        }))).map((e => `${e.name}: ${e.ms}`)).join(", ")
                    } else i.kernelMs = {
                        error: "WebGL query timers are not supported in this environment."
                    };
                    return this.uploadWaitMs = 0, this.downloadWaitMs = 0, i
                })()
            }
            memory() {
                return {
                    unreliable: !1,
                    numBytesInGPU: this.numBytesInGPU,
                    numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
                    numBytesInGPUFree: this.textureManager.numBytesFree
                }
            }
            startTimer() {
                return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
                    startMs: Xs(),
                    endMs: null
                }
            }
            endTimer(e) {
                return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = Xs(), e)
            }
            async getQueryTime(e) {
                if (de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this.gpgpu.waitForQueryAndGetTime(e);
                const t = e;
                return t.endMs - t.startMs
            }
            disposeData(e, t = !1) {
                if (this.pendingDisposal.has(e)) return !1;
                if (!this.texData.has(e)) return !0;
                if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return !1;
                if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
                this.releaseGPUData(e);
                const {
                    complexTensorInfos: n
                } = this.texData.get(e);
                return null != n && (this.disposeData(n.real.dataId, t), this.disposeData(n.imag.dataId, t)), this.texData.delete(e), !0
            }
            releaseGPUData(e) {
                const {
                    texture: t,
                    dtype: n,
                    texShape: s,
                    usage: r,
                    isPacked: a,
                    slice: i
                } = this.texData.get(e), o = i && i.origDataId || e, u = this.dataRefCount.get(o);
                u > 1 ? this.dataRefCount.set(o, u - 1) : (this.dataRefCount.delete(o), null != t && (this.numBytesInGPU -= this.computeBytes(s, n), this.textureManager.releaseTexture(t, s, r, a)));
                const l = this.texData.get(e);
                l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null
            }
            getTexture(e) {
                return this.uploadToGPU(e), this.texData.get(e).texture.texture
            }
            getDataInfo(e) {
                return this.texData.get(e)
            }
            shouldExecuteOnCPU(e, t = _A) {
                return de().getBool("WEBGL_CPU_FORWARD") && e.every((e => null == this.texData.get(e.dataId).texture && O(e.shape) < t))
            }
            getGPGPUContext() {
                return this.gpgpu
            }
            where(e) {
                Is("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
                const t = e.dataSync();
                return FA(e.shape, t)
            }
            packedUnaryOp(e, t, n) {
                const s = new AA(e.shape, t),
                    r = this.compileAndRun(s, [e], n);
                return mi().makeTensorFromTensorInfo(r)
            }
            abs(e) {
                if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
                    const t = tA(this.texData.get(e.dataId).values);
                    return this.makeOutput(e.shape, e.dtype, t)
                }
                if (de().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, TA, e.dtype);
                const t = new NA(e.shape, TA),
                    n = this.compileAndRun(t, [e]);
                return mi().makeTensorFromTensorInfo(n)
            }
            makeTensorInfo(e, t, n) {
                let s;
                if ("string" === t && null != n && n.length > 0 && X(n[0])) {
                    const r = n.map((e => Ys(e)));
                    s = this.write(r, e, t)
                } else s = this.write(n, e, t);
                return this.texData.get(s).usage = null, {
                    dataId: s,
                    shape: e,
                    dtype: t
                }
            }
            makeOutput(e, t, n) {
                return mi().makeTensorFromTensorInfo(this.makeTensorInfo(e, t, n), this)
            }
            unpackTensor(e) {
                const t = new RA(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype)
            }
            packTensor(e) {
                const t = new bA(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype, null, !0)
            }
            packedReshape(e, t) {
                const n = [TC(e.shape), ...$C(e.shape)],
                    s = {
                        dtype: e.dtype,
                        shape: n,
                        dataId: e.dataId
                    },
                    r = [TC(t), ...$C(t)],
                    a = new xA(r, n),
                    i = [n],
                    o = this.runWebGLProgram(a, [s], e.dtype, i, !0);
                return {
                    dataId: o.dataId,
                    shape: t,
                    dtype: o.dtype
                }
            }
            decode(e, t) {
                const n = this.texData.get(e),
                    {
                        isPacked: s,
                        shape: r,
                        dtype: a
                    } = n;
                if (null != t) {
                    R(O(r) <= t[0] * t[1] * 4, (() => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))
                }
                const i = CC(r);
                let o;
                o = s ? new hE(i) : new cE(i);
                const u = [null != t ? t : cC(i)];
                return {
                    dtype: a,
                    shape: r,
                    dataId: this.runWebGLProgram(o, [{
                        shape: i,
                        dtype: a,
                        dataId: e
                    }], a, u, !0, t).dataId
                }
            }
            runWebGLProgram(e, t, n, s, r = !1, a) {
                const i = this.makeTensorInfo(e.outputShape, n),
                    o = this.texData.get(i.dataId);
                if (e.packedOutput && (o.isPacked = !0), e.outPackingScheme === iC.DENSE) {
                    const t = null != a ? a : cC(e.outputShape);
                    o.texShape = t.map((e => 2 * e))
                }
                if (null != e.outTexUsage && (o.usage = e.outTexUsage), 0 === O(i.shape)) return o.values = G(i.dtype, 0), i;
                const u = [],
                    l = t.map((t => {
                        if ("complex64" === t.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
                        let n = this.texData.get(t.dataId);
                        if (null == n.texture) {
                            if (!e.packedInputs && O(t.shape) <= de().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                                shape: t.shape,
                                texData: null,
                                isUniform: !0,
                                uniformValues: n.values
                            };
                            e.packedInputs && (n.isPacked = !0, n.shape = t.shape)
                        }
                        if (this.uploadToGPU(t.dataId), !!n.isPacked != !!e.packedInputs) t = n.isPacked ? this.unpackTensor(t) : this.packTensor(t), u.push(t), n = this.texData.get(t.dataId);
                        else if (n.isPacked && !AC(n.shape, t.shape)) {
                            const e = t,
                                s = t.shape;
                            t.shape = n.shape, t = this.packedReshape(t, s), u.push(t), n = this.texData.get(t.dataId), e.shape = s
                        }
                        return {
                            shape: t.shape,
                            texData: n,
                            isUniform: !1
                        }
                    }));
                this.uploadToGPU(i.dataId);
                const c = {
                        shape: i.shape,
                        texData: o,
                        isUniform: !1
                    },
                    h = function(e, t, n) {
                        let s = "";
                        t.concat(n).forEach((t => {
                            const r = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0;
                            if (e.enableShapeUniforms && !t.isUniform) {
                                const a = t.texData.texShape,
                                    {
                                        useSqueezeShape: i,
                                        uniformShape: o,
                                        keptDims: u
                                    } = sE(e.packedInputs, t.shape, a);
                                let l = "",
                                    c = "",
                                    h = "";
                                if (1 === o.length && e.packedInputs) {
                                    const e = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
                                    l = `${e[0]>1}_${e[1]>1}`
                                } else if (2 !== o.length || e.packedInputs) {
                                    if (o.length > 2 && !e.packedInputs) {
                                        const e = ee(o);
                                        h = `${e[0]===a[1]}_${e[e.length-1]===a[1]}`
                                    }
                                } else c = `${o[0]>1}_${o[1]>1}`;
                                const p = t.shape.length,
                                    d = 2 === o.length && M(t.shape, a),
                                    f = 1 === O(t.shape),
                                    m = Wa(t.shape, n.shape),
                                    g = !e.packedInputs && p === n.shape.length && M(a, n.texData.texShape),
                                    y = e.packedInputs || o.length > 2 ? "" : `${a[0]>1}_${a[1]>1}`;
                                s += `${p}_${g}_${i?u:""}_${o.length}_${f}_${m}_${d}_${l}_${c}_${h}_${y}_${r}`
                            } else {
                                const e = t.isUniform ? "uniform" : t.texData.texShape;
                                s += `${t.shape}_${e}_${r}`
                            }
                        }));
                        const r = e.userCode;
                        let a = e.constructor.name;
                        return a += "_" + s + "_" + r + `${de().getNumber("WEBGL_VERSION")}`, a
                    }(e, l, c),
                    p = this.getAndSaveBinary(h, (() => iE(this.gpgpu, e, l, c))),
                    d = null != this.activeTimers;
                let f;
                d && (f = this.startTimer()), de().get("ENGINE_COMPILE_ONLY") || function(e, t, n, s, r) {
                    t.program.enableShapeUniforms || (uE(t.inShapeInfos, n), uE([t.outShapeInfo], [s]));
                    const a = s.texData.texture,
                        i = s.texData.texShape;
                    s.texData.isPacked ? e.setOutputPackedMatrixTexture(a.texture, i[0], i[1]) : e.setOutputMatrixTexture(a.texture, i[0], i[1]), e.setProgram(t.webGLProgram), 1 === de().getNumber("WEBGL_VERSION") && null !== t.infLoc && e.gl.uniform1f(t.infLoc, 1 / 0), null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN), n.forEach(((n, s) => {
                        const r = t.program.variableNames[s],
                            a = t.uniformLocations[r],
                            i = t.uniformLocations[`offset${r}`],
                            o = t.inShapesLocations[`${r}Shape`],
                            u = t.inTexShapesLocations[`${r}TexShape`];
                        if (o) {
                            const {
                                uniformShape: s
                            } = sE(t.program.packedInputs, n.shape, n.texData.texShape);
                            switch (s.length) {
                                case 1:
                                    e.gl.uniform1iv(o, new Int32Array(s));
                                    break;
                                case 2:
                                    e.gl.uniform2iv(o, new Int32Array(s));
                                    break;
                                case 3:
                                    e.gl.uniform3iv(o, new Int32Array(s));
                                    break;
                                case 4:
                                    e.gl.uniform4iv(o, new Int32Array(s))
                            }
                        }
                        if (u && e.gl.uniform2i(u, n.texData.texShape[0], n.texData.texShape[1]), null != a)
                            if (n.isUniform)
                                if (O(n.shape) < 2) e.gl.uniform1f(a, n.uniformValues[0]);
                                else {
                                    let t = n.uniformValues;
                                    t instanceof Float32Array || (t = new Float32Array(t)), e.gl.uniform1fv(a, t)
                                }
                        else null != n.texData.slice && null != i && e.gl.uniform1i(i, n.texData.slice.flatOffset), e.setInputMatrixTexture(n.texData.texture.texture, a, s)
                    }));
                    const o = t.outShapeLocation;
                    if (o) switch (s.shape.length) {
                        case 1:
                            e.gl.uniform1iv(o, new Int32Array(s.shape));
                            break;
                        case 2:
                            e.gl.uniform2iv(o, new Int32Array(s.shape));
                            break;
                        case 3:
                            e.gl.uniform3iv(o, new Int32Array(s.shape));
                            break;
                        case 4:
                            e.gl.uniform4iv(o, new Int32Array(s.shape))
                    }
                    if (t.outShapeStridesLocation) {
                        const n = ee(s.shape);
                        switch (s.shape.length) {
                            case 2:
                                e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(n));
                                break;
                            case 3:
                                e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(n));
                                break;
                            case 4:
                                e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(n))
                        }
                    }
                    t.outTexShapeLocation && e.gl.uniform2i(t.outTexShapeLocation, s.texData.texShape[0], s.texData.texShape[1]), t.program.customUniforms && r && t.program.customUniforms.forEach(((n, s) => {
                        const a = t.customUniformLocations[s],
                            i = r[s];
                        if ("float" === n.type) e.gl.uniform1fv(a, i);
                        else if ("vec2" === n.type) e.gl.uniform2fv(a, i);
                        else if ("vec3" === n.type) e.gl.uniform3fv(a, i);
                        else if ("vec4" === n.type) e.gl.uniform4fv(a, i);
                        else if ("int" === n.type) e.gl.uniform1iv(a, i);
                        else if ("ivec2" === n.type) e.gl.uniform2iv(a, i);
                        else if ("ivec3" === n.type) e.gl.uniform3iv(a, i);
                        else {
                            if ("ivec4" !== n.type) throw Error(`uniform type ${n.type} is not supported yet.`);
                            e.gl.uniform4iv(a, i)
                        }
                    })), e.executeProgram()
                }(this.gpgpu, p, l, c, s), u.forEach((e => this.disposeIntermediateTensorInfo(e))), d && (f = this.endTimer(f), this.activeTimers.push({
                    name: e.constructor.name,
                    query: this.getQueryTime(f)
                }));
                const m = de().get("WEBGL_FLUSH_THRESHOLD");
                if (m > 0) {
                    const e = Xs();
                    e - this.lastGlFlushTime > m && (this.gpgpu.gl.flush(), this.lastGlFlushTime = e)
                }
                if (!de().getBool("WEBGL_LAZILY_UNPACK") && o.isPacked && !1 === r) {
                    const e = this.unpackTensor(i);
                    return this.disposeIntermediateTensorInfo(i), e
                }
                return i
            }
            compileAndRun(e, t, n, s, r = !1) {
                n = n || t[0].dtype;
                return this.runWebGLProgram(e, t, n, s, r)
            }
            getAndSaveBinary(e, t) {
                return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e]
            }
            getTextureManager() {
                return this.textureManager
            }
            dispose() {
                if (!this.disposed) {
                    if (!de().getBool("IS_TEST")) {
                        Object.keys(this.binaryCache).forEach((e => {
                            this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram), delete this.binaryCache[e]
                        }))
                    }
                    this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0
                }
            }
            floatPrecision() {
                return null == this.floatPrecisionValue && (this.floatPrecisionValue = yi((() => {
                    if (!de().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                        const e = de().getBool("DEBUG");
                        de().set("DEBUG", !1);
                        const t = this.abs(vi(1e-8)).dataSync()[0];
                        if (de().set("DEBUG", e), t > 0) return 32
                    }
                    return 16
                }))), this.floatPrecisionValue
            }
            epsilon() {
                return 32 === this.floatPrecision() ? 1e-7 : 1e-4
            }
            uploadToGPU(e) {
                const t = this.texData.get(e),
                    {
                        shape: n,
                        dtype: s,
                        values: r,
                        texture: a,
                        usage: i,
                        isPacked: o
                    } = t;
                if (null != a) return;
                const u = null != this.activeTimers;
                let l;
                u && (l = Xs());
                let c = t.texShape;
                if (null == c && (c = function(e, t = !1) {
                        let n = de().getNumber("WEBGL_MAX_TEXTURE_SIZE");
                        if (t && (n *= 2, 1 === (e = e.map(((t, n) => n >= e.length - 2 ? E(e[n]) : e[n]))).length && (e = [2, e[0]])), 2 !== e.length) {
                            const t = V(e);
                            e = t.newShape
                        }
                        let s = O(e);
                        if (e.length <= 1 && s <= n) return [1, s];
                        if (2 === e.length && e[0] <= n && e[1] <= n) return e;
                        if (3 === e.length && e[0] * e[1] <= n && e[2] <= n) return [e[0] * e[1], e[2]];
                        if (3 === e.length && e[0] <= n && e[1] * e[2] <= n) return [e[0], e[1] * e[2]];
                        if (4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n) return [e[0] * e[1] * e[2], e[3]];
                        if (4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n) return [e[0], e[1] * e[2] * e[3]];
                        if (t) {
                            const t = TC(e);
                            let n = 2,
                                r = 2;
                            return e.length && ([n, r] = $C(e)), s = t * (n / 2) * (r / 2), z(s).map((e => 2 * e))
                        }
                        return z(s)
                    }(n, o), t.texShape = c), null != r) {
                    const e = CC(n);
                    let a, i = c[1],
                        h = c[0];
                    const p = r instanceof Uint8Array || r instanceof Uint8ClampedArray;
                    !o && p || ([i, h] = hC(c[0], c[1])), a = o ? new mE(e, p) : new fE(e, p);
                    const d = p ? [h, i] : c,
                        f = this.makeTensorInfo(d, s),
                        m = this.texData.get(f.dataId);
                    m.usage = p ? oC.PIXELS : oC.UPLOAD, m.texShape = d, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId), i, h, r);
                    const g = [
                            [h, i]
                        ],
                        y = !0,
                        b = this.runWebGLProgram(a, [f], s, g, y),
                        x = this.texData.get(b.dataId);
                    t.texShape = x.texShape, t.isPacked = x.isPacked, t.usage = x.usage, de().get("ENGINE_COMPILE_ONLY") ? this.disposeData(b.dataId) : (t.texture = x.texture, t.values = null, this.texData.delete(b.dataId)), this.disposeIntermediateTensorInfo(f), u && (this.uploadWaitMs += Xs() - l)
                } else {
                    const e = this.acquireTexture(c, i, s, o);
                    t.texture = e
                }
            }
            convertAndCacheOnCPU(e, t) {
                const n = this.texData.get(e),
                    {
                        dtype: s
                    } = n;
                return this.releaseGPUData(e), null != t && (n.values = function(e, t) {
                    if ("float32" === t || "complex64" === t) return e;
                    if ("int32" === t || "bool" === t) {
                        const n = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length);
                        for (let t = 0; t < n.length; ++t) n[t] = Math.round(e[t]);
                        return n
                    }
                    throw new Error(`Unknown dtype ${t}`)
                }(t, s)), n.values
            }
            acquireTexture(e, t, n, s) {
                if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
                    const e = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
                    this.warnedAboutMemory = !0, console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)
                }
                return this.textureManager.acquireTexture(e, t, s)
            }
            computeBytes(e, t) {
                return e[0] * e[1] * K(t)
            }
            checkCompileCompletion() {
                for (const [, e] of Object.entries(this.binaryCache)) this.checkCompletion_(e)
            }
            async checkCompileCompletionAsync() {
                const e = [];
                if (this.gpgpu.parallelCompilationExtension) {
                    for (const [, t] of Object.entries(this.binaryCache)) e.push(this.checkCompletionAsync_(t));
                    return Promise.all(e)
                }
                for (const [, t] of Object.entries(this.binaryCache)) {
                    const n = new Promise((e => {
                        try {
                            this.checkCompletion_(t), e(!0)
                        } catch (e) {
                            throw e
                        }
                    }));
                    e.push(n)
                }
                return Promise.all(e)
            }
            async checkCompletionAsync_(e) {
                return this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(e) : (await hc(), this.checkCompletionAsync_(e))
            }
            checkCompletion_(e) {
                if (!1 === this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.gl.LINK_STATUS)) {
                    if (console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)), !1 === this.gpgpu.gl.getShaderParameter(e.fragmentShader, this.gpgpu.gl.COMPILE_STATUS)) throw yC(e.source, this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)), new Error("Failed to compile fragment shader.");
                    throw new Error("Failed to link vertex and fragment shaders.")
                }
                return !0
            }
            getUniformLocations() {
                for (const [, e] of Object.entries(this.binaryCache)) {
                    const {
                        uniformLocations: t,
                        customUniformLocations: n,
                        infLoc: s,
                        nanLoc: r,
                        inShapesLocations: a,
                        inTexShapesLocations: i,
                        outShapeLocation: o,
                        outShapeStridesLocation: u,
                        outTexShapeLocation: l
                    } = oE(this.gpgpu, e.program, e.webGLProgram);
                    e.uniformLocations = t, e.customUniformLocations = n, e.infLoc = s, e.nanLoc = r, e.inShapesLocations = a, e.inTexShapesLocations = i, e.outShapeLocation = o, e.outShapeStridesLocation = u, e.outTexShapeLocation = l
                }
            }
        }
        OA.nextDataId = 0;
        Dr() && wi("webgl", (() => new OA), 2);
        const MA = "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";
        class LA {
            constructor(e, t, n) {
                this.variableNames = ["A", "B"], this.outputShape = Ga(t, n), this.enableShapeUniforms = lE(this.outputShape.length), this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `
            }
        }
        const zA = "\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";
        class BA {
            constructor(e, t, n, s = !1) {
                this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Ga(t, n);
                const r = this.outputShape.length;
                this.enableShapeUniforms = lE(r);
                let a = "";
                if (s)
                    if (0 === r || 1 === O(this.outputShape)) a = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
                    else {
                        if (a = `\n          ${nE(r)} coords = getOutputCoords();\n        `, 1 === r) this.enableShapeUniforms ? a += "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : a += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;
                        else {
                            const e = yA("coords", r);
                            this.enableShapeUniforms ? a += `\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ` : a += `\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `
                        }
                    } this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `
            }
        }

        function PA(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                x: s
            } = t;
            return n.incRef(s.dataId), {
                dataId: s.dataId,
                shape: s.shape,
                dtype: s.dtype
            }
        }
        const UA = {
            kernelName: Rt,
            backendName: "webgl",
            kernelFunc: PA
        };

        function WA(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                real: s,
                imag: r
            } = t, a = n.makeTensorInfo(s.shape, "complex64"), i = n.texData.get(a.dataId), o = PA({
                inputs: {
                    x: s
                },
                backend: n
            }), u = PA({
                inputs: {
                    x: r
                },
                backend: n
            });
            return i.complexTensorInfos = {
                real: o,
                imag: u
            }, a
        }
        const VA = {
                kernelName: Ve,
                backendName: "webgl",
                kernelFunc: WA
            },
            GA = "return (a < 0.) ? b * a : a;",
            HA = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
        const jA = {
                kernelName: Lt,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        alpha: a
                    } = s, i = n.makeTensorInfo([], "float32", qs(a, "float32")), o = de().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BA(HA, r.shape, i.shape) : new LA(GA, r.shape, i.shape), u = n.runWebGLProgram(o, [r, i], "float32");
                    return n.disposeIntermediateTensorInfo(i), u
                }
            },
            qA = "return (a < 0.) ? b * a : a;",
            KA = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
        const XA = {
                kernelName: xn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        x: s,
                        alpha: r
                    } = t, a = de().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BA(KA, s.shape, r.shape) : new LA(qA, s.shape, r.shape);
                    return n.runWebGLProgram(a, [s, r], "float32")
                }
            },
            YA = "if (isnan(x)) return x;";

        function JA({
            opSnippet: e,
            packedOpSnippet: t,
            cpuKernelImpl: n,
            dtype: s
        }) {
            return ({
                inputs: r,
                backend: a
            }) => {
                const {
                    x: i
                } = r, o = a, u = s || i.dtype;
                if (o.shouldExecuteOnCPU([i]) && null != n) {
                    const e = o.texData.get(i.dataId),
                        t = n(e.values, u);
                    return o.makeTensorInfo(i.shape, u, t)
                }
                let l;
                return l = de().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != t ? new AA(i.shape, t) : new NA(i.shape, e), o.runWebGLProgram(l, [i], u)
            }
        }

        function ZA({
            opSnippet: e,
            packedOpSnippet: t,
            checkOutOfBounds: n = !1,
            supportsComplex: s = !1,
            cpuKernelImpl: r,
            dtype: a
        }) {
            return ({
                inputs: i,
                backend: o
            }) => {
                const {
                    a: u,
                    b: l
                } = i, c = o;
                if (s && "complex64" === u.dtype) {
                    const t = c.texData.get(u.dataId),
                        n = c.texData.get(l.dataId),
                        [s, r] = [
                            [t.complexTensorInfos.real, n.complexTensorInfos.real],
                            [t.complexTensorInfos.imag, n.complexTensorInfos.imag]
                        ].map((t => {
                            const [n, s] = t, r = {
                                dataId: n.dataId,
                                dtype: n.dtype,
                                shape: u.shape
                            }, a = {
                                dataId: s.dataId,
                                dtype: s.dtype,
                                shape: l.shape
                            }, i = new LA(e, u.shape, l.shape);
                            return c.runWebGLProgram(i, [r, a], xr(n.dtype, s.dtype))
                        })),
                        a = WA({
                            inputs: {
                                real: s,
                                imag: r
                            },
                            backend: c
                        });
                    return c.disposeIntermediateTensorInfo(s), c.disposeIntermediateTensorInfo(r), a
                }
                const h = a || xr(u.dtype, l.dtype);
                if (("string" === u.dtype || "string" === l.dtype || c.shouldExecuteOnCPU([u, l])) && null != r) {
                    const e = c.texData.get(u.dataId).values,
                        t = c.texData.get(l.dataId).values,
                        n = "string" === u.dtype ? fh(e) : e,
                        s = "string" === u.dtype ? fh(t) : t,
                        [a, i] = r(u.shape, l.shape, n, s, h),
                        o = c.makeTensorInfo(i, h);
                    return c.texData.get(o.dataId).values = a, o
                }
                let p;
                return p = de().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != t ? new BA(t, u.shape, l.shape, n) : new LA(e, u.shape, l.shape), c.runWebGLProgram(p, [u, l], h)
            }
        }

        function QA(e, t = !1) {
            if ("linear" === e) return "return x;";
            if ("relu" === e) return t ? "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : $A;
            if ("elu" === e) return t ? "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n" : "return (x >= 0.0) ? x : (exp(x) - 1.0);";
            if ("relu6" === e) return t ? "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n" : CA;
            if ("prelu" === e) return t ? KA : qA;
            if ("leakyrelu" === e) return t ? HA : GA;
            if ("sigmoid" === e) return "return 1.0 / (1.0 + exp(-1.0 * x));";
            throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)
        }
        class eR {
            constructor(e, t, n, s = !1, r = !1, a = !1, i = null, o = !1, u = !1) {
                this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n, this.enableShapeUniforms = lE(this.outputShape.length);
                const l = s ? e[1] : e[2],
                    c = Math.ceil(l / 2),
                    h = s ? "i * 2, rc.y" : "rc.y, i * 2",
                    p = r ? "rc.z, i * 2" : "i * 2, rc.z",
                    d = s ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
                    f = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
                let m = "",
                    g = "";
                i && (m = o ? `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }` : u ? `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }` : `vec4 activation(vec4 x) {\n          ${i}\n        }`, g = "result = activation(result);");
                const y = a ? "result += getBiasAtOutCoords();" : "";
                a && this.variableNames.push("bias"), o && this.variableNames.push("preluActivationWeights"), u && this.variableNames.push("leakyreluAlpha");
                let b = "rc.x",
                    x = "rc.x";
                e[0] < t[0] ? b = `int(min(float(rc.x), ${e[0]-1}.))` : t[0] < e[0] && (x = `int(min(float(rc.x), ${t[0]-1}.))`), this.userCode = `\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${b};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${f[0]});\n          result += (${d[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `
            }
        }
        const tR = "return areal * breal - aimag * bimag;",
            nR = "return areal * bimag + aimag * breal;";
        class sR {
            constructor(e, t, n) {
                this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = Ga(t, n), this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `
            }
        }
        const rR = "return a * b;";

        function aR(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                a: s,
                b: r
            } = t, a = xr(s.dtype, r.dtype);
            if ("complex64" === s.dtype) {
                const e = n.texData.get(s.dataId),
                    t = n.texData.get(r.dataId),
                    a = new sR(tR, s.shape, r.shape),
                    i = new sR(nR, s.shape, r.shape),
                    o = [{
                        dataId: e.complexTensorInfos.real.dataId,
                        dtype: e.complexTensorInfos.real.dtype,
                        shape: s.shape
                    }, {
                        dataId: e.complexTensorInfos.imag.dataId,
                        dtype: e.complexTensorInfos.imag.dtype,
                        shape: s.shape
                    }, {
                        dataId: t.complexTensorInfos.real.dataId,
                        dtype: t.complexTensorInfos.real.dtype,
                        shape: r.shape
                    }, {
                        dataId: t.complexTensorInfos.imag.dataId,
                        dtype: t.complexTensorInfos.imag.dtype,
                        shape: r.shape
                    }],
                    u = n.runWebGLProgram(a, o, "float32"),
                    l = n.runWebGLProgram(i, o, "float32"),
                    c = WA({
                        inputs: {
                            real: u,
                            imag: l
                        },
                        backend: n
                    });
                return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(l), c
            }
            if (n.shouldExecuteOnCPU([s, r])) {
                const e = n.texData.get(s.dataId),
                    t = n.texData.get(r.dataId),
                    [i, o] = qE(s.shape, r.shape, e.values, t.values, a),
                    u = n.makeTensorInfo(o, a);
                return n.texData.get(u.dataId).values = i, u
            }
            let i;
            return i = de().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BA(rR, s.shape, r.shape) : new LA(rR, s.shape, r.shape), n.runWebGLProgram(i, [s, r], a)
        }
        const iR = {
            kernelName: un,
            backendName: "webgl",
            kernelFunc: aR
        };

        function oR(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                shape: a
            } = s, i = n, o = O(r.shape), u = U(a, o), l = O(u);
            R(o === l, (() => `The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));
            const c = i.texData.get(r.dataId);
            return !c.isPacked || AC(r.shape, u) || null !== c.texture && AC(c.shape, u) ? (i.incRef(r.dataId), {
                dataId: r.dataId,
                shape: u,
                dtype: r.dtype
            }) : function(e, t, n) {
                const s = [TC(e.shape), ...$C(e.shape)],
                    r = {
                        dtype: e.dtype,
                        shape: s,
                        dataId: e.dataId
                    },
                    a = [TC(t), ...$C(t)],
                    i = new xA(a, s),
                    o = [s],
                    u = n.runWebGLProgram(i, [r], e.dtype, o, !0);
                return {
                    dataId: u.dataId,
                    shape: t,
                    dtype: u.dtype
                }
            }(r, u, i)
        }
        const uR = {
            kernelName: Sn,
            backendName: "webgl",
            kernelFunc: oR
        };
        class lR {
            constructor(e, t) {
                this.variableNames = ["x"];
                const {
                    windowSize: n,
                    batchSize: s,
                    inSize: r,
                    outSize: a
                } = e;
                this.outputShape = [s, a];
                const i = 4 * Math.floor(n / 4),
                    o = n % 4;
                let u = "sumValue += dot(values, ones);";
                if (null != t) {
                    const e = 1 / t;
                    u = `sumValue += dot(values * ${L(e)?e.toPrecision(2):e}, ones);`
                }
                let l = "";
                r % n > 0 && (l = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `), this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `
            }
        }
        class cR {
            constructor(e, t) {
                this.variableNames = ["x"];
                const {
                    windowSize: n,
                    batchSize: s,
                    inSize: r,
                    outSize: a
                } = e;
                this.outputShape = [s, a];
                let i = "0.0",
                    o = "";
                "prod" === t ? i = "1.0" : "min" === t ? (i = "1.0 / 1e-20", o = "min") : "max" === t && (i = "-1.0 / 1e-20", o = "max");
                let u = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
                "sum" === t ? u = "sumValue" : "prod" === t ? u = "prodValue" : "all" === t ? u = "allValue" : "any" === t && (u = "anyValue");
                const l = 4 * Math.floor(n / 4),
                    c = n % 4;
                let h = `\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,
                    p = "vec4";
                "all" === t ? (i = "1.0", h = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", p = "bvec4") : "any" === t && (i = "0.0", h = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", p = "bvec4");
                let d = "";
                r % n > 0 && (d = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `), this.userCode = `\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `
            }
        }

        function hR(e, t, n, s) {
            const r = function(e) {
                const t = [];
                for (; 0 === t.length || 1 !== t[t.length - 1].outSize;) {
                    const n = t.length ? t[t.length - 1].outSize : e[1],
                        s = mc(n);
                    t.push({
                        inSize: n,
                        windowSize: s,
                        outSize: Math.ceil(n / s)
                    })
                }
                return t
            }(e.shape);
            let a = e;
            for (let i = 0; i < r.length; i++) {
                const {
                    inSize: o,
                    windowSize: u,
                    outSize: l
                } = r[i];
                let c, h;
                c = "mean" === n ? 0 === i ? new lR({
                    windowSize: u,
                    inSize: o,
                    batchSize: e.shape[0],
                    outSize: l
                }, o) : new lR({
                    windowSize: u,
                    inSize: o,
                    batchSize: e.shape[0],
                    outSize: l
                }) : new cR({
                    windowSize: u,
                    inSize: o,
                    batchSize: e.shape[0],
                    outSize: l
                }, n), h = a, a = s.runWebGLProgram(c, [a], t), h.dataId !== e.dataId && s.disposeIntermediateTensorInfo(h)
            }
            return a
        }
        class pR {
            constructor(e, t) {
                this.variableNames = ["A"];
                const n = new Array(e.length);
                for (let s = 0; s < n.length; s++) n[s] = e[t[s]];
                this.outputShape = n, this.rank = n.length;
                const s = nE(this.rank),
                    r = function(e) {
                        const t = e.length;
                        if (t > 6) throw Error(`Transpose for rank ${t} is not yet supported`);
                        const n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"],
                            s = new Array(t);
                        for (let t = 0; t < e.length; t++) s[e[t]] = n[t];
                        return s.join()
                    }(t);
                this.userCode = `\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `
            }
        }
        class dR {
            constructor(e, t) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
                const n = new Array(e.length);
                for (let s = 0; s < n.length; s++) n[s] = e[t[s]];
                if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
                const s = nE(this.rank),
                    r = gA("rc", this.rank),
                    a = new Array(this.rank);
                for (let e = 0; e < t.length; e++) a[t[e]] = r[e];
                const i = `vec2(${a.slice(-2).join()})`,
                    o = `++${r[this.rank-1]} < ${n[this.rank-1]}`,
                    u = `getChannel(getA(${a.join()}), ${i})`;
                this.userCode = `\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `
            }
        }

        function fR(e, t, n) {
            const s = de().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new dR(e.shape, t) : new pR(e.shape, t);
            return n.runWebGLProgram(s, [e], e.dtype)
        }

        function mR(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                axis: a,
                keepDims: i
            } = s;
            return function(e, t, n, s) {
                const r = t,
                    a = e.shape.length,
                    i = W(r, e.shape);
                let o = i;
                const u = Go(o, a),
                    l = null != u;
                let c = e;
                l && (c = fR(e, u, s), o = jo(o.length, a)), Vo("sum", o, a);
                const [h, p] = Uo(c.shape, o);
                let d = h;
                n && (d = Wo(h, i));
                const f = O(p),
                    m = oR({
                        inputs: {
                            x: c
                        },
                        attrs: {
                            shape: [O(e.shape) / f, f]
                        },
                        backend: s
                    }),
                    g = hR(m, wr(e.dtype), "sum", s),
                    y = oR({
                        inputs: {
                            x: g
                        },
                        attrs: {
                            shape: d
                        },
                        backend: s
                    });
                return s.disposeIntermediateTensorInfo(m), s.disposeIntermediateTensorInfo(g), l && s.disposeIntermediateTensorInfo(c), y
            }(r, a, i, n)
        }
        const gR = {
            kernelName: Hn,
            backendName: "webgl",
            kernelFunc: mR
        };

        function yR(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                perm: a
            } = s, i = n, o = r.shape.length, u = new Array(o);
            for (let e = 0; e < u.length; e++) u[e] = r.shape[a[e]];
            let l;
            if (i.shouldExecuteOnCPU([r])) {
                const e = i.texData.get(r.dataId).values,
                    t = fA(e, r.shape, r.dtype, a, u);
                l = i.makeTensorInfo(u, r.dtype);
                i.texData.get(l.dataId).values = t
            } else l = fR(r, a, i);
            return l
        }
        const bR = {
            kernelName: ps,
            backendName: "webgl",
            kernelFunc: yR
        };

        function xR({
            a: e,
            b: t,
            transposeA: n,
            transposeB: s,
            backend: r,
            bias: a = null,
            preluActivationWeights: i = null,
            leakyreluAlpha: o = 0,
            activation: u = null
        }) {
            const l = e.shape.length,
                c = t.shape.length,
                h = n ? e.shape[l - 2] : e.shape[l - 1],
                p = s ? t.shape[c - 1] : t.shape[c - 2],
                d = n ? e.shape[l - 1] : e.shape[l - 2],
                f = s ? t.shape[c - 2] : t.shape[c - 1],
                m = e.shape.slice(0, -2),
                g = t.shape.slice(0, -2),
                y = O(m),
                b = O(g),
                x = Ga(e.shape.slice(0, -2), t.shape.slice(0, -2)).concat([d, f]);
            R(h === p, (() => `Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${s} must match.`));
            const w = n ? [y, h, d] : [y, d, h],
                k = s ? [b, f, p] : [b, p, f],
                v = oR({
                    inputs: {
                        x: e
                    },
                    backend: r,
                    attrs: {
                        shape: w
                    }
                }),
                I = oR({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: k
                    }
                }),
                N = [v, I],
                S = Math.max(y, b),
                T = n ? v.shape[1] : v.shape[2],
                $ = null != a,
                C = null != i,
                E = "leakyrelu" === u,
                A = null != u ? QA(u, !0) : null;
            let F;
            if ((1 === d || 1 === f) && T > 1e3 && !1 === ($ || C || E || null != A)) {
                let e = v,
                    t = I;
                n && (e = yR({
                    inputs: {
                        x: v
                    },
                    backend: r,
                    attrs: {
                        perm: [0, 2, 1]
                    }
                }), N.push(e)), s && (t = yR({
                    inputs: {
                        x: I
                    },
                    backend: r,
                    attrs: {
                        perm: [0, 2, 1]
                    }
                }), N.push(t));
                const a = 1 === f;
                let i = e;
                1 !== f && (i = oR({
                    inputs: {
                        x: e
                    },
                    backend: r,
                    attrs: {
                        shape: [S, T, 1]
                    }
                }), N.push(i));
                const o = 1 === f ? 2 : 1;
                let u = t;
                a && (u = oR({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: [S, 1, T]
                    }
                }), N.push(u));
                const l = aR({
                    inputs: {
                        a: i,
                        b: u
                    },
                    backend: r
                });
                F = mR({
                    inputs: {
                        x: l
                    },
                    backend: r,
                    attrs: {
                        axis: o,
                        keepDims: !0
                    }
                }), N.push(l)
            } else {
                const u = xr(e.dtype, t.dtype),
                    l = new eR(w, k, [S, d, f], n, s, $, A, C, E),
                    c = [v, I];
                if (null != a && c.push(a), C && c.push(i), E) {
                    const e = r.makeTensorInfo([], "float32", qs(o, "float32"));
                    c.push(e), N.push(e)
                }
                F = r.runWebGLProgram(l, c, u)
            }
            const D = oR({
                inputs: {
                    x: F
                },
                backend: r,
                attrs: {
                    shape: x
                }
            });
            N.push(F);
            for (const e of N) r.disposeIntermediateTensorInfo(e);
            return D
        }
        const wR = {
                kernelName: ws,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        a: r,
                        b: a,
                        bias: i,
                        preluActivationWeights: o
                    } = t, {
                        transposeA: u,
                        transposeB: l,
                        activation: c,
                        leakyreluAlpha: h
                    } = s;
                    return xR({
                        a: r,
                        b: a,
                        transposeA: u,
                        transposeB: l,
                        backend: n,
                        bias: i,
                        preluActivationWeights: o,
                        leakyreluAlpha: h,
                        activation: c
                    })
                }
            },
            kR = "return abs(x);";
        const vR = {
                kernelName: be,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        x: s
                    } = t;
                    if (n.shouldExecuteOnCPU([s]) && "complex64" !== s.dtype) {
                        const e = n.texData.get(s.dataId),
                            t = tA(e.values);
                        return n.makeTensorInfo(s.shape, s.dtype, t)
                    }
                    let r;
                    return r = de().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new AA(s.shape, kR) : new NA(s.shape, kR), n.runWebGLProgram(r, [s], s.dtype)
                }
            },
            IR = JA({
                opSnippet: SA + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
            }),
            NR = {
                kernelName: xe,
                backendName: "webgl",
                kernelFunc: IR
            },
            SR = JA({
                opSnippet: SA + "\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
            }),
            TR = {
                kernelName: we,
                backendName: "webgl",
                kernelFunc: SR
            },
            $R = "return a + b;",
            CR = ZA({
                opSnippet: $R,
                packedOpSnippet: $R,
                supportsComplex: !0,
                cpuKernelImpl: $E
            }),
            ER = {
                kernelName: ke,
                backendName: "webgl",
                kernelFunc: CR
            };
        class AR {
            constructor(e, t) {
                this.outputShape = [], this.outputShape = e, this.variableNames = t.map(((e, t) => `T${t}`));
                const n = [];
                this.variableNames.forEach((e => {
                    n.push(`float v${e} = get${e}AtOutCoords();`)
                }));
                const s = this.variableNames.map((e => `v${e}`)).join(" + ");
                this.userCode = `\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `
            }
        }
        class RR {
            constructor(e, t) {
                this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = t.map(((e, t) => `T${t}`));
                const n = [];
                this.variableNames.forEach((e => {
                    n.push(`vec4 v${e} = get${e}AtOutCoords();`)
                }));
                const s = this.variableNames.map((e => `v${e}`)).join(" + ");
                this.userCode = `\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `
            }
        }
        const FR = {
            kernelName: ve,
            backendName: "webgl",
            kernelFunc: function e(t) {
                const {
                    inputs: n,
                    backend: s
                } = t, r = n;
                if (1 === r.length) return PA({
                    inputs: {
                        x: r[0]
                    },
                    backend: s
                });
                if (r.length > de().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                    const t = Math.floor(r.length / 2),
                        n = e({
                            inputs: r.slice(0, t),
                            backend: s
                        }),
                        a = e({
                            inputs: r.slice(t),
                            backend: s
                        });
                    return e({
                        inputs: [n, a],
                        backend: s
                    })
                }
                const a = r.map((e => e.dtype)).reduce(((e, t) => xr(e, t))),
                    i = r.map((e => e.shape)),
                    o = de().getBool("WEBGL_PACK") ? new RR(r[0].shape, i) : new AR(r[0].shape, i);
                return s.runWebGLProgram(o, r, a)
            }
        };
        const DR = {
            kernelName: Ie,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    keepDims: i
                } = s, o = r.shape.length, u = W(a, r.shape);
                let l = u;
                const c = Go(l, o);
                let h = r;
                null != c && (h = yR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }), l = jo(l.length, o)), Vo("all", l, o);
                const [p, d] = Uo(h.shape, l), f = oR({
                    inputs: {
                        x: h
                    },
                    backend: n,
                    attrs: {
                        shape: [-1, O(d)]
                    }
                }), m = hR(f, f.dtype, "all", n);
                let g;
                if (i) {
                    g = oR({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: Wo(p, u)
                        }
                    })
                } else g = oR({
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: p
                    }
                });
                return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), g
            }
        };
        const _R = {
            kernelName: Ne,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    keepDims: i
                } = s, o = r.shape.length, u = W(a, r.shape);
                let l = u;
                const c = Go(l, o);
                let h = r;
                null != c && (h = yR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }), l = jo(l.length, o)), Vo("any", l, o);
                const [p, d] = Uo(h.shape, l), f = oR({
                    inputs: {
                        x: h
                    },
                    backend: n,
                    attrs: {
                        shape: [-1, O(d)]
                    }
                }), m = hR(f, f.dtype, "any", n);
                let g;
                if (i) {
                    g = oR({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: Wo(p, u)
                        }
                    })
                } else g = oR({
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: p
                    }
                });
                return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), g
            }
        };
        class OR {
            constructor(e, t, n) {
                this.variableNames = ["A"];
                const {
                    windowSize: s,
                    batchSize: r,
                    outSize: a
                } = e;
                n || this.variableNames.push("bestIndicesA"), this.outputShape = [r, a];
                const i = "max" === t ? ">" : "<",
                    o = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
                this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `
            }
        }
        class MR {
            constructor(e, t, n, s) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, R(e.length > 2, (() => `Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));
                const r = e[e.length - 1],
                    a = Math.ceil(r / t);
                this.outputShape = e.slice(0, -1), a > 1 && this.outputShape.push(a), s || this.variableNames.push("bestIndicesA");
                const i = this.outputShape,
                    o = i.length,
                    u = nE(o),
                    l = yA("coords", o);
                let c, h;
                if (1 === a) {
                    h = o + 1;
                    const e = nE(h);
                    c = `\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[o-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[o-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[o-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[o-2]};`
                } else h = o, c = `\n        ${u} sourceLocR = coords;\n        ++${l[o-1]};\n        ${u} sourceLocG = coords;\n        ++${l[o-2]};\n        ${u} sourceLocA = coords;\n        --${l[o-1]};\n        ${u} sourceLocB = coords;\n        --${l[o-2]};`;
                const p = ["x", "y", "z", "w", "u", "v"].slice(0, h),
                    d = "." + p[h - 1],
                    f = p.map((e => "int " + e)),
                    m = yA("sourceLocR", h - 1).concat("inIdx.r"),
                    g = yA("sourceLocG", h - 1).concat("inIdx.g"),
                    y = yA("sourceLocB", h - 1).concat("inIdx.b"),
                    b = yA("sourceLocA", h - 1).concat("inIdx.a"),
                    x = "max" === n ? "greaterThan" : "lessThan",
                    w = s ? "" : `\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,
                    k = `vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,
                    v = s ? "" : `\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;
                this.userCode = `\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${v}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${l[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${k};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${k};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `
            }
        }

        function LR(e, t, n, s = null) {
            let r = t.shape[0],
                a = t.shape[1];
            null != s && (r = s.shape[0], a = s.shape[1]);
            const i = mc(a),
                o = {
                    windowSize: i,
                    inSize: a,
                    batchSize: r,
                    outSize: Math.ceil(a / i)
                },
                u = new OR(o, n, null == s),
                l = [t];
            null != s && l.push(s);
            const c = e.runWebGLProgram(u, l, "int32");
            if (1 === c.shape[1]) return c;
            const h = LR(e, t, n, c);
            return e.disposeIntermediateTensorInfo(c), h
        }

        function zR(e, t, n, s = null) {
            const r = null != s ? s.shape : t.shape,
                a = mc(r[r.length - 1]),
                i = new MR(r, a, n, null == s),
                o = null == s ? [t] : [t, s],
                u = e.runWebGLProgram(i, o, "int32");
            if (u.shape.length === t.shape.length) {
                const s = zR(e, t, n, u);
                return e.disposeIntermediateTensorInfo(u), s
            }
            return u
        }

        function BR(e, t, n, s) {
            const r = [n];
            if (Vo("arg" + s.charAt(0).toUpperCase() + s.slice(1), r, t.shape.length), !de().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
                const n = [],
                    a = e.texData.get(t.dataId);
                let i = t;
                null !== a && a.isPacked && (i = e.unpackTensor(t), n.push(i));
                const [o, u] = Uo(i.shape, r), l = O(u), c = oR({
                    inputs: {
                        x: i
                    },
                    backend: e,
                    attrs: {
                        shape: [-1, l]
                    }
                });
                n.push(c);
                const h = LR(e, c, s);
                n.push(h);
                const p = oR({
                    inputs: {
                        x: h
                    },
                    backend: e,
                    attrs: {
                        shape: o
                    }
                });
                return n.forEach((t => e.disposeIntermediateTensorInfo(t))), p
            }
            return zR(e, t, s)
        }
        const PR = {
            kernelName: Se,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a
                } = s;
                let i = W(a, r.shape);
                const o = Go(i, r.shape.length);
                let u = r;
                const l = [];
                null != o && (u = yR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        perm: o
                    }
                }), l.push(u), i = jo(i.length, u.shape.length)), Vo("argMax", [i[0]], u.shape.length);
                const c = BR(n, u, i[0], "max");
                return l.forEach((e => n.disposeIntermediateTensorInfo(e))), c
            }
        };
        const UR = {
                kernelName: Te,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        axis: a
                    } = s;
                    let i = W(a, r.shape);
                    const o = Go(i, r.shape.length);
                    let u = r;
                    const l = [];
                    null != o && (u = yR({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            perm: o
                        }
                    }), l.push(u), i = jo(i.length, u.shape.length)), Vo("argMin", [i[0]], u.shape.length);
                    const c = BR(n, u, i[0], "min");
                    return l.forEach((e => n.disposeIntermediateTensorInfo(e))), c
                }
            },
            WR = JA({
                opSnippet: SA + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
            }),
            VR = {
                kernelName: $e,
                backendName: "webgl",
                kernelFunc: WR
            },
            GR = JA({
                opSnippet: SA + "return log(x + sqrt(x * x + 1.0));"
            }),
            HR = {
                kernelName: Ce,
                backendName: "webgl",
                kernelFunc: GR
            },
            jR = JA({
                opSnippet: SA + "\n  return atan(x);\n"
            }),
            qR = {
                kernelName: Ee,
                backendName: "webgl",
                kernelFunc: jR
            },
            KR = ZA({
                opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
                packedOpSnippet: "\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"
            }),
            XR = {
                kernelName: Re,
                backendName: "webgl",
                kernelFunc: KR
            },
            YR = JA({
                opSnippet: SA + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
            }),
            JR = {
                kernelName: Ae,
                backendName: "webgl",
                kernelFunc: YR
            };
        class ZR {
            constructor(e, t, n, s = !1, r = !1) {
                if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
                const a = e.filterWidth,
                    i = e.strideHeight,
                    o = e.strideWidth,
                    u = e.dilationHeight,
                    l = e.dilationWidth,
                    c = e.effectiveFilterHeight,
                    h = e.effectiveFilterWidth,
                    p = e.padInfo.top,
                    d = e.padInfo.left;
                this.outputShape = e.outShape;
                const f = "avg" === t,
                    m = `((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,
                    g = `(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;
                let y = "0.0";
                if (f || (y = "-1.0 / 1e-20"), n) {
                    const t = ">=";
                    return void(this.userCode = `\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${p}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)
                }
                let b = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
                "avg" === t && (b = "avgValue / count");
                const x = 4 * Math.floor(a / 4),
                    w = a % 4,
                    k = `\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;
                this.userCode = `\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${b});\n      }\n    `
            }
        }
        class QR {
            constructor(e, t, n, s = !1, r = !1) {
                if (this.variableNames = ["x"], "avg" === t && n) throw new Error("Cannot compute positions for average pool.");
                const a = e.filterWidth,
                    i = e.strideDepth,
                    o = e.strideHeight,
                    u = e.strideWidth,
                    l = e.dilationDepth,
                    c = e.dilationHeight,
                    h = e.dilationWidth,
                    p = e.effectiveFilterDepth,
                    d = e.effectiveFilterHeight,
                    f = e.effectiveFilterWidth,
                    m = e.padInfo.front,
                    g = e.padInfo.top,
                    y = e.padInfo.left;
                this.outputShape = e.outShape;
                const b = "avg" === t;
                let x = "0.0";
                if (b || (x = "-1.0 / 1e-20"), n) {
                    const t = ">=";
                    return void(this.userCode = `\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)
                }
                let w = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
                "avg" === t && (w = "avgValue / count");
                const k = 4 * Math.floor(a / 4),
                    v = a % 4,
                    I = `\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;
                this.userCode = `\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${I}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===v}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${2===v}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${I}\n            } else if (${3===v}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${I}\n            }\n          }\n          setOutput(${w});\n        }\n      }\n    `
            }
        }
        const eF = {
            kernelName: Fe,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t;
                LC(r, "avgPool");
                const {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u
                } = s;
                R(Pi(i, 1), (() => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
                const l = Ai(r.shape, a, i, 1, o, u);
                if (1 === l.filterWidth && 1 === l.filterHeight && M(l.inShape, l.outShape)) return PA({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                const c = new ZR(l, "avg", !1);
                return n.runWebGLProgram(c, [r], "float32")
            }
        };
        const tF = {
            kernelName: _e,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u,
                    dataFormat: l
                } = s, c = Ri(r.shape, a, i, [1, 1, 1], o, u, l), h = new QR(c, "avg", !1);
                return n.runWebGLProgram(h, [r], "float32")
            }
        };
        class nF {
            constructor(e) {
                this.variableNames = ["dy"], this.outputShape = e.inShape;
                const t = e.filterHeight,
                    n = e.filterWidth,
                    s = e.strideHeight,
                    r = e.strideWidth,
                    a = e.dilationHeight,
                    i = e.dilationWidth,
                    o = e.effectiveFilterHeight,
                    u = e.effectiveFilterWidth,
                    l = o - 1 - e.padInfo.top,
                    c = u - 1 - e.padInfo.left,
                    h = 1 / (t * n);
                this.userCode = `\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class sF {
            constructor(e) {
                this.variableNames = ["dy"], this.outputShape = e.inShape;
                const t = e.filterDepth,
                    n = e.filterHeight,
                    s = e.filterWidth,
                    r = e.strideDepth,
                    a = e.strideHeight,
                    i = e.strideWidth,
                    o = e.dilationDepth,
                    u = e.dilationHeight,
                    l = e.dilationWidth,
                    c = e.effectiveFilterDepth,
                    h = e.effectiveFilterHeight,
                    p = e.effectiveFilterWidth,
                    d = c - 1 - e.padInfo.front,
                    f = h - 1 - e.padInfo.top,
                    m = p - 1 - e.padInfo.left,
                    g = 1 / (t * n * s);
                this.userCode = `\n      const ivec3 pads = ivec3(${d}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        const rF = {
            kernelName: Oe,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a
                } = t, i = a, {
                    filterSize: o,
                    strides: u,
                    pad: l,
                    dimRoundingMode: c
                } = s, h = Ri(i.shape, o, u, [1, 1, 1], l, c), p = new sF(h);
                return n.runWebGLProgram(p, [r], i.dtype)
            }
        };
        const aF = {
            kernelName: De,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a
                } = t, i = a;
                LC([r, a], "avgPoolGrad");
                const {
                    filterSize: o,
                    strides: u,
                    pad: l
                } = s, c = Ai(i.shape, o, u, 1, l), h = new nF(c);
                return n.runWebGLProgram(h, [r], i.dtype)
            }
        };
        const iF = {
            kernelName: Me,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    a: r,
                    b: a
                } = t, {
                    transposeA: i,
                    transposeB: o
                } = s;
                return xR({
                    a: r,
                    b: a,
                    transposeA: i,
                    transposeB: o,
                    backend: n
                })
            }
        };
        class oF {
            constructor(e, t, n, s, r, a) {
                this.outputShape = [], this.variableNames = ["x", "mean", "variance"], Ga(e, t), Ga(e, n);
                let i = "0.0";
                null != s && (Ga(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
                let o = "1.0";
                null != r && (Ga(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `
            }
        }
        class uF {
            constructor(e, t, n, s, r, a) {
                this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], Ga(e, t), Ga(e, n);
                let i = "vec4(0.0)";
                null != s && (Ga(e, s), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
                let o = "vec4(1.0)";
                null != r && (Ga(e, r), this.variableNames.push("scale"), o = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `
            }
        }
        const lF = {
            kernelName: Tt,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                backend: t,
                attrs: n
            }) => {
                const {
                    x: s,
                    mean: r,
                    variance: a,
                    offset: i,
                    scale: o
                } = e;
                R(r.shape.length === a.shape.length, (() => "Batch normalization gradient requires mean and variance to have equal ranks.")), R(null == i || r.shape.length === i.shape.length, (() => "Batch normalization gradient requires mean and offset to have equal ranks.")), R(null == o || r.shape.length === o.shape.length, (() => "Batch normalization gradient requires mean and scale to have equal ranks."));
                let {
                    varianceEpsilon: u
                } = n;
                null == u && (u = .001);
                const l = [s, r, a];
                let c = null;
                null != i && (c = i.shape, l.push(i));
                let h = null;
                null != o && (h = o.shape, l.push(o));
                const p = de().getBool("WEBGL_PACK_NORMALIZATION") ? new uF(s.shape, r.shape, a.shape, c, h, u) : new oF(s.shape, r.shape, a.shape, c, h, u);
                return t.runWebGLProgram(p, l, l[0].dtype)
            }
        };
        class cF {
            constructor(e) {
                this.variableNames = ["source"], this.outputShape = e, this.rank = e.length;
                const t = nE(this.rank);
                this.customUniforms = [{
                    name: "start",
                    arrayIndex: this.rank,
                    type: "int"
                }];
                const n = function(e) {
                    if (1 === e) return "sourceLoc";
                    if (e <= 6) return hF.slice(0, e).map((e => "sourceLoc." + e)).join(",");
                    throw Error(`Slicing for rank ${e} is not yet supported`)
                }(this.rank);
                let s;
                s = `\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${hF[t]} = start[${t}] + coords.${hF[t]};`)).join("\n")}\n      `, this.userCode = `\n      void main() {\n        ${s}\n        setOutput(getSource(${n}));\n      }\n    `
            }
        }
        const hF = ["x", "y", "z", "w", "u", "v"];
        class pF {
            constructor(e) {
                this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.rank = e.length, this.customUniforms = [{
                    name: "start",
                    arrayIndex: this.rank,
                    type: "int"
                }];
                const t = nE(this.rank),
                    n = yA("coords", this.rank),
                    s = yA("sourceLoc", this.rank),
                    r = 1 === this.rank ? "sourceLoc" : `vec2(${s.slice(-2).join()})`,
                    a = `getChannel(getSource(${s.join()}), ${r})`,
                    i = `\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${a};\n        --${s[this.rank-1]};\n      }\n    `,
                    o = 1 === this.rank ? "" : `\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,
                    u = this.rank <= 4 ? `sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});` : e.map(((e, t) => `${s[t]} = ${n[t]} + start[${t}];`)).join("\n");
                this.userCode = `\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `
            }
        }

        function dF(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                begin: a,
                size: i
            } = s, [o, u] = li(r, a, i);
            if (Xa(r, o, u), 0 === O(u)) return n.makeTensorInfo(u, r.dtype, []);
            if (n.shouldExecuteOnCPU([r]) || "string" === r.dtype) {
                const e = n.texData.get(r.dataId),
                    t = nA(e.values, o, u, r.shape, r.dtype);
                return n.makeTensorInfo(u, r.dtype, t)
            }
            const {
                isPacked: l
            } = n.texData.get(r.dataId), c = oi(r.shape, o, u);
            if (l || !c) {
                const e = de().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new pF(u) : new cF(u),
                    t = [o];
                return n.runWebGLProgram(e, [r], r.dtype, t)
            }
            return n.uploadToGPU(r.dataId),
                function(e, t, n, s) {
                    const r = s.texData.get(e.dataId),
                        a = s.makeTensorInfo(n, e.dtype),
                        i = s.texData.get(a.dataId);
                    Object.assign(i, r), i.refCount = 1, i.shape = n, i.dtype = e.dtype;
                    let o = ui(t, ee(e.shape));
                    r.slice && (o += r.slice.flatOffset), i.slice = {
                        flatOffset: o,
                        origDataId: r.slice && r.slice.origDataId || e.dataId
                    };
                    const u = s.dataRefCount.get(i.slice.origDataId) || 1;
                    return s.dataRefCount.set(i.slice.origDataId, u + 1), a
                }(r, o, u, n)
        }
        const fF = {
                kernelName: zn,
                backendName: "webgl",
                kernelFunc: dF
            },
            mF = {
                kernelName: Le,
                backendName: "webgl",
                kernelFunc: e => {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        blockShape: a,
                        crops: i
                    } = s;
                    R(r.shape.length <= 4, (() => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));
                    const o = a.reduce(((e, t) => e * t)),
                        u = yc(r.shape, a, o),
                        l = bc(u.length, a.length),
                        c = xc(r.shape, a, o),
                        h = wc(i, a.length),
                        p = kc(c, i, a.length),
                        d = [],
                        f = oR({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                shape: u
                            }
                        }),
                        m = yR({
                            inputs: {
                                x: f
                            },
                            backend: n,
                            attrs: {
                                perm: l
                            }
                        }),
                        g = oR({
                            inputs: {
                                x: m
                            },
                            backend: n,
                            attrs: {
                                shape: c
                            }
                        }),
                        y = dF({
                            inputs: {
                                x: g
                            },
                            backend: n,
                            attrs: {
                                begin: h,
                                size: p
                            }
                        });
                    return d.push(f), d.push(m), d.push(g), d.forEach((e => n.disposeIntermediateTensorInfo(e))), y
                }
            };
        const gF = {
            kernelName: ze,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    weights: a
                } = t, {
                    size: i
                } = s, o = n.readSync(r.dataId), u = n.readSync(a.dataId), l = CE(o, u, a.dtype, a.shape, i);
                return n.makeTensorInfo([i], a.dtype, l)
            }
        };
        const yF = {
                kernelName: Be,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        s0: s,
                        s1: r
                    } = t, a = n.readSync(s.dataId), i = n.readSync(r.dataId), o = Ga(Array.from(a), Array.from(i));
                    return n.makeTensorInfo([o.length], "int32", Int32Array.from(o))
                }
            },
            bF = ZA({
                opSnippet: "return float(a != b);",
                cpuKernelImpl: XE,
                dtype: "bool"
            }),
            xF = {
                kernelName: cn,
                backendName: "webgl",
                kernelFunc: bF
            };

        function wF(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                input: s
            } = t;
            return PA({
                inputs: {
                    x: n.texData.get(s.dataId).complexTensorInfos.real
                },
                backend: n
            })
        }
        const kF = {
            kernelName: vn,
            backendName: "webgl",
            kernelFunc: wF
        };
        const vF = {
                kernelName: Pe,
                backendName: "webgl",
                kernelFunc: function e(t) {
                    const {
                        inputs: n,
                        backend: s,
                        attrs: r
                    } = t, {
                        x: a
                    } = n, {
                        dtype: i
                    } = r;
                    if ("complex64" === i) {
                        if ("complex64" === a.dtype) return PA({
                            inputs: {
                                x: a
                            },
                            backend: s
                        });
                        const t = Zo(a.shape),
                            n = e({
                                inputs: {
                                    x: a
                                },
                                backend: s,
                                attrs: {
                                    dtype: "float32"
                                }
                            }),
                            r = WA({
                                inputs: {
                                    real: n,
                                    imag: t
                                },
                                backend: s
                            });
                        return t.dispose(), s.disposeIntermediateTensorInfo(n), r
                    }
                    if ("complex64" === a.dtype) {
                        const t = wF({
                                inputs: {
                                    input: a
                                },
                                backend: s
                            }),
                            n = e({
                                inputs: {
                                    x: t
                                },
                                backend: s,
                                attrs: {
                                    dtype: i
                                }
                            });
                        return s.disposeIntermediateTensorInfo(t), n
                    }
                    if (!j(a.dtype, i)) {
                        const e = PA({
                            inputs: {
                                x: a
                            },
                            backend: s
                        });
                        return {
                            dataId: e.dataId,
                            shape: e.shape,
                            dtype: i
                        }
                    }
                    if ("int32" === i) return function(e, t) {
                        const n = new NA(e.shape, "return float(int(x));"),
                            s = t.runWebGLProgram(n, [e], "int32");
                        return {
                            dataId: s.dataId,
                            shape: s.shape,
                            dtype: s.dtype
                        }
                    }(a, s);
                    if ("bool" === i) {
                        const e = s.makeTensorInfo([], "bool", G("bool", 1)),
                            t = bF({
                                inputs: {
                                    a,
                                    b: e
                                },
                                backend: s
                            });
                        return s.disposeIntermediateTensorInfo(e), t
                    }
                    throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)
                }
            },
            IF = "return ceil(x);",
            NF = JA({
                opSnippet: IF,
                packedOpSnippet: IF,
                cpuKernelImpl: AE
            }),
            SF = {
                kernelName: Ue,
                backendName: "webgl",
                kernelFunc: NF
            };
        class TF {
            constructor(e) {
                this.variableNames = ["A"], this.customUniforms = [{
                    name: "minVal",
                    type: "float"
                }, {
                    name: "maxVal",
                    type: "float"
                }], this.outputShape = e, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
            }
        }
        class $F {
            constructor(e) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                    name: "minVal",
                    type: "float"
                }, {
                    name: "maxVal",
                    type: "float"
                }], this.outputShape = e, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
            }
        }
        const CF = {
            kernelName: We,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    clipValueMin: a,
                    clipValueMax: i
                } = s;
                let o;
                o = de().getBool("WEBGL_PACK_CLIP") ? new $F(r.shape) : new TF(r.shape);
                const u = [
                    [a],
                    [i]
                ];
                return n.runWebGLProgram(o, [r], r.dtype, u)
            }
        };
        class EF {
            constructor(e) {
                this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
            }
        }

        function AF(e, t) {
            return {
                dataId: t.dataId,
                dtype: t.dtype,
                shape: e.shape
            }
        }
        const RF = {
            kernelName: Ge,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    x: s
                } = t, r = n.texData.get(s.dataId), a = new EF(s.shape), i = [AF(s, r.complexTensorInfos.real), AF(s, r.complexTensorInfos.imag)];
                return n.runWebGLProgram(a, i, i[0].dtype)
            }
        };
        class FF {
            constructor(e) {
                this.outputShape = [], this.outputShape = dc(e, 1), this.variableNames = e.map(((e, t) => `T${t}`));
                const t = new Array(e.length - 1);
                t[0] = e[0][1];
                for (let n = 1; n < t.length; n++) t[n] = t[n - 1] + e[n][1];
                const n = [`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];
                for (let e = 1; e < t.length; e++) {
                    const s = t[e - 1];
                    n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${s}));`)
                }
                const s = t.length,
                    r = t[t.length - 1];
                n.push(`else setOutput(getT${s}(yR, yC-${r}));`), this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `
            }
        }
        class DF {
            constructor(e, t) {
                this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = dc(e, t);
                const n = this.outputShape,
                    s = n.length,
                    r = nE(s),
                    a = yA("coords", s),
                    i = ["x", "y", "z", "w", "u", "v"].slice(0, s);
                this.variableNames = e.map(((e, t) => `T${t}`));
                const o = new Array(e.length - 1);
                o[0] = e[0][t];
                for (let n = 1; n < o.length; n++) o[n] = o[n - 1] + e[n][t];
                const u = i[t],
                    l = i.slice(-2),
                    c = i.join();
                let h = `if (${u} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;
                for (let e = 1; e < o.length; e++) {
                    const t = o[e - 1];
                    h += `\n        if (${u} < ${o[e]}  && ${u} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${_F(i,u,t)}),\n            vec2(${_F(l,u,t)}));\n        }`
                }
                const p = o.length,
                    d = o[o.length - 1];
                h += `\n        return getChannel(\n          getT${p}(${_F(i,u,d)}),\n          vec2(${_F(l,u,d)}));`, this.userCode = `\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[s-1]} = ${a[s-1]} + 1;\n        if (${a[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[s-2]} = ${a[s-2]} + 1;\n        if (${a[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[s-1]} = ${a[s-1]} - 1;\n        if (${a[s-2]} < ${n[s-2]} &&\n            ${a[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `
            }
        }

        function _F(e, t, n) {
            const s = e.indexOf(t);
            return e.map(((e, t) => t === s ? `${e} - ${n}` : e)).join()
        }

        function OF(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                input: s
            } = t;
            return PA({
                inputs: {
                    x: n.texData.get(s.dataId).complexTensorInfos.imag
                },
                backend: n
            })
        }
        const MF = {
            kernelName: Dt,
            backendName: "webgl",
            kernelFunc: OF
        };

        function LF(e, t, n) {
            const s = e[0].dtype;
            if ("complex64" === s) {
                const s = e.map((e => wF({
                        inputs: {
                            input: e
                        },
                        backend: n
                    }))),
                    r = e.map((e => OF({
                        inputs: {
                            input: e
                        },
                        backend: n
                    }))),
                    a = LF(s, t, n),
                    i = LF(r, t, n),
                    o = WA({
                        inputs: {
                            real: a,
                            imag: i
                        },
                        backend: n
                    });
                return s.forEach((e => n.disposeIntermediateTensorInfo(e))), r.forEach((e => n.disposeIntermediateTensorInfo(e))), n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(i), o
            }
            let r = n.shouldExecuteOnCPU(e);
            if ("string" === s && (r = !0), r) {
                const r = e.map((e => {
                        const s = O(e.shape.slice(t));
                        return oR({
                            inputs: {
                                x: e
                            },
                            backend: n,
                            attrs: {
                                shape: [-1, s]
                            }
                        })
                    })),
                    a = r.map((e => ({
                        vals: n.readSync(e.dataId),
                        shape: e.shape
                    }))),
                    i = dc(r.map((e => e.shape)), 1),
                    o = 1 === r[0].shape[0],
                    u = RE(a, i, s, o),
                    l = dc(e.map((e => e.shape)), t),
                    c = n.makeTensorInfo(l, s, u);
                return r.forEach((e => n.disposeIntermediateTensorInfo(e))), c
            }
            if (e.length > de().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                const s = Math.floor(e.length / 2),
                    r = LF(e.slice(0, s), t, n),
                    a = LF(e.slice(s), t, n),
                    i = LF([r, a], t, n);
                return n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(a), i
            }
            if (de().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && e[0].shape.length > 1) {
                const r = new DF(e.map((e => e.shape)), t);
                return n.runWebGLProgram(r, e, s)
            }
            const {
                tensors2D: a,
                outShape: i
            } = function(e, t, n) {
                const s = dc(e.map((e => e.shape)), t),
                    r = e.map((e => oR({
                        inputs: {
                            x: e
                        },
                        attrs: {
                            shape: [-1, O(e.shape.slice(t))]
                        },
                        backend: n
                    })));
                return {
                    tensors2D: r,
                    outShape: s
                }
            }(e, t, n), o = new FF(a.map((e => e.shape))), u = n.runWebGLProgram(o, a, s);
            a.forEach((e => n.disposeIntermediateTensorInfo(e)));
            const l = oR({
                inputs: {
                    x: u
                },
                attrs: {
                    shape: i
                },
                backend: n
            });
            return n.disposeIntermediateTensorInfo(u), l
        }

        function zF(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                axis: r
            } = s, a = W(r, t[0].shape)[0], i = dc(t.map((e => e.shape)), a);
            if (0 === O(i)) return n.makeTensorInfo(i, t[0].dtype, []);
            const o = t.filter((e => O(e.shape) > 0));
            if (1 === o.length) return PA({
                inputs: {
                    x: o[0]
                },
                backend: n
            });
            return pc(o.map((e => e.shape)), a), LF(o, a, n)
        }
        const BF = {
            kernelName: He,
            backendName: "webgl",
            kernelFunc: zF
        };
        class PF {
            constructor(e, t = !1, n = null, s = !1, r = !1) {
                this.variableNames = ["x", "W"], this.outputShape = e.outShape;
                const a = e.padInfo.top,
                    i = e.padInfo.left,
                    o = e.strideHeight,
                    u = e.strideWidth,
                    l = e.dilationHeight,
                    c = e.dilationWidth,
                    h = e.filterHeight,
                    p = e.filterWidth,
                    d = 4 * Math.floor(e.inChannels / 4),
                    f = e.inChannels % 4,
                    m = "channelsLast" === e.dataFormat,
                    g = m ? 1 : 2,
                    y = m ? 2 : 3,
                    b = m ? 3 : 1;
                let x = "",
                    w = "";
                n && (x = s ? `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }` : r ? `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }` : `\n          float activation(float x) {\n            ${n}\n          }\n        `, w = "result = activation(result);");
                const k = t ? "result += getBiasAtOutCoords();" : "";
                t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${d}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${d}) *\n                    getW(wR, wC, ${d}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${d}, xR, xC) *\n                    getW(wR, wC, ${d}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${d}, d2),\n                getW(wR, wC, ${d} + 1, d2),\n                getW(wR, wC, ${d} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${d}),\n                  getX(batch, xR, xC, ${d} + 1),\n                  getX(batch, xR, xC, ${d} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${d}, xR, xC),\n                  getX(batch, ${d} + 1, xR, xC),\n                  getX(batch, ${d} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${k}\n        ${w}\n        setOutput(result);\n      }\n    `
            }
        }
        class UF {
            constructor(e) {
                this.variableNames = ["x", "W"], this.outputShape = e.outShape;
                const t = e.padInfo.front,
                    n = e.padInfo.top,
                    s = e.padInfo.left,
                    r = e.strideDepth,
                    a = e.strideHeight,
                    i = e.strideWidth,
                    o = e.dilationDepth,
                    u = e.dilationHeight,
                    l = e.dilationWidth,
                    c = e.filterDepth,
                    h = e.filterHeight,
                    p = e.filterWidth,
                    d = 4 * Math.floor(e.inChannels / 4),
                    f = e.inChannels % 4;
                this.userCode = `\n      const ivec3 strides = ivec3(${r}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${d}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${d}) *\n                  getW(wF, wR, wC, ${d}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${d}),\n                  getX(batch, xF, xR, xC, ${d} + 1),\n                  getX(batch, xF, xR, xC, ${d} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${d}, d2),\n                  getW(wF, wR, wC, ${d} + 1, d2),\n                  getW(wF, wR, wC, ${d} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class WF {
            constructor(e, t) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                    name: "inputShape",
                    type: "ivec3"
                }, {
                    name: "pad",
                    type: "ivec2"
                }, {
                    name: "stride",
                    type: "ivec2"
                }, {
                    name: "dilation",
                    type: "ivec2"
                }, {
                    name: "inChannels",
                    type: "int"
                }, {
                    name: "itemsPerBlockRow",
                    type: "int"
                }, {
                    name: "outWidth",
                    type: "int"
                }], this.outputShape = e, this.enableShapeUniforms = lE(this.outputShape.length);
                const {
                    dataFormat: n
                } = t, s = BC(), r = "channelsLast" === n, a = r ? 0 : 1, i = r ? 1 : 2, o = this.enableShapeUniforms ? "if(blockIndex < outShape[1] && pos < outShape[0]) {" : `if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;
                let u = "";
                for (let e = 0; e <= 1; e++)
                    for (let t = 0; t <= 1; t++) u += `\n          blockIndex = rc.y + ${t};\n          pos = rc.x + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;
                this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${s.output} = result;\n      }\n    `
            }
        }

        function VF({
            x: e,
            filter: t,
            convInfo: n,
            backend: s,
            bias: r = null,
            preluActivationWeights: a = null,
            leakyreluAlpha: i = 0,
            activation: o = null
        }) {
            const u = e.shape,
                l = s.texData.get(e.dataId),
                c = n.inChannels,
                h = u[0] * u[1] * u[2],
                p = n.outChannels,
                d = "channelsLast" === n.dataFormat,
                f = !1,
                m = !1;
            let g;
            const y = [];
            if (null != a && !d && 3 === a.shape.length) {
                const e = yR({
                    inputs: {
                        x: a
                    },
                    backend: s,
                    attrs: {
                        perm: [1, 2, 0]
                    }
                });
                y.push(e), a = e
            }
            if (!((1 === h || 1 === p) && c > 1e3) && l.isPacked && d && null != l.texture && u[2] % 2 != 0 && M(l.shape.slice(-3), u.slice(-3))) {
                const c = u[0] * u[1] * (u[2] + 1),
                    h = {
                        dataId: e.dataId,
                        shape: [1, c, n.inChannels],
                        dtype: e.dtype
                    },
                    p = l.shape;
                l.shape = l.shape.slice(), l.shape[l.shape.length - 2]++, R(AC(l.shape, h.shape), (() => `packed reshape ${l.shape} to ${h.shape} isn't free`));
                const d = oR({
                    inputs: {
                        x: t
                    },
                    backend: s,
                    attrs: {
                        shape: [1, n.inChannels, n.outChannels]
                    }
                });
                y.push(d);
                const b = xR({
                        a: h,
                        b: d,
                        backend: s,
                        transposeA: f,
                        transposeB: m,
                        bias: r,
                        activation: o,
                        preluActivationWeights: a,
                        leakyreluAlpha: i
                    }),
                    x = s.texData.get(b.dataId);
                R(x.isPacked, (() => "batchMatMul result is expected to be packed")), l.shape = p, x.shape = n.outShape, g = PA({
                    inputs: {
                        x: b
                    },
                    backend: s
                }), g.shape = n.outShape, y.push(b)
            } else {
                const u = d ? e : yR({
                        inputs: {
                            x: e
                        },
                        backend: s,
                        attrs: {
                            perm: [0, 2, 3, 1]
                        }
                    }),
                    l = u.shape,
                    c = oR({
                        inputs: {
                            x: u
                        },
                        backend: s,
                        attrs: {
                            shape: [1, l[0] * l[1] * l[2], n.inChannels]
                        }
                    }),
                    h = oR({
                        inputs: {
                            x: t
                        },
                        backend: s,
                        attrs: {
                            shape: [1, n.inChannels, n.outChannels]
                        }
                    }),
                    p = xR({
                        a: c,
                        b: h,
                        transposeA: f,
                        transposeB: m,
                        backend: s,
                        bias: r,
                        activation: o,
                        preluActivationWeights: a,
                        leakyreluAlpha: i
                    }),
                    b = oR({
                        inputs: {
                            x: p
                        },
                        backend: s,
                        attrs: {
                            shape: [n.batchSize, n.outHeight, n.outWidth, n.outChannels]
                        }
                    });
                g = d ? b : yR({
                    inputs: {
                        x: b
                    },
                    backend: s,
                    attrs: {
                        perm: [0, 3, 1, 2]
                    }
                }), d || (y.push(u), y.push(b)), y.push(c), y.push(h), y.push(p)
            }
            for (const e of y) s.disposeIntermediateTensorInfo(e);
            return g
        }

        function GF({
            x: e,
            filter: t,
            convInfo: n,
            backend: s,
            bias: r = null,
            preluActivationWeights: a = null,
            leakyreluAlpha: i = 0,
            activation: o = null
        }) {
            const {
                filterWidth: u,
                filterHeight: l,
                inChannels: c,
                outWidth: h,
                outHeight: p,
                dataFormat: d
            } = n, f = "channelsLast" === d, m = u * l * c, g = p * h, y = [m, g], b = [];
            if (null != a && !f && 3 === a.shape.length) {
                const e = yR({
                    inputs: {
                        x: a
                    },
                    backend: s,
                    attrs: {
                        perm: [1, 2, 0]
                    }
                });
                b.push(e), a = e
            }
            const x = oR({
                    inputs: {
                        x: e
                    },
                    backend: s,
                    attrs: {
                        shape: e.shape.slice(1)
                    }
                }),
                w = oR({
                    inputs: {
                        x: t
                    },
                    backend: s,
                    attrs: {
                        shape: [1, m, O(t.shape) / m]
                    }
                });
            b.push(x), b.push(w);
            const k = new WF(y, n),
                v = [x.shape, [n.padInfo.top, n.padInfo.left],
                    [n.strideHeight, n.strideWidth],
                    [n.dilationHeight, n.dilationWidth],
                    [n.inChannels],
                    [n.filterWidth * n.inChannels],
                    [n.outWidth]
                ],
                I = s.runWebGLProgram(k, [x], "float32", v),
                N = oR({
                    inputs: {
                        x: I
                    },
                    backend: s,
                    attrs: {
                        shape: [1, y[0], y[1]]
                    }
                });
            b.push(I), b.push(N);
            const S = null != r,
                T = null != a,
                $ = "leakyrelu" === o,
                C = o ? QA(o, !0) : null,
                E = new eR(N.shape, w.shape, [1, g, n.outChannels], !0, !1, S, C, T, $),
                A = [N, w];
            if (r && A.push(r), T && A.push(a), $) {
                const e = s.makeTensorInfo([], "float32", qs(i, "float32"));
                A.push(e), b.push(e)
            }
            const R = s.runWebGLProgram(E, A, "float32"),
                F = oR({
                    inputs: {
                        x: R
                    },
                    backend: s,
                    attrs: {
                        shape: [1, p, h, n.outChannels]
                    }
                }),
                D = f ? F : yR({
                    inputs: {
                        x: F
                    },
                    backend: s,
                    attrs: {
                        perm: [0, 3, 1, 2]
                    }
                });
            f || b.push(F), b.push(R);
            for (const e of b) s.disposeIntermediateTensorInfo(e);
            return D
        }
        const HF = {
            kernelName: je,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a
                } = t, {
                    strides: i,
                    pad: o,
                    dataFormat: u,
                    dilations: l,
                    dimRoundingMode: c
                } = s, h = Ui(u), p = Fi(r.shape, a.shape, i, l, o, c, !1, h);
                let d;
                if (1 !== p.filterHeight || 1 !== p.filterWidth || 1 !== p.dilationHeight || 1 !== p.dilationWidth || 1 !== p.strideHeight || 1 !== p.strideWidth || "SAME" !== p.padInfo.type && "VALID" !== p.padInfo.type)
                    if (de().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) d = GF({
                        x: r,
                        filter: a,
                        convInfo: p,
                        backend: n
                    });
                    else {
                        const e = new PF(p);
                        d = n.runWebGLProgram(e, [r, a], "float32")
                    }
                else d = VF({
                    x: r,
                    filter: a,
                    convInfo: p,
                    backend: n
                });
                const f = oR({
                    inputs: {
                        x: d
                    },
                    backend: n,
                    attrs: {
                        shape: p.outShape
                    }
                });
                return n.disposeIntermediateTensorInfo(d), f
            }
        };
        class jF {
            constructor(e) {
                this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
                const t = e.strideHeight,
                    n = e.strideWidth,
                    s = e.padInfo.top,
                    r = e.padInfo.left,
                    a = "channelsLast" === e.dataFormat;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${s};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${a}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class qF {
            constructor(e) {
                this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
                const t = e.filterHeight,
                    n = e.filterWidth,
                    s = e.strideHeight,
                    r = e.strideWidth,
                    a = "channelsLast" === e.dataFormat,
                    i = t - 1 - e.padInfo.top,
                    o = n - 1 - e.padInfo.left,
                    u = a ? 1 : 2,
                    l = a ? 2 : 3,
                    c = a ? 3 : 1;
                this.userCode = `\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class KF {
            constructor(e) {
                this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
                const t = e.strideDepth,
                    n = e.strideHeight,
                    s = e.strideWidth,
                    r = e.padInfo.front,
                    a = e.padInfo.top,
                    i = e.padInfo.left;
                this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${s} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class XF {
            constructor(e) {
                this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
                const t = e.filterDepth,
                    n = e.filterHeight,
                    s = e.filterWidth,
                    r = e.strideDepth,
                    a = e.strideHeight,
                    i = e.strideWidth,
                    o = t - 1 - e.padInfo.front,
                    u = n - 1 - e.padInfo.top,
                    l = s - 1 - e.padInfo.left;
                this.userCode = `\n      const ivec3 pads = ivec3(${o}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        const YF = {
            kernelName: qe,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    dy: a
                } = t, {
                    strides: i,
                    pad: o,
                    dataFormat: u,
                    dimRoundingMode: l,
                    filterShape: c
                } = s, h = Ui(u), p = Fi(r.shape, c, i, 1, o, l, !1, h), d = new jF(p);
                return n.runWebGLProgram(d, [r, a], "float32")
            }
        };
        const JF = {
            kernelName: Ke,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    filter: a
                } = t, {
                    inputShape: i,
                    strides: o,
                    pad: u,
                    dataFormat: l,
                    dimRoundingMode: c
                } = s, h = Ui(l), p = Fi(i, a.shape, o, 1, u, c, !1, h), d = new qF(p);
                return n.runWebGLProgram(d, [r, a], "float32")
            }
        };
        const ZF = {
            kernelName: Xe,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a
                } = t, {
                    strides: i,
                    pad: o,
                    dilations: u
                } = s, l = Di(r.shape, a.shape, i, u, o), c = new UF(l);
                return n.runWebGLProgram(c, [r, a], "float32")
            }
        };
        const QF = {
            kernelName: Ye,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    dy: a
                } = t, {
                    strides: i,
                    pad: o,
                    filterShape: u
                } = s, l = Di(r.shape, u, i, 1, o), c = new KF(l);
                return n.runWebGLProgram(c, [r, a], "float32")
            }
        };
        const eD = {
                kernelName: Je,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        dy: r,
                        filter: a
                    } = t, {
                        pad: i,
                        strides: o,
                        inputShape: u
                    } = s, l = Di(u, a.shape, o, 1, i), c = new XF(l);
                    return n.runWebGLProgram(c, [r, a], "float32")
                }
            },
            tD = JA({
                opSnippet: YA + "\n  return cos(x);\n"
            }),
            nD = {
                kernelName: Ze,
                backendName: "webgl",
                kernelFunc: tD
            },
            sD = JA({
                opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
            }),
            rD = {
                kernelName: Qe,
                backendName: "webgl",
                kernelFunc: sD
            };
        class aD {
            constructor(e, t, n, s, r) {
                this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
                const [a, i, o, u] = e, [l] = t, [c, h] = n;
                this.outputShape = [l, c, h, u];
                const p = "bilinear" === s ? 1 : 0,
                    [d, f] = [i - 1 + ".0", o - 1 + ".0"],
                    [m, g, y] = c > 1 ? ["" + (i - 1) / (c - 1), "(y2-y1) * height_ratio", `y1*${d} + float(y)*(height_scale)`] : ["0.0", "0.0", `0.5 * (y1+y2) * ${d}`],
                    [b, x, w] = h > 1 ? ["" + (o - 1) / (h - 1), "(x2-x1) * width_ratio", `x1*${f} + float(x)*(width_scale)`] : ["0.0", "0.0", `0.5 * (x1+x2) * ${f}`];
                this.userCode = `\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${d} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `
            }
        }
        const iD = {
            kernelName: nt,
            backendName: "webgl",
            kernelFunc: e => {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    image: r,
                    boxes: a,
                    boxInd: i
                } = t, {
                    cropSize: o,
                    method: u,
                    extrapolationValue: l
                } = s, c = new aD(r.shape, a.shape, o, u, l);
                return n.runWebGLProgram(c, [r, a, i], "float32")
            }
        };
        var oD;
        ! function(e) {
            e.Prod = "*", e.Sum = "+"
        }(oD || (oD = {}));
        class uD {
            constructor(e, t, n, s) {
                this.op = e, this.outputShape = t, this.variableNames = ["x"], this.customUniforms = [{
                    name: "index",
                    type: "float"
                }];
                const r = this.outputShape.length,
                    a = this.op === oD.Prod ? "1.0" : "0.0",
                    i = n ? a : `getX(${lD(r,"coords",this.op)})`,
                    o = this.outputShape[this.outputShape.length - 1];
                let u = "",
                    l = "";
                n ? (u = s ? "end != " + (o - 1) : "end != 0", l = s ? "end + 1" : "end - 1") : (u = s ? `end + pow2 < ${o}` : "end >= pow2", l = s ? "end + pow2" : "end - pow2"), this.userCode = `\n      void main() {\n        ${nE(r)} coords = getOutputCoords();\n        int end = ${cD(r,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${l};\n          ${cD(r,"coords",this.op)} = idx;\n          val ${this.op}= getX(${lD(r,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `
            }
        }

        function lD(e, t, n) {
            if (1 === e) return `${t}`;
            if (2 === e) return `${t}.x, ${t}.y`;
            if (3 === e) return `${t}.x, ${t}.y, ${t}.z`;
            if (4 === e) return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
            throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)
        }

        function cD(e, t, n) {
            if (1 === e) return `${t}`;
            if (2 === e) return `${t}.y`;
            if (3 === e) return `${t}.z`;
            if (4 === e) return `${t}.w`;
            throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)
        }

        function hD(e, t, n, s, r, a) {
            const i = t.shape.length,
                o = Go([s], i);
            let u = t;
            null != o && (u = yR({
                inputs: {
                    x: t
                },
                backend: n,
                attrs: {
                    perm: o
                }
            }));
            const l = jo(1, i)[0];
            if (l !== i - 1) throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);
            const c = u.shape[l];
            let h = PA({
                inputs: {
                    x: u
                },
                backend: n
            });
            for (let t = 0; t <= Math.ceil(Math.log2(c)) - 1; t++) {
                const s = new uD(e, u.shape, !1, a),
                    r = [
                        [t]
                    ],
                    i = h;
                h = n.runWebGLProgram(s, [h], h.dtype, r), n.disposeIntermediateTensorInfo(i)
            }
            if (r) {
                const t = new uD(e, u.shape, r, a),
                    s = h;
                h = n.runWebGLProgram(t, [h], h.dtype), n.disposeIntermediateTensorInfo(s)
            }
            if (null != o) {
                const e = yR({
                    inputs: {
                        x: h
                    },
                    backend: n,
                    attrs: {
                        perm: Ho(o)
                    }
                });
                return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(u), e
            }
            return h
        }
        const pD = {
            kernelName: et,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    exclusive: i,
                    reverse: o
                } = s;
                return hD(oD.Prod, r, n, a, i, o)
            }
        };
        const dD = {
            kernelName: tt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    axis: a,
                    exclusive: i,
                    reverse: o
                } = s;
                return hD(oD.Sum, r, n, a, i, o)
            }
        };
        const fD = {
            kernelName: st,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    weights: a
                } = t, {
                    size: i,
                    binaryOutput: o
                } = s;
                if (1 === r.shape.length) {
                    const e = n.readSync(r.dataId),
                        t = n.readSync(a.dataId),
                        s = CE(e, t, a.dtype, a.shape, i);
                    return n.makeTensorInfo([i], a.dtype, s)
                }
                if (2 === r.shape.length) {
                    const e = n.bufferSync(r),
                        t = n.bufferSync(a),
                        s = EE(e, t, i, o);
                    return n.makeTensorInfo(s.shape, a.dtype, s.values)
                }
                throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)
            }
        };
        class mD {
            constructor(e, t, n) {
                this.variableNames = ["x"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = n, this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `
            }
            getHeightCoordString() {
                return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
            }
            getWidthCoordString() {
                return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
            }
            getDepthCoordString() {
                return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
            }
            getOutputDepthSize() {
                return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
            }
            getInputSamplingString() {
                return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
            }
        }
        const gD = {
            kernelName: rt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    blockSize: a,
                    dataFormat: i
                } = s, o = r.shape[0], u = ("NHWC" === i ? r.shape[1] : r.shape[2]) * a, l = ("NHWC" === i ? r.shape[2] : r.shape[3]) * a, c = ("NHWC" === i ? r.shape[3] : r.shape[1]) / (a * a), h = new mD("NHWC" === i ? [o, u, l, c] : [o, c, u, l], a, i);
                return n.runWebGLProgram(h, [r], r.dtype)
            }
        };
        class yD {
            constructor(e, t = !1, n = null, s = !1, r = !1) {
                this.variableNames = ["x", "W"], this.customUniforms = [{
                    name: "pads",
                    type: "ivec2"
                }, {
                    name: "strides",
                    type: "ivec2"
                }, {
                    name: "dilations",
                    type: "ivec2"
                }, {
                    name: "inDims",
                    type: "ivec2"
                }], this.outputShape = e.outShape, this.enableShapeUniforms = lE(this.outputShape.length);
                const a = e.filterHeight,
                    i = e.filterWidth,
                    o = e.outChannels / e.inChannels;
                let u = "",
                    l = "";
                n && (u = s ? `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }` : r ? `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }` : `\n          float activation(float x) {\n            ${n}\n          }\n        `, l = "result = activation(result);");
                const c = t ? "result += getBiasAtOutCoords();" : "";
                t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `
            }
        }
        class bD {
            constructor(e, t = !1, n = null, s = !1, r = !1) {
                this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                    name: "pads",
                    type: "ivec2"
                }, {
                    name: "strides",
                    type: "ivec2"
                }, {
                    name: "dilations",
                    type: "ivec2"
                }, {
                    name: "inDims",
                    type: "ivec2"
                }], this.outputShape = e.outShape, this.enableShapeUniforms = lE(this.outputShape.length);
                const a = e.outChannels / e.inChannels,
                    i = e.padInfo.left,
                    o = e.strideWidth,
                    u = e.dilationWidth,
                    l = e.filterHeight,
                    c = e.filterWidth,
                    h = c;
                let p = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";
                for (let e = 0; e < c; e++) p += `\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;
                p += `\n    for (int r = 0; r < ${l}; r++) {\n      `;
                for (let e = 0; e < c; e++) p += `\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;
                p += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
                for (let e = 0; e < (h + 1) / 2; e++) {
                    const t = 2 * e;
                    if (p += `\n          xC = xCCorner + ${t*u};\n          `, 1 === o) {
                        if (t < c && (i % 2 == 1 ? (p += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `, p += 1 === u && t > 0 ? `\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                ` : `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `) : p += `\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `, t + 1 < c)) {
                            const e = i % 2 == 0 ? E(u) : u;
                            u % 2 == 0 && i % 2 == 1 || u % 2 != 0 && i % 2 != 1 ? (p += `\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `, u > 1 && (p += `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                      xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${t}Ready = 1;\n                    }\n                    `), p += `\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                  `) : p += 1 === e ? `\n                    xC${t+1} = xTexelC${t};\n                    ` : `\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `
                        }
                    } else t < c && (i % 2 == 1 ? (p += `\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `, t + 1 < c && (p += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)) : (p += `\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `, t + 1 < c && (p += `\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));
                    t < c && (p += `\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `, t + 1 < c && (p += `\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))
                }
                p += "\n    }\n  ", p += "\n      }\n    ";
                let d = "",
                    f = "";
                n && (d = s ? `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }` : r ? `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }` : `vec4 activation(vec4 x) {\n          ${n}\n        }`, f = "result = activation(result);");
                const m = t ? "result += getBiasAtOutCoords();" : "";
                t && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), r && this.variableNames.push("leakyreluAlpha"), this.userCode = `\n      ${d}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `
            }
        }
        const xD = {
            kernelName: at,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a
                } = t, {
                    strides: i,
                    pad: o,
                    dilations: u,
                    dimRoundingMode: l
                } = s;
                let c = u;
                null == c && (c = [1, 1]), R(Pi(i, c), (() => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));
                const h = Fi(r.shape, a.shape, i, c, o, l, !0);
                let p;
                p = de().getBool("WEBGL_PACK_DEPTHWISECONV") && h.strideWidth <= 2 && h.outChannels / h.inChannels == 1 ? new bD(h) : new yD(h);
                const d = [
                    [h.padInfo.top, h.padInfo.left],
                    [h.strideHeight, h.strideWidth],
                    [h.dilationHeight, h.dilationWidth],
                    [h.inHeight, h.inWidth]
                ];
                return n.runWebGLProgram(p, [r, a], "float32", d)
            }
        };
        class wD {
            constructor(e) {
                this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
                const t = e.strideHeight,
                    n = e.strideWidth,
                    s = e.padInfo.top,
                    r = e.padInfo.left,
                    a = e.outChannels / e.inChannels;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${s};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class kD {
            constructor(e) {
                this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
                const t = e.filterHeight,
                    n = e.filterWidth,
                    s = e.strideHeight,
                    r = e.strideWidth,
                    a = t - 1 - e.padInfo.top,
                    i = n - 1 - e.padInfo.left,
                    o = e.outChannels / e.inChannels;
                this.userCode = `\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        const vD = {
            kernelName: it,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    dy: a
                } = t, {
                    strides: i,
                    dilations: o,
                    pad: u,
                    dimRoundingMode: l,
                    filterShape: c
                } = s, h = Fi(r.shape, c, i, o, u, l, !0), p = new wD(h);
                return n.runWebGLProgram(p, [r, a], "float32")
            }
        };
        const ID = {
            kernelName: ot,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    filter: a
                } = t, {
                    strides: i,
                    dilations: o,
                    pad: u,
                    dimRoundingMode: l,
                    inputShape: c
                } = s, h = Fi(c, a.shape, i, o, u, l, !0), p = new kD(h);
                return n.runWebGLProgram(p, [r, a], "float32")
            }
        };
        class ND {
            constructor(e) {
                this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
            }
        }
        const SD = {
            kernelName: ut,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    x: s
                } = t, r = [...s.shape, ...s.shape], a = O(s.shape), i = oR({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        shape: [a]
                    }
                }), o = new ND(a), u = n.runWebGLProgram(o, [i], i.dtype), l = oR({
                    inputs: {
                        x: u
                    },
                    backend: n,
                    attrs: {
                        shape: r
                    }
                });
                return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(u), l
            }
        };
        class TD {
            constructor(e) {
                this.variableNames = ["x", "W"], this.outputShape = e.outShape;
                const {
                    inHeight: t,
                    inWidth: n,
                    padInfo: s,
                    strideHeight: r,
                    strideWidth: a,
                    filterHeight: i,
                    filterWidth: o,
                    dilationHeight: u,
                    dilationWidth: l
                } = e, {
                    top: c,
                    left: h
                } = s;
                this.userCode = `\n      const ivec2 strides = ivec2(${r}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `
            }
        }
        const $D = {
            kernelName: lt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a
                } = t, {
                    strides: i,
                    pad: o,
                    dilations: u
                } = s, l = Ei(r.shape, a.shape, i, o, "NHWC", u);
                let c;
                const h = new TD(l);
                c = n.runWebGLProgram(h, [r, a], "float32");
                const p = oR({
                    inputs: {
                        x: c
                    },
                    backend: n,
                    attrs: {
                        shape: l.outShape
                    }
                });
                return n.disposeIntermediateTensorInfo(c), p
            }
        };
        const CD = {
                kernelName: dt,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        equation: r
                    } = s, a = t, {
                        allDims: i,
                        summedDims: o,
                        idDims: u
                    } = jc(r, a.length);
                    Kc(i.length, u, a);
                    const {
                        path: l,
                        steps: c
                    } = Xc(o, u), h = c.length;
                    let p = null,
                        d = i.length;
                    const f = [];
                    for (let e = 0; e < h; ++e) {
                        for (const t of c[e]) {
                            const {
                                permutationIndices: e,
                                expandDims: s
                            } = qc(d, u[t]);
                            let r;
                            Yc(e) ? r = a[t] : (r = yR({
                                inputs: {
                                    x: a[t]
                                },
                                backend: n,
                                attrs: {
                                    perm: e
                                }
                            }), f.push(r));
                            const i = r.shape.slice();
                            for (let e = 0; e < s.length; ++e) i.splice(s[e], 0, 1);
                            M(r.shape, i) || (r = oR({
                                inputs: {
                                    x: r
                                },
                                backend: n,
                                attrs: {
                                    shape: i
                                }
                            }), f.push(r)), null === p ? p = r : (p = aR({
                                inputs: {
                                    a: r,
                                    b: p
                                },
                                backend: n
                            }), f.push(p))
                        }
                        e < h - 1 && (l[e] >= 0 && (p = mR({
                            inputs: {
                                x: p
                            },
                            backend: n,
                            attrs: {
                                axis: l[e] - (i.length - d),
                                keepDims: !1
                            }
                        }), f.push(p)), d--)
                    }
                    for (const e of f) e !== p && n.disposeIntermediateTensorInfo(e);
                    return p
                }
            },
            ED = JA({
                opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
                packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
            }),
            AD = {
                kernelName: ft,
                backendName: "webgl",
                kernelFunc: ED
            },
            RD = {
                kernelName: mt,
                backendName: "webgl",
                kernelFunc: e => {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        dy: s,
                        y: r
                    } = t, a = de().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BA("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", s.shape, r.shape) : new LA("return (b >= 1.0) ? a : a * (b + 1.0);", s.shape, r.shape);
                    return n.runWebGLProgram(a, [s, r], s.dtype)
                }
            },
            FD = ZA({
                opSnippet: "return float(a == b);",
                packedOpSnippet: "\n  return vec4(equal(a, b));\n",
                dtype: "bool",
                cpuKernelImpl: FE
            }),
            DD = {
                kernelName: yt,
                backendName: "webgl",
                kernelFunc: FD
            },
            _D = JA({
                opSnippet: `\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Cc};\n  float a1 = ${Ec};\n  float a2 = ${Ac};\n  float a3 = ${Rc};\n  float a4 = ${Fc};\n  float a5 = ${Dc};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`
            }),
            OD = {
                kernelName: gt,
                backendName: "webgl",
                kernelFunc: _D
            },
            MD = JA({
                opSnippet: YA + "\n  return exp(x);\n",
                packedOpSnippet: "\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
                cpuKernelImpl: DE,
                dtype: "float32"
            }),
            LD = {
                kernelName: bt,
                backendName: "webgl",
                kernelFunc: MD
            };

        function zD(e) {
            const {
                inputs: t,
                attrs: n,
                backend: s
            } = e, {
                dim: r
            } = n, {
                input: a
            } = t, i = a.shape.length, o = a.shape.slice();
            let u = r;
            return r < 0 && (R(-(i + 1) <= r, (() => `Axis must be in the interval [${-(i+1)}, ${i}]`)), u = i + r + 1), o.splice(u, 0, 1), oR({
                inputs: {
                    x: a
                },
                backend: s,
                attrs: {
                    shape: o
                }
            })
        }
        const BD = {
                kernelName: xt,
                backendName: "webgl",
                kernelFunc: zD
            },
            PD = "return exp(x) - 1.0;",
            UD = JA({
                opSnippet: PD,
                packedOpSnippet: PD,
                cpuKernelImpl: _E
            }),
            WD = {
                kernelName: wt,
                backendName: "webgl",
                kernelFunc: UD
            };
        class VD {
            constructor(e, t, n) {
                this.variableNames = ["real", "imag"];
                const s = t[1];
                this.outputShape = t;
                const r = n ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`,
                    a = n ? `${s}.0` : "1.0";
                let i;
                if ("real" === e) i = "return real * expR - imag * expI;";
                else {
                    if ("imag" !== e) throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);
                    i = "return real * expI + imag * expR;"
                }
                this.userCode = `\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `
            }
        }

        function GD(e, t, n) {
            const s = n.texData.get(e.dataId),
                r = O(e.shape),
                a = e.shape[e.shape.length - 1],
                i = oR({
                    inputs: {
                        x: e
                    },
                    backend: n,
                    attrs: {
                        shape: [r / a, a]
                    }
                }),
                o = i.shape,
                u = new VD("real", o, t),
                l = new VD("imag", o, t),
                c = [{
                    dataId: s.complexTensorInfos.real.dataId,
                    dtype: s.complexTensorInfos.real.dtype,
                    shape: o
                }, {
                    dataId: s.complexTensorInfos.imag.dataId,
                    dtype: s.complexTensorInfos.imag.dtype,
                    shape: o
                }],
                h = n.runWebGLProgram(u, c, "float32"),
                p = n.runWebGLProgram(l, c, "float32"),
                d = WA({
                    inputs: {
                        real: h,
                        imag: p
                    },
                    backend: n
                });
            n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p);
            const f = oR({
                inputs: {
                    x: d
                },
                backend: n,
                attrs: {
                    shape: e.shape
                }
            });
            return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(d), f
        }
        const HD = {
            kernelName: kt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    input: s
                } = t;
                return GD(s, !1, n)
            }
        };
        class jD {
            constructor(e, t) {
                this.outputShape = [], this.customUniforms = [{
                    name: "value",
                    type: "float"
                }], this.variableNames = ["x"], this.outputShape = e, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
            }
        }

        function qD(e) {
            const {
                backend: t,
                attrs: n
            } = e, {
                shape: s,
                value: r
            } = n;
            let {
                dtype: a
            } = n;
            if (a = a || J(r), "string" === a) {
                const e = H(a, O(s));
                return e.fill(r), t.makeTensorInfo(s, a, e)
            } {
                const e = new jD(s, r),
                    n = [
                        [r]
                    ];
                return t.runWebGLProgram(e, [], a, n)
            }
        }
        const KD = {
            kernelName: vt,
            backendName: "webgl",
            kernelFunc: qD
        };
        class XD {
            constructor(e) {
                this.variableNames = ["Image"], this.outputShape = [];
                const t = e[2];
                this.outputShape = e, this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `
            }
        }
        const YD = {
                kernelName: It,
                backendName: "webgl",
                kernelFunc: ({
                    inputs: e,
                    backend: t
                }) => {
                    const {
                        image: n
                    } = e, s = t, r = new XD(n.shape);
                    return s.runWebGLProgram(r, [n], n.dtype)
                }
            },
            JD = "return floor(x);",
            ZD = JA({
                opSnippet: JD,
                packedOpSnippet: JD,
                cpuKernelImpl: OE
            }),
            QD = {
                kernelName: Nt,
                backendName: "webgl",
                kernelFunc: ZD
            },
            e_ = ZA({
                opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
                packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
                dtype: "int32"
            }),
            t_ = {
                kernelName: St,
                backendName: "webgl",
                kernelFunc: e_
            };
        class n_ {
            constructor(e) {
                this.variableNames = ["A"];
                const t = BC(),
                    [n, s] = e;
                this.outputShape = e, this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `
            }
        }
        class s_ {
            constructor(e) {
                this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
                const t = BC(),
                    [n, s] = e;
                this.outputShape = e, this.userCode = `\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `
            }
        }
        const r_ = {
            kernelName: bs,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e;
                let {
                    pixels: r
                } = t;
                const {
                    numChannels: a
                } = s, i = "undefined" != typeof HTMLVideoElement && r instanceof HTMLVideoElement, o = "undefined" != typeof HTMLImageElement && r instanceof HTMLImageElement, [u, l] = i ? [r.videoWidth, r.videoHeight] : [r.width, r.height], c = [l, u], h = [l, u, a];
                (o || i) && (null == a_ && (a_ = document.createElement("canvas").getContext("2d")), a_.canvas.width = u, a_.canvas.height = l, a_.drawImage(r, 0, 0, u, l), r = a_.canvas);
                const p = n.makeTensorInfo(c, "int32");
                n.texData.get(p.dataId).usage = oC.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId), r);
                const d = de().getBool("WEBGL_PACK") ? new s_(h) : new n_(h),
                    f = n.runWebGLProgram(d, [p], "int32");
                return n.disposeData(p.dataId), f
            }
        };
        let a_;
        const i_ = {
            kernelName: ks,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a,
                    bias: i,
                    preluActivationWeights: o
                } = t, {
                    strides: u,
                    pad: l,
                    dataFormat: c,
                    dilations: h,
                    dimRoundingMode: p,
                    activation: d,
                    leakyreluAlpha: f
                } = s, m = Ui(c), g = Fi(r.shape, a.shape, u, h, l, p, !1, m);
                let y;
                const b = [];
                if (1 !== g.filterHeight || 1 !== g.filterWidth || 1 !== g.dilationHeight || 1 !== g.dilationWidth || 1 !== g.strideHeight || 1 !== g.strideWidth || "SAME" !== g.padInfo.type && "VALID" !== g.padInfo.type)
                    if (de().getBool("WEBGL_CONV_IM2COL") && 1 === r.shape[0]) y = GF({
                        x: r,
                        filter: a,
                        convInfo: g,
                        backend: n,
                        bias: i,
                        activation: d,
                        preluActivationWeights: o,
                        leakyreluAlpha: f
                    });
                    else {
                        const e = null != i,
                            t = null != o,
                            s = "leakyrelu" === d,
                            u = d ? QA(d, !1) : null,
                            l = new PF(g, e, u, t, s),
                            h = [r, a],
                            p = (e, t) => {
                                if ("NCHW" === t && 1 === e.shape.length && 1 !== e.shape[0]) {
                                    const t = oR({
                                        inputs: {
                                            x: e
                                        },
                                        backend: n,
                                        attrs: {
                                            shape: [e.shape[0], 1, 1]
                                        }
                                    });
                                    return b.push(t), t
                                }
                                return e
                            };
                        if (e && h.push(p(i, c)), t && h.push(p(o, c)), s) {
                            const e = n.makeTensorInfo([], "float32", qs(f, "float32"));
                            h.push(e), b.push(e)
                        }
                        y = n.runWebGLProgram(l, h, "float32")
                    }
                else y = VF({
                    x: r,
                    filter: a,
                    convInfo: g,
                    backend: n,
                    bias: i,
                    activation: d,
                    preluActivationWeights: o,
                    leakyreluAlpha: f
                });
                const x = oR({
                    inputs: {
                        x: y
                    },
                    backend: n,
                    attrs: {
                        shape: g.outShape
                    }
                });
                return b.push(y), b.forEach((e => n.disposeIntermediateTensorInfo(e))), x
            }
        };
        const o_ = {
            kernelName: vs,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    filter: a,
                    bias: i,
                    preluActivationWeights: o
                } = t, {
                    strides: u,
                    pad: l,
                    dilations: c,
                    dimRoundingMode: h,
                    activation: p,
                    leakyreluAlpha: d
                } = s, f = [];
                let m = c;
                null == m && (m = [1, 1]), R(Pi(u, m), (() => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`));
                const g = Fi(r.shape, a.shape, u, m, l, h, !0),
                    y = de().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels == 1,
                    b = p ? QA(p, y) : null,
                    x = [r, a],
                    w = null != i,
                    k = null != o,
                    v = "leakyrelu" === p;
                if (w && x.push(i), k && x.push(o), v) {
                    const e = n.makeTensorInfo([], "float32", qs(d, "float32"));
                    x.push(e), f.push(e)
                }
                let I;
                I = y ? new bD(g, w, b, k, v) : new yD(g, w, b, k, v);
                const N = [
                        [g.padInfo.top, g.padInfo.left],
                        [g.strideHeight, g.strideWidth],
                        [g.dilationHeight, g.dilationWidth],
                        [g.inHeight, g.inWidth]
                    ],
                    S = n.runWebGLProgram(I, x, "float32", N);
                return f.forEach((e => n.disposeIntermediateTensorInfo(e))), S
            }
        };
        class u_ {
            constructor(e, t, n) {
                this.sliceDim = e, this.strides = t, this.variableNames = ["x", "indices"], this.outputShape = n;
                const s = nE(t.length),
                    r = nE(n.length),
                    a = this.sliceDim > 1 ? "strides[j]" : "strides";
                this.userCode = `\n        ${s} strides = ${s}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${a};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `
            }
        }
        const l_ = {
            kernelName: Ct,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    params: s,
                    indices: r
                } = t, a = r.shape, i = a[a.length - 1], o = O(s.shape), [u, l, c, h] = vc(s, r), p = oR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: [l, i]
                    }
                }), d = oR({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        shape: [O(s.shape) / c, c]
                    }
                });
                if (n.shouldExecuteOnCPU([s, r]) || "string" === s.dtype) {
                    const e = n.readSync(r.dataId),
                        t = n.bufferSync(s),
                        a = ME(e, t, s.dtype, l, i, c, h, s.shape, o);
                    return n.makeTensorInfo(u, s.dtype, a.values)
                }
                const f = new u_(i, h, [l, c]),
                    m = n.runWebGLProgram(f, [d, p], d.dtype),
                    g = oR({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    });
                return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(m), g
            }
        };
        class c_ {
            constructor(e, t) {
                this.variableNames = ["A", "indices"], this.outputShape = t, this.rank = t.length;
                const n = nE(this.rank),
                    s = function(e) {
                        const t = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
                            n = [];
                        for (let s = 0; s < e.length; s++) 2 === s ? n.push("index") : n.push(`${t[s]}`);
                        return n.join()
                    }(e);
                this.userCode = `\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `
            }
        }

        function h_(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r,
                indices: a
            } = t, {
                axis: i,
                batchDims: o
            } = s, u = W(i, r.shape)[0];
            if (de().get("DEBUG")) {
                const e = n.readSync(a.dataId),
                    t = r.shape[u];
                for (let n = 0; n < e.length; ++n) {
                    const s = e[n];
                    R(s <= t - 1 && s >= 0, (() => `GatherV2: the index value ${s} is not in [0, ${t-1}]`))
                }
            }
            const l = dh(r, a, u, o),
                c = O(a.shape),
                h = [],
                p = oR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: [l.batchSize, l.outerSize, l.dimSize, l.sliceSize]
                    }
                }),
                d = oR({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        shape: [l.batchSize, c / l.batchSize]
                    }
                });
            h.push(p), h.push(d);
            const f = [l.batchSize, l.outerSize, c / l.batchSize, l.sliceSize];
            if (n.shouldExecuteOnCPU([r, a]) || "string" === r.dtype) {
                const e = n.bufferSync(d),
                    t = n.bufferSync(p),
                    s = LE(t, e, f);
                return h.forEach((e => n.disposeIntermediateTensorInfo(e))), n.makeTensorInfo(l.outputShape, s.dtype, s.values)
            }
            const m = new c_(p.shape, f),
                g = n.runWebGLProgram(m, [p, d], p.dtype);
            h.push(g);
            const y = oR({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    shape: l.outputShape
                }
            });
            return h.forEach((e => n.disposeIntermediateTensorInfo(e))), y
        }
        const p_ = {
                kernelName: $t,
                backendName: "webgl",
                kernelFunc: h_
            },
            d_ = ZA({
                opSnippet: "return float(a > b);",
                packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
                cpuKernelImpl: zE,
                dtype: "bool"
            }),
            f_ = {
                kernelName: Et,
                backendName: "webgl",
                kernelFunc: d_
            },
            m_ = ZA({
                opSnippet: "return float(a >= b);",
                packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
                dtype: "bool",
                cpuKernelImpl: BE
            }),
            g_ = {
                kernelName: At,
                backendName: "webgl",
                kernelFunc: m_
            };
        const y_ = {
                kernelName: Ft,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        input: s
                    } = t;
                    return GD(s, !0, n)
                }
            },
            b_ = JA({
                opSnippet: "return float(!isnan(x) && !isinf(x));",
                dtype: "bool"
            }),
            x_ = {
                kernelName: _t,
                backendName: "webgl",
                kernelFunc: b_
            },
            w_ = JA({
                opSnippet: "return float(isinf(x));",
                dtype: "bool"
            }),
            k_ = {
                kernelName: Ot,
                backendName: "webgl",
                kernelFunc: w_
            },
            v_ = JA({
                opSnippet: "return float(isnan(x));",
                dtype: "bool"
            }),
            I_ = {
                kernelName: Mt,
                backendName: "webgl",
                kernelFunc: v_
            },
            N_ = ZA({
                opSnippet: "return float(a < b);",
                packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
                cpuKernelImpl: PE,
                dtype: "bool"
            }),
            S_ = {
                kernelName: zt,
                backendName: "webgl",
                kernelFunc: N_
            },
            T_ = ZA({
                opSnippet: "return float(a <= b);",
                packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
                cpuKernelImpl: UE,
                dtype: "bool"
            }),
            $_ = {
                kernelName: Bt,
                backendName: "webgl",
                kernelFunc: T_
            };
        const C_ = {
                kernelName: Pt,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        backend: t,
                        attrs: n
                    } = e, {
                        start: s,
                        stop: r,
                        num: a
                    } = n, i = WE(s, r, a);
                    return t.makeTensorInfo([i.length], "float32", i)
                }
            },
            E_ = JA({
                opSnippet: YA + "\n  return x < 0.0 ? 0./0. : log(x);\n",
                packedOpSnippet: "\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",
                cpuKernelImpl: VE
            }),
            A_ = {
                kernelName: Ut,
                backendName: "webgl",
                kernelFunc: E_
            },
            R_ = JA({
                opSnippet: YA + "\n  return log(1.0 + x);\n"
            }),
            F_ = {
                kernelName: Wt,
                backendName: "webgl",
                kernelFunc: R_
            },
            D_ = ZA({
                opSnippet: "return float(a >= 1.0 && b >= 1.0);",
                packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
                dtype: "bool"
            }),
            __ = {
                kernelName: Vt,
                backendName: "webgl",
                kernelFunc: D_
            },
            O_ = JA({
                opSnippet: "return float(!(x >= 1.0));"
            }),
            M_ = {
                kernelName: Gt,
                backendName: "webgl",
                kernelFunc: O_
            },
            L_ = ZA({
                opSnippet: "return float(a >= 1.0 || b >= 1.0);",
                packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
                dtype: "bool"
            }),
            z_ = {
                kernelName: Ht,
                backendName: "webgl",
                kernelFunc: L_
            };
        class B_ {
            constructor(e, t, n, s, r) {
                this.variableNames = ["x"], this.outputShape = [];
                const a = t,
                    i = e[3] - 1;
                let o;
                this.outputShape = e;
                const u = `float(${n}) + float(${s}) * sum`;
                o = .5 === r ? `inversesqrt(${u})` : 1 === r ? `1.0/(${u})` : `exp(log(${u}) * float(-${r}));`, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `
            }
        }
        class P_ {
            constructor(e, t, n, s, r) {
                this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
                const a = t,
                    i = e[3] - 1;
                let o;
                this.outputShape = e;
                const u = `float(${n}) + float(${s}) * sum`;
                o = .5 === r ? `inversesqrt(${u})` : 1 === r ? `1.0/(${u})` : `exp(log(${u}) * float(-${r}));`, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `
            }
        }
        const U_ = {
            kernelName: jt,
            backendName: "webgl",
            kernelFunc: e => {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    depthRadius: a,
                    bias: i,
                    alpha: o,
                    beta: u
                } = s, l = de().getBool("WEBGL_PACK_NORMALIZATION") ? new P_(r.shape, a, i, o, u) : new B_(r.shape, a, i, o, u);
                return n.runWebGLProgram(l, [r], r.dtype)
            }
        };
        class W_ {
            constructor(e, t, n, s, r) {
                this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, this.alpha = s, this.beta = r, this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `
            }
        }
        const V_ = {
            kernelName: qt,
            backendName: "webgl",
            kernelFunc: e => {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r,
                    y: a,
                    dy: i
                } = t, {
                    depthRadius: o,
                    bias: u,
                    alpha: l,
                    beta: c
                } = s, h = new W_(r.shape, o, u, l, c);
                return n.runWebGLProgram(h, [r, a, i], r.dtype)
            }
        };

        function G_(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                reductionIndices: a,
                keepDims: i
            } = s, o = r.shape.length, u = W(a, r.shape);
            let l = u;
            const c = Go(l, o),
                h = null != c,
                p = n.shouldExecuteOnCPU([r]);
            let d = r;
            if (h) {
                if (p) {
                    const e = n.texData.get(d.dataId).values,
                        t = new Array(o);
                    for (let e = 0; e < t.length; e++) t[e] = r.shape[c[e]];
                    const s = fA(e, r.shape, r.dtype, c, t);
                    d = n.makeTensorInfo(t, r.dtype);
                    n.texData.get(d.dataId).values = s
                } else d = fR(r, c, n);
                l = jo(l.length, o)
            }
            Vo("max", l, o);
            const [f, m] = Uo(d.shape, l);
            let g, y = f;
            if (i && (y = Wo(f, u)), p) {
                const e = n.texData.get(d.dataId).values,
                    t = GE(e, O(m), y, r.dtype);
                g = n.makeTensorInfo(y, r.dtype);
                n.texData.get(g.dataId).values = t
            } else g = function(e, t, n, s) {
                const r = O(t),
                    a = oR({
                        inputs: {
                            x: e
                        },
                        attrs: {
                            shape: [O(e.shape) / r, r]
                        },
                        backend: s
                    }),
                    i = hR(a, e.dtype, "max", s),
                    o = oR({
                        inputs: {
                            x: i
                        },
                        attrs: {
                            shape: n
                        },
                        backend: s
                    });
                return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o
            }(d, m, y, n);
            return h && n.disposeIntermediateTensorInfo(d), g
        }
        const H_ = {
                kernelName: Kt,
                backendName: "webgl",
                kernelFunc: G_
            },
            j_ = ZA({
                opSnippet: MA + "\n  return max(a, b);\n",
                packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  " + zA + "\n  return result;\n",
                cpuKernelImpl: HE
            }),
            q_ = {
                kernelName: Xt,
                backendName: "webgl",
                kernelFunc: j_
            };
        const K_ = {
            kernelName: Yt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t;
                LC(r, "maxPool");
                const {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dimRoundingMode: u
                } = s;
                R(Pi(i, 1), (() => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));
                const l = Ai(r.shape, a, i, 1, o, u);
                if (1 === l.filterWidth && 1 === l.filterHeight && M(l.inShape, l.outShape)) return PA({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                const c = new ZR(l, "max", !1);
                return n.runWebGLProgram(c, [r], r.dtype)
            }
        };
        const X_ = {
            kernelName: Zt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    filterSize: a,
                    strides: i,
                    pad: o,
                    dataFormat: u,
                    dimRoundingMode: l
                } = s, c = Ri(r.shape, a, i, [1, 1, 1], o, l, u), h = new QR(c, "max", !1);
                return n.runWebGLProgram(h, [r], r.dtype)
            }
        };
        class Y_ {
            constructor(e) {
                this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
                const t = e.strideHeight,
                    n = e.strideWidth,
                    s = e.dilationHeight,
                    r = e.effectiveFilterHeight,
                    a = e.effectiveFilterWidth,
                    i = r - 1 - e.padInfo.top,
                    o = a - 1 - e.padInfo.left,
                    u = r * a - 1;
                this.userCode = `\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        class J_ {
            constructor(e) {
                this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
                const t = e.strideDepth,
                    n = e.strideHeight,
                    s = e.strideWidth,
                    r = e.dilationDepth,
                    a = e.dilationHeight,
                    i = e.dilationWidth,
                    o = e.effectiveFilterDepth,
                    u = e.effectiveFilterHeight,
                    l = e.effectiveFilterWidth,
                    c = o - 1 - e.padInfo.front,
                    h = u - 1 - e.padInfo.top,
                    p = l - 1 - e.padInfo.left,
                    d = o * u * l - 1;
                this.userCode = `\n      const ivec3 pads = ivec3(${c}, ${h}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${d} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `
            }
        }
        const Z_ = {
            kernelName: Qt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a
                } = t, i = a, {
                    filterSize: o,
                    strides: u,
                    pad: l,
                    dimRoundingMode: c
                } = s, h = Ri(i.shape, o, u, [1, 1, 1], l, c), p = new QR(h, "max", !0), d = n.runWebGLProgram(p, [i], i.dtype), f = new J_(h), m = n.runWebGLProgram(f, [r, d], i.dtype);
                return n.disposeIntermediateTensorInfo(d), m
            }
        };
        const Q_ = {
            kernelName: Jt,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    dy: r,
                    input: a,
                    output: i
                } = t, o = a;
                LC([a, i], "maxPoolGrad");
                const {
                    filterSize: u,
                    strides: l,
                    pad: c,
                    dimRoundingMode: h
                } = s, p = Ai(o.shape, u, l, 1, c, h), d = new ZR(p, "max", !0), f = n.runWebGLProgram(d, [o], o.dtype), m = new Y_(p), g = n.runWebGLProgram(m, [r, f], o.dtype);
                return n.disposeIntermediateTensorInfo(f), g
            }
        };
        const eO = {
            kernelName: en,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                attrs: t,
                backend: n
            }) => {
                const {
                    x: s
                } = e, {
                    filterSize: r,
                    strides: a,
                    pad: i,
                    includeBatchInIndex: o
                } = t, u = n;
                R(4 === s.shape.length, (() => `Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));
                const l = [1, 1];
                R(Pi(a, l), (() => `Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`));
                const c = Ai(s.shape, r, a, l, i),
                    [h, p] = function(e, t, n, s) {
                        let r = new ZR(n, "max", !1);
                        const a = s.runWebGLProgram(r, [e], "float32");
                        return r = new ZR(n, "max", !0, !0, t), [a, s.runWebGLProgram(r, [e], "float32")]
                    }(s, o, c, u);
                return [h, p]
            }
        };
        const tO = {
            kernelName: tn,
            backendName: "webgl",
            kernelFunc: ({
                inputs: e,
                attrs: t,
                backend: n
            }) => {
                const {
                    x: s
                } = e, {
                    keepDims: r,
                    axis: a
                } = t, i = n, o = s.shape.length, u = W(a, s.shape);
                let l = u;
                const c = Go(l, o),
                    h = null != c,
                    p = i.shouldExecuteOnCPU([s]),
                    d = [];
                let f = s;
                if (h) {
                    if (p) {
                        const e = i.texData.get(f.dataId).values,
                            t = new Array(o);
                        for (let e = 0; e < t.length; e++) t[e] = s.shape[c[e]];
                        const n = fA(e, s.shape, s.dtype, c, t);
                        f = i.makeTensorInfo(t, s.dtype);
                        i.texData.get(f.dataId).values = n
                    } else f = fR(s, c, i);
                    d.push(f), l = jo(l.length, o)
                }
                Vo("sum", l, o);
                const [m, g] = Uo(f.shape, l);
                let y = m;
                r && (y = Wo(m, u));
                const b = function(e, t, n, s) {
                    const r = O(t),
                        a = oR({
                            inputs: {
                                x: e
                            },
                            attrs: {
                                shape: [O(e.shape) / r, r]
                            },
                            backend: s
                        }),
                        i = hR(a, "float32", "mean", s),
                        o = oR({
                            inputs: {
                                x: i
                            },
                            attrs: {
                                shape: n
                            },
                            backend: s
                        });
                    return s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o
                }(f, g, y, i);
                for (const e of d) i.disposeIntermediateTensorInfo(e);
                return b
            }
        };
        const nO = {
                kernelName: nn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        axis: a,
                        keepDims: i
                    } = s, o = r.shape.length, u = W(a, r.shape);
                    let l = u;
                    const c = Go(l, o);
                    let h = r;
                    null != c && (h = yR({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            perm: c
                        }
                    }), l = jo(l.length, r.shape.length)), Vo("min", l, o);
                    const [p, d] = Uo(h.shape, l), f = oR({
                        inputs: {
                            x: h
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, O(d)]
                        }
                    }), m = hR(f, f.dtype, "min", n);
                    let g;
                    if (i) {
                        g = oR({
                            inputs: {
                                x: m
                            },
                            backend: n,
                            attrs: {
                                shape: Wo(p, u)
                            }
                        })
                    } else g = oR({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: p
                        }
                    });
                    return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), null != c && n.disposeIntermediateTensorInfo(h), g
                }
            },
            sO = ZA({
                opSnippet: MA + "\n  return min(a, b);\n",
                packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  " + zA + "\n  return result;\n",
                cpuKernelImpl: jE
            }),
            rO = {
                kernelName: sn,
                backendName: "webgl",
                kernelFunc: sO
            };
        class aO {
            constructor(e, t, n) {
                this.variableNames = ["x"], this.outputShape = t.map(((t, n) => t[0] + e[n] + t[1]));
                const s = e.length,
                    r = nE(s),
                    a = t.map((e => e[0])).join(","),
                    i = t.map(((t, n) => t[0] + e[n])).join(","),
                    o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s),
                    u = "reflect" === n ? 0 : 1;
                this.userCode = 1 !== s ? `\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    ` : `\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `
            }
        }
        class iO {
            constructor(e, t, n) {
                this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.map(((t, n) => t[0] + e[n] + t[1]));
                const s = e.length,
                    r = nE(s),
                    a = t.map((e => e[0])).join(","),
                    i = t.map(((t, n) => t[0] + e[n])).join(","),
                    o = yA("rc", s),
                    u = yA("source", s),
                    l = `${o[s-1]} < ${this.outputShape[s-1]}`,
                    c = 1 === s ? "source" : `vec2(${u.slice(-2).join()})`,
                    h = "reflect" === n ? 0 : 1;
                let p = "";
                if (1 === s) {
                    const e = `\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;
                    p = `\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `
                } else {
                    const e = `\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;
                    p = `\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[s-2]} += 1;\n        if(${o[s-2]} < ${this.outputShape[s-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[s-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `
                }
                this.userCode = `\n      const ${r} start = ${r}(${a});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `
            }
        }
        const oO = {
                kernelName: rn,
                backendName: "webgl",
                kernelFunc: ({
                    inputs: e,
                    backend: t,
                    attrs: n
                }) => {
                    const {
                        x: s
                    } = e, {
                        paddings: r,
                        mode: a
                    } = n, i = de().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new iO(s.shape, r, a) : new aO(s.shape, r, a);
                    return t.runWebGLProgram(i, [s], s.dtype)
                }
            },
            uO = ZA({
                opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
                packedOpSnippet: "\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  " + zA + "\n  return result;\n"
            }),
            lO = {
                kernelName: an,
                backendName: "webgl",
                kernelFunc: uO
            };
        class cO {
            constructor(e, t, n) {
                this.variableNames = ["probs"], this.customUniforms = [{
                    name: "seed",
                    type: "float"
                }], this.outputShape = [e, n], this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `
            }
        }
        const hO = ZA({
                opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
                packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
                checkOutOfBounds: !0
            }),
            pO = {
                kernelName: pt,
                backendName: "webgl",
                kernelFunc: hO
            },
            dO = "return a - b;",
            fO = ZA({
                opSnippet: dO,
                packedOpSnippet: dO,
                supportsComplex: !0,
                cpuKernelImpl: hA
            }),
            mO = {
                kernelName: is,
                backendName: "webgl",
                kernelFunc: fO
            };

        function gO(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                logits: r
            } = t, {
                dim: a
            } = s, i = W([a], r.shape), o = G_({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    reductionIndices: i,
                    keepDims: !1
                }
            }), u = Wo(o.shape, i), l = oR({
                inputs: {
                    x: o
                },
                backend: n,
                attrs: {
                    shape: u
                }
            }), c = fO({
                inputs: {
                    a: r,
                    b: l
                },
                backend: n
            }), h = MD({
                inputs: {
                    x: c
                },
                backend: n
            }), p = mR({
                inputs: {
                    x: h
                },
                backend: n,
                attrs: {
                    axis: i,
                    keepDims: !1
                }
            }), d = oR({
                inputs: {
                    x: p
                },
                backend: n,
                attrs: {
                    shape: u
                }
            }), f = hO({
                inputs: {
                    a: h,
                    b: d
                },
                backend: n
            });
            return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(d), f
        }
        const yO = {
            kernelName: Kn,
            backendName: "webgl",
            kernelFunc: gO
        };
        const bO = {
                kernelName: on,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        logits: r
                    } = t, {
                        numSamples: a,
                        seed: i,
                        normalized: o
                    } = s, u = o ? r : gO({
                        inputs: {
                            logits: r
                        },
                        backend: n,
                        attrs: {
                            dim: r.shape.length - 1
                        }
                    }), l = u.shape[0], c = u.shape[1], h = new cO(l, c, a), p = [
                        [i]
                    ], d = n.runWebGLProgram(h, [u], "int32", p);
                    return o || n.disposeIntermediateTensorInfo(u), d
                }
            },
            xO = SA + "\n  return -x;\n";
        const wO = {
                kernelName: ln,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        x: s
                    } = t;
                    if (n.shouldExecuteOnCPU([s])) {
                        const e = n.texData.get(s.dataId),
                            [t, r] = KE(e.values, s.shape, s.dtype);
                        return n.makeTensorInfo(r, s.dtype, t)
                    }
                    let r;
                    return r = de().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new AA(s.shape, "\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n") : new NA(s.shape, xO), n.runWebGLProgram(r, [s], s.dtype)
                }
            },
            kO = hl;
        const vO = {
                kernelName: hn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    Is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        boxes: r,
                        scores: a
                    } = t, {
                        maxOutputSize: i,
                        iouThreshold: o,
                        scoreThreshold: u
                    } = s, l = n.readSync(r.dataId), c = n.readSync(a.dataId), {
                        selectedIndices: h
                    } = kO(l, c, i, o, u);
                    return n.makeTensorInfo([h.length], "int32", new Int32Array(h))
                }
            },
            IO = pl;
        const NO = {
                kernelName: pn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    Is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        boxes: r,
                        scores: a
                    } = t, {
                        maxOutputSize: i,
                        iouThreshold: o,
                        scoreThreshold: u,
                        padToMaxOutputSize: l
                    } = s, c = n.readSync(r.dataId), h = n.readSync(a.dataId), {
                        selectedIndices: p,
                        validOutputs: d
                    } = IO(c, h, i, o, u, l);
                    return [n.makeTensorInfo([p.length], "int32", new Int32Array(p)), n.makeTensorInfo([], "int32", new Int32Array([d]))]
                }
            },
            SO = dl;
        const TO = {
            kernelName: dn,
            backendName: "webgl",
            kernelFunc: function(e) {
                Is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    boxes: r,
                    scores: a
                } = t, {
                    maxOutputSize: i,
                    iouThreshold: o,
                    scoreThreshold: u,
                    softNmsSigma: l
                } = s, c = n.readSync(r.dataId), h = n.readSync(a.dataId), p = i, d = o, f = u, m = l, {
                    selectedIndices: g,
                    selectedScores: y
                } = SO(c, h, p, d, f, m);
                return [n.makeTensorInfo([g.length], "int32", new Int32Array(g)), n.makeTensorInfo([y.length], "float32", new Float32Array(y))]
            }
        };
        class $O {
            constructor(e, t, n, s) {
                this.variableNames = ["indices"], this.outputShape = [e, t], this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `
            }
        }
        const CO = {
            kernelName: mn,
            backendName: "webgl",
            kernelFunc: e => {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    indices: r
                } = t, {
                    depth: a,
                    onValue: i,
                    offValue: o
                } = s, u = O(r.shape), l = new $O(u, a, i, o), c = oR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: [u]
                    }
                }), h = n.runWebGLProgram(l, [c], r.dtype);
                n.disposeIntermediateTensorInfo(c);
                const p = oR({
                    inputs: {
                        x: h
                    },
                    backend: n,
                    attrs: {
                        shape: [...r.shape, a]
                    }
                });
                return n.disposeIntermediateTensorInfo(h), p
            }
        };

        function EO(e) {
            const {
                inputs: t,
                backend: n
            } = e, {
                x: s
            } = t;
            if ("complex64" === s.dtype) {
                const e = wF({
                        inputs: {
                            input: s
                        },
                        backend: n
                    }),
                    t = EO({
                        inputs: {
                            x: e
                        },
                        backend: n
                    }),
                    r = OF({
                        inputs: {
                            input: s
                        },
                        backend: n
                    }),
                    a = EO({
                        inputs: {
                            x: r
                        },
                        backend: n
                    }),
                    i = WA({
                        inputs: {
                            real: t,
                            imag: a
                        },
                        backend: n
                    });
                return n.disposeIntermediateTensorInfo(e), n.disposeIntermediateTensorInfo(t), n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(a), i
            }
            return qD({
                attrs: {
                    shape: s.shape,
                    dtype: s.dtype,
                    value: "string" === s.dtype ? "" : 0
                },
                backend: n
            })
        }
        const AO = {
            kernelName: gs,
            backendName: "webgl",
            kernelFunc: EO
        };
        const RO = {
            kernelName: fn,
            backendName: "webgl",
            kernelFunc: function e(t) {
                const {
                    inputs: n,
                    backend: s
                } = t, {
                    x: r
                } = n;
                if ("string" === r.dtype) throw new Error("onesLike is not supported under string dtype");
                if ("complex64" === r.dtype) {
                    const t = wF({
                            inputs: {
                                input: r
                            },
                            backend: s
                        }),
                        n = e({
                            inputs: {
                                x: t
                            },
                            backend: s
                        }),
                        a = OF({
                            inputs: {
                                input: r
                            },
                            backend: s
                        }),
                        i = EO({
                            inputs: {
                                x: a
                            },
                            backend: s
                        }),
                        o = WA({
                            inputs: {
                                real: n,
                                imag: i
                            },
                            backend: s
                        });
                    return s.disposeIntermediateTensorInfo(t), s.disposeIntermediateTensorInfo(n), s.disposeIntermediateTensorInfo(a), s.disposeIntermediateTensorInfo(i), o
                }
                return qD({
                    attrs: {
                        shape: r.shape,
                        dtype: r.dtype,
                        value: 1
                    },
                    backend: s
                })
            }
        };
        const FO = {
            kernelName: gn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    axis: r
                } = s;
                if (1 === t.length) return zD({
                    inputs: {
                        input: t[0]
                    },
                    backend: n,
                    attrs: {
                        dim: r
                    }
                });
                const a = t[0].shape,
                    i = t[0].dtype;
                t.forEach((e => {
                    F(a, e.shape, "All tensors passed to stack must have matching shapes"), R(i === e.dtype, (() => "All tensors passed to stack must have matching dtypes"))
                }));
                const o = [],
                    u = zF({
                        inputs: t.map((e => {
                            const t = zD({
                                inputs: {
                                    input: e
                                },
                                backend: n,
                                attrs: {
                                    dim: r
                                }
                            });
                            return o.push(t), t
                        })),
                        backend: n,
                        attrs: {
                            axis: r
                        }
                    });
                return o.forEach((e => n.disposeIntermediateTensorInfo(e))), u
            }
        };
        class DO {
            constructor(e, t, n) {
                this.variableNames = ["x"], this.customUniforms = [{
                    name: "value",
                    type: "float"
                }], this.outputShape = t.map(((t, n) => t[0] + e[n] + t[1]));
                const s = e.length,
                    r = nE(s),
                    a = t.map((e => e[0])).join(","),
                    i = t.map(((t, n) => t[0] + e[n])).join(","),
                    o = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, s);
                this.userCode = 1 !== s ? `\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    ` : `\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `
            }
        }
        class _O {
            constructor(e, t, n) {
                this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                    name: "value",
                    type: "float"
                }], this.outputShape = t.map(((t, n) => t[0] + e[n] + t[1]));
                const s = e.length,
                    r = nE(s),
                    a = t.map((e => e[0])).join(","),
                    i = t.map(((t, n) => t[0] + e[n])).join(","),
                    o = yA("rc", s),
                    u = yA("source", s),
                    l = `${o[s-1]} < ${this.outputShape[s-1]}`,
                    c = 1 === s ? "source" : `vec2(${u.slice(-2).join()})`,
                    h = [`${r} rc = outputLoc;`, `${o[s-1]} += 1;\n       if(${l}) {\n      `, 1 === s ? "" : `}\n       rc = outputLoc;\n       ${o[s-2]} += 1;\n       if(${o[s-2]} < ${this.outputShape[s-2]}) {`, 1 === s ? "" : `  ${o[s-1]} += 1;\n         if(${l}) {`],
                    p = 1 === s ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
                let d = "";
                for (let e = 0, t = 1 === s ? 2 : 4; e < t; e++) d += `\n        ${h[e]}\n        if (${p}) {\n          result[${e}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;
                d += 1 === s ? "} " : "}}", this.userCode = `\n      const ${r} start = ${r}(${a});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `
            }
        }
        const OO = e => {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    paddings: a,
                    constantValue: i
                } = s;
                if (0 === O(r.shape)) {
                    const e = a.map(((e, t) => e[0] + r.shape[t] + e[1]));
                    return qD({
                        backend: n,
                        attrs: {
                            shape: e,
                            value: i,
                            dtype: r.dtype
                        }
                    })
                }
                const o = de().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new _O(r.shape, a, i) : new DO(r.shape, a, i),
                    u = [
                        [i]
                    ];
                return n.runWebGLProgram(o, [r], r.dtype, u)
            },
            MO = {
                kernelName: yn,
                backendName: "webgl",
                kernelFunc: OO
            },
            LO = ZA({
                opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
                packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  " + zA + "\n  return result;\n"
            }),
            zO = {
                kernelName: bn,
                backendName: "webgl",
                kernelFunc: LO
            };
        const BO = {
                kernelName: wn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        axis: a,
                        keepDims: i
                    } = s, o = r.shape.length, u = [], l = W(a, r.shape);
                    let c = l;
                    const h = Go(c, o);
                    let p, d = r;
                    if (null != h && (d = yR({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                perm: h
                            }
                        }), c = jo(c.length, o), u.push(d)), Vo("prod", c, o), n.shouldExecuteOnCPU([d])) {
                        const e = n.texData.get(d.dataId).values,
                            {
                                outVals: t,
                                outShape: s,
                                outDtype: r
                            } = YE(d.shape, d.dtype, e, c);
                        p = n.makeTensorInfo(s, r, t)
                    } else {
                        const [e, t] = Uo(d.shape, c), s = O(t), a = oR({
                            inputs: {
                                x: d
                            },
                            backend: n,
                            attrs: {
                                shape: [-1, s]
                            }
                        }), i = hR(a, wr(r.dtype), "prod", n);
                        p = oR({
                            inputs: {
                                x: i
                            },
                            backend: n,
                            attrs: {
                                shape: e
                            }
                        }), u.push(a), u.push(i)
                    }
                    if (i) {
                        u.push(p);
                        const e = Wo(p.shape, l);
                        p = oR({
                            inputs: {
                                x: p
                            },
                            backend: n,
                            attrs: {
                                shape: e
                            }
                        })
                    }
                    return u.forEach((e => n.disposeIntermediateTensorInfo(e))), p
                }
            },
            PO = e => {
                const {
                    backend: t,
                    attrs: n
                } = e, {
                    start: s,
                    stop: r,
                    step: a,
                    dtype: i
                } = n, o = JE(s, r, a, i);
                return t.makeTensorInfo([o.length], i, o)
            },
            UO = {
                kernelName: kn,
                backendName: "webgl",
                kernelFunc: PO
            },
            WO = JA({
                opSnippet: "return 1.0 / x;"
            }),
            VO = {
                kernelName: In,
                backendName: "webgl",
                kernelFunc: WO
            },
            GO = JA({
                opSnippet: SA + "\n  return (x < 0.0) ? 0.0 : x;\n",
                packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
            }),
            HO = {
                kernelName: Nn,
                backendName: "webgl",
                kernelFunc: GO
            },
            jO = JA({
                opSnippet: SA + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
                packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
            }),
            qO = {
                kernelName: An,
                backendName: "webgl",
                kernelFunc: jO
            };
        class KO {
            constructor(e, t, n, s, r) {
                this.variableNames = ["A"], this.outputShape = [];
                const [a, i, o, u] = e;
                this.outputShape = [a, t, n, u];
                const l = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
                    c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
                let h;
                h = r ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        class XO {
            constructor(e, t, n, s, r) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
                const [a, i, o, u] = e;
                this.outputShape = [a, t, n, u];
                const l = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
                    c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n];
                let h;
                h = r ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        const YO = {
            kernelName: Cn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r
                } = t, {
                    alignCorners: a,
                    halfPixelCenters: i,
                    size: o
                } = s, [u, l] = o, c = de().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new XO(r.shape, u, l, a, i) : new KO(r.shape, u, l, a, i);
                return n.runWebGLProgram(c, [r], "float32")
            }
        };
        class JO {
            constructor(e, t, n) {
                this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
                const [, s, r] = t, [, a, i] = e, o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r], u = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i], l = o[0] / u[0], c = o[1] / u[1], h = 1 / l, p = 1 / c, d = 2 * Math.ceil(h) + 2, f = 2 * Math.ceil(p) + 2;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `
            }
        }
        const ZO = {
            kernelName: En,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r,
                    dy: a
                } = t, {
                    alignCorners: i
                } = s, o = new JO(a.shape, r.shape, i);
                return n.runWebGLProgram(o, [a], a.dtype)
            }
        };
        class QO {
            constructor(e, t, n, s, r) {
                this.variableNames = ["A"], this.outputShape = [];
                const [a, i, o, u] = e;
                this.outputShape = [a, t, n, u];
                const l = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
                    c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n],
                    h = s ? "0.5" : "0.0";
                let p;
                p = r ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        class eM {
            constructor(e, t, n, s, r) {
                this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
                const [a, i, o, u] = e;
                this.outputShape = [a, t, n, u];
                const l = [s && t > 1 ? i - 1 : i, s && n > 1 ? o - 1 : o],
                    c = [s && t > 1 ? t - 1 : t, s && n > 1 ? n - 1 : n],
                    h = s ? "0.5" : "0.0";
                let p;
                p = r ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `
            }
        }
        const tM = {
            kernelName: Tn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r
                } = t, {
                    alignCorners: a,
                    halfPixelCenters: i,
                    size: o
                } = s, [u, l] = o, c = de().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new eM(r.shape, u, l, a, i) : new QO(r.shape, u, l, a, i);
                return n.runWebGLProgram(c, [r], r.dtype)
            }
        };
        class nM {
            constructor(e, t, n) {
                this.variableNames = ["dy"], this.outputShape = [], this.outputShape = t;
                const [, s, r] = t, [, a, i] = e, o = [n && a > 1 ? s - 1 : s, n && i > 1 ? r - 1 : r], u = [n && a > 1 ? a - 1 : a, n && i > 1 ? i - 1 : i], l = o[0] / u[0], c = o[1] / u[1], h = 1 / l, p = 1 / c, d = 2 * Math.ceil(h) + 2, f = 2 * Math.ceil(p) + 2;
                this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${d});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `
            }
        }
        const sM = {
            kernelName: $n,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    images: r,
                    dy: a
                } = t, {
                    alignCorners: i
                } = s, o = new nM(a.shape, r.shape, i);
                return n.runWebGLProgram(o, [a], a.dtype)
            }
        };
        class rM {
            constructor(e, t) {
                this.variableNames = ["x"];
                const n = e.length;
                if (n > 4) throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);
                if (this.outputShape = e, 1 === n) return void(this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);
                const s = e.map(((n, s) => (n => -1 !== t.indexOf(n) && 1 !== e[n] ? `${e[n]} - coords[${n}] - 1` : `coords[${n}]`)(s))).join(","),
                    r = nE(n);
                this.userCode = `\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `
            }
        }
        class aM {
            constructor(e, t) {
                this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
                const n = e.length;
                if (n > 4) throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);
                this.outputShape = e;
                const s = yA("rc", n),
                    r = `${s[n-1]} + 1 < ${this.outputShape[n-1]}`,
                    a = `${s[n-2]} + 1 < ${this.outputShape[n-2]}`,
                    i = nE(n);

                function o(n) {
                    const s = e.map(((s, r) => function(n, s) {
                        return -1 !== t.indexOf(n) && 1 !== e[n] ? `${e[n]} - ${s[n]} - 1` : `${s[n]}`
                    }(r, n)));
                    return `getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`
                }
                this.userCode = 1 === n ? `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ` : `\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(s.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(s.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `
            }
        }
        const iM = {
            kernelName: Rn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    dims: a
                } = s, i = r.shape.length, o = W(a, r.shape);
                if (0 === i) return PA({
                    inputs: {
                        x: r
                    },
                    backend: n
                });
                const u = de().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new aM(r.shape, o) : new rM(r.shape, o);
                return n.runWebGLProgram(u, [r], r.dtype)
            }
        };
        class oM {
            constructor(e, t) {
                this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{
                    name: "params",
                    type: "vec4"
                }];
                const n = e[1],
                    s = e[2];
                this.outputShape = e;
                let r = "";
                r = "number" == typeof t ? `float outputValue = ${t.toFixed(2)};` : `\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`, this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `
            }
        }
        const uM = {
                kernelName: xs,
                backendName: "webgl",
                kernelFunc: ({
                    inputs: e,
                    attrs: t,
                    backend: n
                }) => {
                    const {
                        image: s
                    } = e, {
                        radians: r,
                        fillValue: a,
                        center: i
                    } = t, o = n, u = new oM(s.shape, a), [l, c] = gc(i, s.shape[1], s.shape[2]), h = [
                        [l, c, Math.sin(r), Math.cos(r)]
                    ];
                    return o.runWebGLProgram(u, [s], s.dtype, h)
                }
            },
            lM = JA({
                opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
            }),
            cM = {
                kernelName: Fn,
                backendName: "webgl",
                kernelFunc: lM
            },
            hM = JA({
                opSnippet: "return inversesqrt(x);",
                cpuKernelImpl: ZE
            }),
            pM = {
                kernelName: Dn,
                backendName: "webgl",
                kernelFunc: hM
            };
        class dM {
            constructor(e, t, n, s, r, a, i = !0) {
                this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a;
                const o = nE(r.length),
                    u = nE(a.length);
                let l = "";
                1 === n ? l = "i" : 2 === n && (l = "i, j");
                const c = `getIndices(${l})`;
                let h = "";
                1 === s ? h = "i" : 2 === s && (h = "i, coords[1]");
                const p = `getUpdates(${h})`,
                    d = t > 1 ? "strides[j]" : "strides";
                this.userCode = `\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${d};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `
            }
        }
        const fM = {
            kernelName: _n,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    indices: r,
                    updates: a
                } = t, {
                    shape: i
                } = s, {
                    sliceRank: o,
                    numUpdates: u,
                    sliceSize: l,
                    strides: c,
                    outputSize: h
                } = Sc(0, r, i), p = [h / l, l];
                if (0 === h) return n.makeTensorInfo(i, r.dtype);
                const d = oR({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [u, o]
                        }
                    }),
                    f = oR({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [u, l]
                        }
                    }),
                    m = n.makeTensorInfo([], "float32", new Float32Array([0])),
                    g = new dM(u, o, d.shape.length, f.shape.length, c, p),
                    y = n.runWebGLProgram(g, [f, d, m], f.dtype),
                    b = oR({
                        inputs: {
                            x: y
                        },
                        backend: n,
                        attrs: {
                            shape: i
                        }
                    });
                return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(m), b
            }
        };
        class mM {
            constructor(e, t, n, s) {
                this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{
                    name: "numInputs",
                    type: "int"
                }], this.outputShape = [e, n];
                const r = `for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,
                    a = 2 === de().getNumber("WEBGL_VERSION") ? "while (left < right) {" : r,
                    i = "left" === s ? "<" : "<=";
                this.userCode = `\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `
            }
        }
        const gM = {
            kernelName: On,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    sortedSequence: r,
                    values: a
                } = t, {
                    side: i
                } = s, o = new mM(r.shape[0], r.shape[1], a.shape[1], i), u = [
                    [r.shape[1]]
                ];
                return n.runWebGLProgram(o, [r, a], "int32", u)
            }
        };
        class yM {
            constructor(e, t, n) {
                let s, r;
                if (this.variableNames = ["c", "a", "b"], this.outputShape = t, n > 4) throw Error(`Where for rank ${n} is not yet supported`);
                if (1 === n) r = "resRC", s = "resRC";
                else {
                    const n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"],
                        a = [],
                        i = [];
                    for (let s = 0; s < t.length; s++) i.push(`${n[s]}`), s < e && a.push(`${n[s]}`);
                    s = a.join(), r = i.join()
                }
                const a = nE(n);
                this.userCode = `\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `
            }
        }
        const bM = {
                kernelName: Mn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n
                    } = e, {
                        condition: s,
                        t: r,
                        e: a
                    } = t, i = new yM(s.shape.length, r.shape, r.shape.length);
                    return n.runWebGLProgram(i, [s, r, a], xr(r.dtype, a.dtype))
                }
            },
            xM = JA({
                opSnippet: `\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Tc};\n  float scale = ${$c};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`
            }),
            wM = {
                kernelName: Ln,
                backendName: "webgl",
                kernelFunc: xM
            },
            kM = JA({
                opSnippet: YA + "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",
                packedOpSnippet: "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
                cpuKernelImpl: eA
            }),
            vM = {
                kernelName: Wn,
                backendName: "webgl",
                kernelFunc: kM
            },
            IM = JA({
                opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
            }),
            NM = {
                kernelName: Un,
                backendName: "webgl",
                kernelFunc: IM
            },
            SM = JA({
                opSnippet: YA + "\n  return sin(x);\n"
            }),
            TM = {
                kernelName: Bn,
                backendName: "webgl",
                kernelFunc: SM
            },
            $M = JA({
                opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
            }),
            CM = {
                kernelName: Pn,
                backendName: "webgl",
                kernelFunc: $M
            },
            EM = JA({
                opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
            }),
            AM = {
                kernelName: Vn,
                backendName: "webgl",
                kernelFunc: EM
            },
            RM = {
                kernelName: jn,
                backendName: "webgl",
                kernelFunc: e => {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        blockShape: a,
                        paddings: i
                    } = s;
                    R(r.shape.length <= 4, (() => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));
                    const o = a.reduce(((e, t) => e * t)),
                        u = [
                            [0, 0]
                        ];
                    u.push(...i);
                    for (let e = 1 + a.length; e < r.shape.length; ++e) u.push([0, 0]);
                    const l = [],
                        c = OO({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                paddings: u,
                                constantValue: 0
                            }
                        }),
                        h = yc(c.shape, a, o, !1),
                        p = bc(h.length, a.length, !1),
                        d = xc(c.shape, a, o, !1),
                        f = oR({
                            inputs: {
                                x: c
                            },
                            backend: n,
                            attrs: {
                                shape: h
                            }
                        }),
                        m = yR({
                            inputs: {
                                x: f
                            },
                            backend: n,
                            attrs: {
                                perm: p
                            }
                        }),
                        g = oR({
                            inputs: {
                                x: m
                            },
                            backend: n,
                            attrs: {
                                shape: d
                            }
                        });
                    return l.push(c), l.push(f), l.push(m), l.forEach((e => n.disposeIntermediateTensorInfo(e))), g
                }
            };
        const FM = {
            kernelName: Xn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    indices: s,
                    values: r,
                    denseShape: a,
                    defaultValue: i
                } = t;
                if (1 !== a.shape.length) throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);
                if (2 !== s.shape.length) throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);
                if (1 !== r.shape.length) throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);
                if (0 !== i.shape.length) throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);
                const o = n.readSync(s.dataId),
                    u = n.readSync(r.dataId),
                    l = n.readSync(a.dataId),
                    c = n.readSync(i.dataId)[0],
                    [h, p, d, f, m] = sA(o, s.shape, s.dtype, u, r.dtype, l, c);
                return [n.makeTensorInfo(p, s.dtype, h), n.makeTensorInfo([p[0]], r.dtype, d), n.makeTensorInfo([f.length], "bool", new Uint8Array(f.map((e => Number(e))))), n.makeTensorInfo([m.length], s.dtype, new Int32Array(m))]
            }
        };
        const DM = {
            kernelName: Yn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    inputIndices: s,
                    inputShape: r,
                    newShape: a
                } = t;
                if (2 !== s.shape.length) throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);
                if (1 !== r.shape.length) throw new Error(`Input shape should be a vector but received shape ${r.shape}`);
                if (1 !== a.shape.length) throw new Error(`Target shape should be a vector but received shape ${a.shape}`);
                const i = Array.from(n.readSync(r.dataId)),
                    o = n.readSync(s.dataId),
                    u = Array.from(n.readSync(a.dataId)),
                    [l, c, h] = rA(o, s.shape, s.dtype, i, u);
                return [n.makeTensorInfo(c, s.dtype, l), n.makeTensorInfo([h.length], a.dtype, new Int32Array(h))]
            }
        };
        const _M = {
            kernelName: Jn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    data: s,
                    indices: r,
                    segmentIds: a
                } = t;
                if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
                if (1 !== r.shape.length) throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);
                if (1 !== a.shape.length) throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);
                const i = n.readSync(s.dataId),
                    o = n.readSync(r.dataId),
                    u = n.readSync(a.dataId),
                    [l, c] = aA(i, s.shape, s.dtype, o, u, !0);
                return n.makeTensorInfo(c, s.dtype, l)
            }
        };
        const OM = {
            kernelName: Zn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n
                } = e, {
                    data: s,
                    indices: r,
                    segmentIds: a
                } = t;
                if (s.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
                if (1 !== r.shape.length) throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);
                if (1 !== a.shape.length) throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);
                const i = n.readSync(s.dataId),
                    o = n.readSync(r.dataId),
                    u = n.readSync(a.dataId),
                    [l, c] = aA(i, s.shape, s.dtype, o, u);
                return n.makeTensorInfo(c, s.dtype, l)
            }
        };
        const MM = {
            kernelName: Qn,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    sparseIndices: r,
                    sparseValues: a,
                    defaultValue: i
                } = t, {
                    outputShape: o
                } = s, {
                    sliceRank: u,
                    numUpdates: l,
                    sliceSize: c,
                    strides: h,
                    outputSize: p
                } = Sc(0, r, o), d = !1;
                if ("string" === a.dtype) {
                    const e = n.bufferSync(r),
                        t = n.bufferSync(a),
                        s = Js(n.readSync(i.dataId)[0]),
                        f = QE(e, t, o, p, c, l, u, h, s, d);
                    return n.makeTensorInfo(o, f.dtype, f.values)
                }
                const f = new dM(l, u, r.shape.length, a.shape.length, h, [p, 1], d),
                    m = n.runWebGLProgram(f, [a, r, i], a.dtype),
                    g = oR({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: o
                        }
                    });
                return n.disposeIntermediateTensorInfo(m), g
            }
        };
        const LM = {
                kernelName: qn,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r
                    } = t, {
                        numOrSizeSplits: a,
                        axis: i
                    } = s, o = W(i, r.shape)[0], u = Zc(r, a, o), l = r.shape.length, c = new Array(l).fill(0), h = r.shape.slice();
                    return u.map((e => {
                        const t = [...h];
                        t[o] = e;
                        const s = dF({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                begin: c,
                                size: t
                            }
                        });
                        return c[o] += e, s
                    }))
                }
            },
            zM = "return sqrt(x);",
            BM = JA({
                opSnippet: zM,
                packedOpSnippet: zM,
                cpuKernelImpl: iA
            }),
            PM = {
                kernelName: Gn,
                backendName: "webgl",
                kernelFunc: BM
            },
            UM = {
                kernelName: ts,
                backendName: "webgl",
                kernelFunc: JA({
                    opSnippet: "return x * x;"
                })
            },
            WM = "return (a - b) * (a - b);",
            VM = ZA({
                opSnippet: WM,
                packedOpSnippet: WM
            }),
            GM = {
                kernelName: es,
                backendName: "webgl",
                kernelFunc: VM
            };
        const HM = {
            kernelName: ys,
            backendName: "webgl",
            kernelFunc: function({
                inputs: e,
                attrs: t,
                backend: n
            }) {
                const {
                    x: s
                } = e, r = SA + `\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `, a = new NA(s.shape, r);
                return n.runWebGLProgram(a, [s], s.dtype)
            }
        };
        class jM {
            constructor(e, t, n) {
                this.variableNames = ["x"], this.outputShape = n;
                const s = n.length,
                    r = nE(n.length),
                    a = nE(n.length);
                let i = "";
                if (1 === s) i = "coords * strides + begin";
                else {
                    let e = 0;
                    i = n.map(((t, s) => (e++, 1 === n.length ? `coords * strides[${s}] + begin[${s}]` : `coords[${e-1}] * strides[${s}] + begin[${s}]`))).join(",")
                }
                this.userCode = `\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `
            }
        }
        const qM = {
            kernelName: ns,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    begin: a,
                    end: i,
                    strides: o,
                    beginMask: u,
                    endMask: l,
                    ellipsisMask: c,
                    newAxisMask: h,
                    shrinkAxisMask: p
                } = s, {
                    finalShapeSparse: d,
                    finalShape: f,
                    isIdentity: m,
                    sliceDim0: g,
                    isSimpleSlice: y,
                    begin: b,
                    end: x,
                    strides: w
                } = ci(r.shape, a, i, o, u, l, c, h, p);
                let k;
                if (m) k = oR({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: f
                    }
                });
                else if (g || y) {
                    R(r.shape.length >= 1, (() => `Input must have rank at least 1, got: ${r.shape.length}`));
                    const e = Ja(b, x, w),
                        t = dF({
                            inputs: {
                                x: r
                            },
                            backend: n,
                            attrs: {
                                begin: b,
                                size: e
                            }
                        });
                    k = oR({
                        inputs: {
                            x: t
                        },
                        backend: n,
                        attrs: {
                            shape: f
                        }
                    }), n.disposeIntermediateTensorInfo(t)
                } else {
                    if (n.shouldExecuteOnCPU([r])) {
                        const e = n.readSync(r.dataId),
                            t = Aa(r.shape, r.dtype, e),
                            s = oA(d, t, w, b);
                        k = n.makeTensorInfo(f, r.dtype, s.values)
                    } else {
                        const e = new jM(b, w, d);
                        k = n.runWebGLProgram(e, [r], r.dtype)
                    }
                }
                const v = oR({
                    inputs: {
                        x: k
                    },
                    backend: n,
                    attrs: {
                        shape: f
                    }
                });
                return n.disposeIntermediateTensorInfo(k), v
            }
        };
        const KM = {
            kernelName: ss,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    separator: r,
                    nGramWidths: a,
                    leftPad: i,
                    rightPad: o,
                    padWidth: u,
                    preserveShortSequences: l
                } = s, {
                    data: c,
                    dataSplits: h
                } = t, p = n.readSync(c.dataId), d = n.readSync(h.dataId), [f, m] = uA(p, d, r, a, i, o, u, l);
                return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", m)]
            }
        };
        const XM = {
            kernelName: rs,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    skipEmpty: r
                } = s, {
                    input: a,
                    delimiter: i
                } = t;
                if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
                if (1 !== a.shape.length) throw new Error(`Input must be a vector, got shape: ${a.shape}`);
                if (0 !== i.shape.length) throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
                const o = n.readSync(a.dataId),
                    u = n.readSync(i.dataId)[0],
                    [l, c, h] = lA(o, u, r),
                    p = c.length;
                return [n.makeTensorInfo([p, 2], "int32", l), n.makeTensorInfo([p], "string", c), n.makeTensorInfo([2], "int32", new Int32Array(h))]
            }
        };
        const YM = {
                kernelName: as,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        numBuckets: r
                    } = s, {
                        input: a
                    } = t;
                    if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
                    if (r <= 0) throw new Error("Number of buckets must be at least 1");
                    const i = n.readSync(a.dataId),
                        o = cA(i, r);
                    return n.makeTensorInfo(a.shape, "int32", o)
                }
            },
            JM = JA({
                opSnippet: "return tan(x);"
            }),
            ZM = {
                kernelName: os,
                backendName: "webgl",
                kernelFunc: JM
            },
            QM = JA({
                opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
            }),
            eL = {
                kernelName: us,
                backendName: "webgl",
                kernelFunc: QM
            };
        class tL {
            constructor(e, t) {
                this.variableNames = ["A"];
                const n = new Array(e.length);
                for (let s = 0; s < n.length; s++) n[s] = e[s] * t[s];
                this.outputShape = n, this.rank = n.length;
                const s = nE(this.rank),
                    r = function(e) {
                        const t = e.length;
                        if (t > 5) throw Error(`Tile for rank ${t} is not yet supported`);
                        if (1 === t) return `imod(resRC, ${e[0]})`;
                        const n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"],
                            s = [];
                        for (let t = 0; t < e.length; t++) s.push(`imod(${n[t]}, ${e[t]})`);
                        return s.join()
                    }(e);
                this.userCode = `\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `
            }
        }

        function nL(e) {
            const {
                inputs: t,
                backend: n,
                attrs: s
            } = e, {
                x: r
            } = t, {
                reps: a
            } = s;
            if ("string" === r.dtype || r.shape.length > 5) {
                const e = n.readSync(r.dataId),
                    t = "string" === r.dtype ? e.map((e => Js(e))) : e,
                    s = Aa(r.shape, r.dtype, t),
                    i = pA(s, a);
                return n.makeTensorInfo(i.shape, i.dtype, i.values)
            }
            const i = new tL(r.shape, a);
            return n.runWebGLProgram(i, [r], r.dtype)
        }
        const sL = {
            kernelName: ls,
            backendName: "webgl",
            kernelFunc: nL
        };
        class rL {
            constructor(e) {
                this.variableNames = ["x", "indices"], this.customUniforms = [{
                    name: "n",
                    type: "int"
                }, {
                    name: "firstPass",
                    type: "int"
                }, {
                    name: "negativeInf",
                    type: "float"
                }, {
                    name: "dir",
                    type: "int"
                }, {
                    name: "inc",
                    type: "int"
                }], this.outputShape = e, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "
            }
        }
        class aL {
            constructor(e) {
                this.variableNames = ["x", "indices"], this.customUniforms = [{
                    name: "n",
                    type: "int"
                }, {
                    name: "firstPass",
                    type: "int"
                }, {
                    name: "k",
                    type: "int"
                }], this.outputShape = e, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "
            }
        }

        function iL(e, t) {
            null !== t && e.disposeIntermediateTensorInfo(t)
        }

        function oL(e) {
            let t = 1;
            for (; t < e;) t *= 2;
            return t
        }
        const uL = {
            kernelName: cs,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    x: r
                } = t, {
                    k: a,
                    sorted: i
                } = s, o = de().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), u = de().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), l = r.shape, c = l[l.length - 1];
                if (n.shouldExecuteOnCPU([r]) || c < o || a > u) {
                    const e = n.readSync(r.dataId),
                        [t, s] = dA(e, l, r.dtype, a, i);
                    return [n.makeTensorInfo(t.shape, t.dtype, t.values), n.makeTensorInfo(s.shape, s.dtype, s.values)]
                }
                if (0 === a) return l[l.length - 1] = 0, [n.makeTensorInfo(l, r.dtype, []), n.makeTensorInfo(l, "int32", [])];
                if (1 === c) return [r, qD({
                    attrs: {
                        shape: l,
                        dtype: "int32",
                        value: 0
                    },
                    backend: n
                })];
                const h = n.texData.get(r.dataId),
                    p = null !== h && h.isPacked,
                    d = p ? n.unpackTensor(r) : r,
                    f = O(l) / c,
                    m = oR({
                        inputs: {
                            x: d
                        },
                        attrs: {
                            shape: [f, c]
                        },
                        backend: n
                    });
                p && iL(n, d);
                const g = oL(a),
                    y = oL(c);
                let b = null;
                const x = () => null === b ? [m, m] : [m, b],
                    w = (e, t, s) => {
                        const r = x(),
                            a = new rL(s),
                            i = [
                                [c],
                                [null === b ? 1 : 0],
                                [Number.NEGATIVE_INFINITY],
                                [e],
                                [t]
                            ],
                            o = b;
                        b = n.runWebGLProgram(a, r, "int32", i), iL(n, o)
                    };
                for (let e = 1; e < g; e *= 2) {
                    const t = 2 * e;
                    for (let n = e; n >= 1; n /= 2) w(t, n, [f, y])
                }
                for (let e = y; e > g; e /= 2) {
                    const t = x(),
                        s = new aL([f, e / 2]),
                        r = [
                            [c],
                            [null === b ? 1 : 0],
                            [g]
                        ],
                        a = b;
                    b = n.runWebGLProgram(s, t, "int32", r), iL(n, a);
                    const i = g / 2,
                        o = 2 * i;
                    for (let e = i; e >= 1; e /= 2) w(o, e, b.shape)
                }
                let k = b;
                b = dF({
                    inputs: {
                        x: b
                    },
                    backend: n,
                    attrs: {
                        begin: 0,
                        size: [f, a]
                    }
                }), iL(n, k);
                let v = h_({
                    inputs: {
                        x: m,
                        indices: b
                    },
                    backend: n,
                    attrs: {
                        axis: 1,
                        batchDims: 1
                    }
                });
                iL(n, m);
                const I = l.slice(0, -1);
                I.push(a), k = b, b = oR({
                    inputs: {
                        x: b
                    },
                    attrs: {
                        shape: I
                    },
                    backend: n
                }), iL(n, k);
                const N = v;
                return v = oR({
                    inputs: {
                        x: v
                    },
                    attrs: {
                        shape: I
                    },
                    backend: n
                }), iL(n, N), [v, b]
            }
        };
        class lL {
            constructor(e, t, n, s, r, a) {
                this.variableNames = ["Image", "Transforms"], this.outputShape = a;
                const i = "nearest" === n ? 1 : 2;
                let o;
                switch (s) {
                    case "constant":
                    default:
                        o = 1;
                        break;
                    case "reflect":
                        o = 2;
                        break;
                    case "wrap":
                        o = 3;
                        break;
                    case "nearest":
                        o = 4
                }
                this.userCode = `\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `
            }
        }
        const cL = {
            kernelName: hs,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    image: r,
                    transforms: a
                } = t, {
                    interpolation: i,
                    fillMode: o,
                    fillValue: u,
                    outputShape: l
                } = s, [c, h, p, d] = r.shape, [f, m] = null != l ? l : [h, p], g = new lL(h, p, i, o, u, [c, f, m, d]);
                return n.runWebGLProgram(g, [r, a], "float32")
            }
        };
        const hL = {
            kernelName: ds,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    attrs: n,
                    backend: s
                } = e, {
                    axis: r
                } = n, {
                    x: a
                } = t;
                LC(a, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
                const i = s.readSync(a.dataId),
                    {
                        outputValues: o,
                        outputShape: u,
                        indices: l
                    } = mA(i, r, a.shape, a.dtype);
                return [s.makeTensorInfo(u, a.dtype, o), s.makeTensorInfo([l.length], "int32", l)]
            }
        };
        const pL = {
            kernelName: fs,
            backendName: "webgl",
            kernelFunc: function(e) {
                const {
                    inputs: t,
                    backend: n,
                    attrs: s
                } = e, {
                    value: r
                } = t;
                let {
                    axis: a
                } = s;
                a < 0 && (a += r.shape.length);
                const i = r,
                    o = i.shape.length,
                    u = r.shape[a],
                    l = new Array(o - 1);
                let c = 0;
                for (let e = 0; e < o; e++) e !== a && (l[c++] = i.shape[e]);
                const h = [],
                    p = new Array(o).fill(0),
                    d = i.shape.slice();
                d[a] = 1;
                const f = new Array(u);
                for (let e = 0; e < f.length; e++) {
                    p[a] = e;
                    const t = dF({
                            inputs: {
                                x: i
                            },
                            backend: n,
                            attrs: {
                                begin: p,
                                size: d
                            }
                        }),
                        s = oR({
                            inputs: {
                                x: t
                            },
                            backend: n,
                            attrs: {
                                shape: l
                            }
                        });
                    f[e] = s, h.push(t)
                }
                return h.forEach((e => n.disposeIntermediateTensorInfo(e))), f
            }
        };
        class dL {
            constructor(e, t) {
                this.variableNames = ["x", "segmentIds"];
                const n = e.windowSize,
                    s = e.batchSize,
                    r = e.inSize,
                    a = e.numSegments,
                    i = a * Math.ceil(r / n);
                this.outputShape = [s, i];
                const o = 4 * Math.floor(n / 4),
                    u = n % 4,
                    l = "\n        sumValue += dot(values, segFilter);\n    ";
                let c = "";
                r % n > 0 && (c = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);
                let h = "";
                r % n > 0 && (h = `\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `), this.userCode = `\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `
            }
        }
        const fL = {
                kernelName: ms,
                backendName: "webgl",
                kernelFunc: function(e) {
                    const {
                        inputs: t,
                        backend: n,
                        attrs: s
                    } = e, {
                        x: r,
                        segmentIds: a
                    } = t, {
                        numSegments: i
                    } = s, o = r.shape.length, u = [];
                    let l = 0;
                    const c = Go([l], o);
                    let h = r;
                    null != c && (h = yR({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            perm: c
                        }
                    }), u.push(h), l = jo(1, o)[0]);
                    const p = ph(h.shape, l, i),
                        d = O([h.shape[l]]),
                        f = oR({
                            inputs: {
                                x: h
                            },
                            backend: n,
                            attrs: {
                                shape: [-1, d]
                            }
                        });
                    u.push(f);
                    const m = wr(r.dtype),
                        g = (e, t, s, r, a) => {
                            const i = e.shape[0],
                                o = e.shape[1],
                                l = hh(o, a),
                                c = new dL({
                                    windowSize: l,
                                    inSize: o,
                                    batchSize: i,
                                    numSegments: a
                                }, t),
                                h = n.compileAndRun(c, [e, s], r);
                            if (u.push(h), h.shape[1] === a) return h;
                            const p = PO({
                                    backend: n,
                                    attrs: {
                                        start: 0,
                                        stop: a,
                                        step: 1,
                                        dtype: "float32"
                                    }
                                }),
                                d = nL({
                                    inputs: {
                                        x: p
                                    },
                                    backend: n,
                                    attrs: {
                                        reps: [o / l]
                                    }
                                });
                            u.push(p), u.push(d);
                            return g(h, t, d, r, a)
                        },
                        y = oR({
                            inputs: {
                                x: g(f, "unsortedSegmentSum", a, m, i)
                            },
                            backend: n,
                            attrs: {
                                shape: p
                            }
                        });
                    let b = y;
                    if (null != c) {
                        u.push(y);
                        const e = Ho(c);
                        b = yR({
                            inputs: {
                                x: b
                            },
                            backend: n,
                            attrs: {
                                perm: e
                            }
                        })
                    }
                    return u.forEach((e => n.disposeIntermediateTensorInfo(e))), b
                }
            },
            mL = [wR, vR, NR, TR, ER, FR, DR, _R, PR, UR, VR, HR, qR, XR, JR, eF, tF, rF, aF, iF, lF, mF, gF, yF, vF, SF, CF, VA, RF, BF, HF, YF, JF, ZF, QF, eD, nD, rD, iD, pD, dD, fD, gD, xD, vD, ID, SD, $D, CD, AD, RD, DD, OD, LD, BD, WD, HD, KD, YD, QD, t_, r_, i_, o_, l_, p_, f_, g_, UA, y_, MF, x_, k_, I_, jA, S_, $_, C_, A_, F_, __, M_, z_, U_, V_, H_, q_, K_, X_, Z_, Q_, eO, tO, nO, rO, oO, lO, bO, iR, wO, vO, NO, TO, xF, CO, RO, FO, MO, zO, XA, BO, UO, kF, pO, VO, HO, qO, uR, YO, ZO, tM, sM, iM, uM, cM, pM, fM, gM, bM, wM, vM, NM, TM, CM, fF, yO, AM, RM, FM, DM, _M, OM, MM, LM, PM, UM, GM, HM, qM, KM, XM, YM, mO, gR, ZM, eL, sL, uL, cL, bR, hL, pL, fL, AO];
        for (const e of mL) As(e);
        const gL = "Identity",
            yL = "Identity_2",
            bL = "Identity_1",
            xL = 22050,
            wL = Math.floor(86.1328125),
            kL = Math.floor(15);
        class vL {
            constructor(e) {
                this.model = "string" == typeof e ? pk(e) : e
            }
            adjustNoteStart(e, t) {
                return e.map((e => ({
                    startTimeSeconds: e.startTimeSeconds + t,
                    durationSeconds: e.durationSeconds,
                    pitch_midi: e.pitchMidi,
                    amplitude: e.amplitude,
                    pitchBends: e.pitchBends
                })))
            }
            async evaluateSingleFrame(e, t) {
                const n = await this.model,
                    s = du(e, t, 1),
                    r = n.execute(s, [bL, yL, gL]);
                return [r[0], r[1], r[2]]
            }
            async prepareData(e) {
                const t = Zi([Zo([Math.floor(3840)], "float32"), Vr(e)]);
                return [go(Yl.frame(t, 43844, 36164, !0, 0), -1), e.length]
            }
            unwrapOutput(e) {
                let t = e;
                t = e.slice([0, kL, 0], [-1, e.shape[1] - 2 * kL, -1]);
                const n = t.shape;
                return t.reshape([n[0] * n[1], n[2]])
            }
            async evaluateModel(e, t, n) {
                let s;
                if (e instanceof Float32Array) s = e;
                else {
                    if (e.sampleRate !== xL) throw new Error(`Input audio buffer is not at correct sample rate! Is ${e.sampleRate}. Should be 22050`);
                    if (1 !== e.numberOfChannels) throw new Error(`Input audio buffer is not mono! Number of channels is ${e.numberOfChannels}. Should be 1`);
                    s = e.getChannelData(0)
                }
                const [r, a] = await this.prepareData(s), i = Math.floor(a * (wL / xL));
                let o = 0;
                for (let e = 0; e < r.shape[0]; ++e) {
                    n(e / r.shape[0]);
                    const [s, a, u] = await this.evaluateSingleFrame(r, e);
                    let l = this.unwrapOutput(s),
                        c = this.unwrapOutput(a),
                        h = this.unwrapOutput(u);
                    const p = l.shape[0];
                    if (!(o >= i)) {
                        if (p + o >= i) {
                            const e = i - o;
                            l = l.slice([0, 0], [e, -1]), c = c.slice([0, 0], [e, -1]), h = h.slice([0, 0], [e, -1])
                        }
                        o += p, t(await l.array(), await c.array(), await h.array())
                    }
                }
                n(1)
            }
        }
        n(748);
        const IL = 22050,
            NL = 256,
            SL = 2 * Math.floor(86.1328125),
            TL = .011609977324263039 * (SL - 171.265625) + .0018,
            $L = e => 12 * (Math.log2(e) - Math.log2(440)) + 69,
            CL = e => 440 * 2 ** ((e - 69) / 12),
            EL = e => e * NL / IL - TL * Math.floor(e / SL);

        function AL(e) {
            return 0 === e.length ? null : e.reduce(((t, n, s) => e[t] > n ? t : s), -1)
        }
        const RL = e => e.map((e => AL(e)));

        function FL(e, t) {
            const n = [],
                s = [];
            for (let r = 0; r < e.length; r++)
                for (let a = 0; a < e[r].length; a++) e[r][a] > t && (n.push(r), s.push(a));
            return [n, s]
        }

        function DL(e) {
            const [t, n, s] = e.reduce(((e, t) => {
                const [n, s, r] = t.reduce(((e, t) => [e[0] + t, e[1] + t * t, e[2] + 1]), [0, 0, 0]);
                return [e[0] + n, e[1] + s, e[2] + r]
            }), [0, 0, 0]);
            return [t / s, Math.sqrt(1 / (s - 1) * (n - t * t / s))]
        }

        function _L(e) {
            return e.reduce(((e, t) => Math.max(e, ...t)), 0)
        }

        function OL(e) {
            const t = e[0].map((e => e.slice()));
            for (let n = 1; n < e.length; ++n)
                for (let s = 0; s < e[0].length; ++s)
                    for (let r = 0; r < e[0][0].length; ++r) t[s][r] = Math.min(t[s][r], e[n][s][r]);
            return t
        }

        function ML(e, t = 1) {
            const n = [];
            for (let s = 0; s < e[0].length; ++s)
                for (let r = 0; r < e.length; ++r) {
                    let a = !0;
                    for (let n = Math.max(0, r - t); a && n <= Math.min(e.length - 1, r + t); ++n) n !== r && (a = a && e[r][s] > e[n][s]);
                    a && n.push([r, s])
                }
            return n
        }

        function LL(e) {
            const t = e[0].map((e => e.slice()));
            for (let n = 1; n < e.length; ++n)
                for (let s = 0; s < e[0].length; ++s)
                    for (let r = 0; r < e[0][0].length; ++r) t[s][r] = Math.max(t[s][r], e[n][s][r]);
            return t
        }

        function zL(e) {
            return null !== e
        }

        function BL(e, t, n, s) {
            if (n) {
                const s = $L(n) - 21;
                for (let t = 0; t < e.length; t++) e[t].fill(0, s);
                for (let e = 0; e < t.length; e++) t[e].fill(0, s)
            }
            if (s) {
                const n = $L(s) - 21;
                for (let t = 0; t < e.length; t++) e[t].fill(0, 0, n);
                for (let e = 0; e < t.length; e++) t[e].fill(0, 0, n)
            }
        }

        function PL(e, t, n = 2) {
            let s = OL(Array.from(Array(n).keys()).map((e => e + 1)).map((e => {
                const n = Array(e).fill(Array(t[0].length).fill(0)).concat(t),
                    s = n.slice(e),
                    r = n.slice(0, -e);
                if (s.length !== r.length) throw new Error(`nPlus length !== minusN length: ${s.length} !== ${r.length}`);
                return s.map(((e, t) => e.map(((e, n) => e - r[t][n]))))
            })));
            s = s.map((e => e.map((e => Math.max(e, 0))))), s = s.map(((e, t) => t < n ? e.fill(0) : e));
            const r = _L(e),
                a = _L(s);
            return s = s.map((e => e.map((e => r * e / a)))), LL([e, s])
        }

        function UL(e, t, n = .5, s = .3, r = 5, a = !0, i = null, o = null, u = !0, l = 11) {
            let c = s;
            if (null === c) {
                const [t, n] = DL(e);
                c = t + n
            }
            const h = e.length;
            BL(t, e, i, o);
            let p = t;
            a && (p = PL(t, e));
            const d = p.map((e => e.map((() => 0))));
            ML(p).forEach((([e, t]) => {
                d[e][t] = p[e][t]
            }));
            const [f, m] = FL(d, n);
            f.reverse(), m.reverse();
            const g = e.map((e => e.slice())),
                y = f.map(((t, n) => {
                    const s = m[n];
                    if (t >= h - 1) return null;
                    let a = t + 1,
                        i = 0;
                    for (; a < h - 1 && i < l;) g[a][s] < c ? i += 1 : i = 0, a += 1;
                    if (a -= i, a - t <= r) return null;
                    for (let e = t; e < a; ++e) g[e][s] = 0, s < 87 && (g[e][s + 1] = 0), s > 0 && (g[e][s - 1] = 0);
                    const o = e.slice(t, a).reduce(((e, t) => e + t[s]), 0) / (a - t);
                    return {
                        startFrame: t,
                        durationFrames: a - t,
                        pitchMidi: s + 21,
                        amplitude: o
                    }
                })).filter(zL);
            if (!0 === u)
                for (; _L(g) > c;) {
                    const [t, n] = g.reduce(((e, t, n) => {
                        const s = AL(t);
                        return t[s] > g[e[0]][e[1]] ? [n, s] : e
                    }), [0, 0]);
                    g[t][n] = 0;
                    let s = t + 1,
                        a = 0;
                    for (; s < h - 1 && a < l;) g[s][n] < c ? a += 1 : a = 0, g[s][n] = 0, n < 87 && (g[s][n + 1] = 0), n > 0 && (g[s][n - 1] = 0), s += 1;
                    const i = s - 1 - a;
                    for (s = t - 1, a = 0; s > 0 && a < l;) g[s][n] < c ? a += 1 : a = 0, g[s][n] = 0, n < 87 && (g[s][n + 1] = 0), n > 0 && (g[s][n - 1] = 0), s -= 1;
                    const o = s + 1 + a;
                    if (o < 0) throw new Error(`iStart is not positive! value: ${o}`);
                    if (i >= h) throw new Error(`iEnd is past end of times. (iEnd, times.length): (${i}, ${h})`);
                    const u = e.slice(o, i).reduce(((e, t) => e + t[n]), 0) / (i - o);
                    i - o <= r || y.push({
                        startFrame: o,
                        durationFrames: i - o,
                        pitchMidi: n + 21,
                        amplitude: u
                    })
                }
            return y
        }
        const WL = (e, t) => Array.from(Array(e).keys()).map((n => Math.exp(-1 * (n - (e - 1) / 2) ** 2 / (2 * t ** 2)))),
            VL = e => 36 * Math.log2(CL(e) / 27.5);

        function GL(e, t, n = 25) {
            const s = 2 * n + 1,
                r = WL(s, 5);
            return t.map((t => {
                const a = Math.floor(Math.round(VL(t.pitchMidi))),
                    i = Math.max(a - n, 0),
                    o = Math.min(264, a + n + 1),
                    u = r.slice(Math.max(0, n - a), s - Math.max(0, a - (264 - n - 1))),
                    l = e.slice(t.startFrame, t.startFrame + t.durationFrames).map((e => e.slice(i, o).map(((e, t) => e * u[t])))),
                    c = n - Math.max(0, n - a),
                    h = RL(l).map((e => e - c));
                return Object.assign(Object.assign({}, t), {
                    pitchBends: h
                })
            }))
        }
        const HL = e => e.map((e => ({
            pitchMidi: e.pitchMidi,
            amplitude: e.amplitude,
            pitchBends: e.pitchBends,
            startTimeSeconds: EL(e.startFrame),
            durationSeconds: EL(e.startFrame + e.durationFrames) - EL(e.startFrame)
        })));
        window.basic_pitch = {
            BasicPitch: vL,
            addPitchBendsToNoteEvents: GL,
            noteFramesToTime: HL,
            outputToNotesPoly: UL
        }, window.basic_pitch.audioToNoteEvents = async function(e, t, n, s, r) {
            const a = new AudioContext({
                    sampleRate: 22050
                }),
                i = [],
                o = [],
                u = [];
            try {
                const n = await fetch(e),
                    l = await n.arrayBuffer(),
                    c = await a.decodeAudioData(l),
                    h = new vL("../model/model.json");
                await h.evaluateModel(c, ((e, t, n) => {
                    i.push(...e), o.push(...t), u.push(...n)
                }), (e => {
                    s && s(e)
                }));
                const {
                    onsetThresh: p = .5,
                    frameThresh: d = .3,
                    minNoteLen: f = 5,
                    inferOnsets: m = !0,
                    maxFreq: g = null,
                    minFreq: y = null,
                    melodiaTrick: b = !0,
                    energyTolerance: x = 11
                } = r || {}, w = HL(GL(u, UL(i, o, p, d, f, m, g, y, b, x))).map((e => ({
                    pitch: e.pitchMidi,
                    duration: e.durationSeconds,
                    onset: e.startTimeSeconds,
                    pitchBends: e.pitchBends,
                    velocity: e.amplitude
                })));
                w.sort(((e, t) => e.onset - t.onset || e.pitch - t.pitch)), t(w)
            } catch (e) {
                n && n(e)
            }
        }
    })()
})();