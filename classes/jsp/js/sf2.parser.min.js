/** @license sf2synth.js 2013 - imaya / GREE Inc. [ https://github.com/gree/sf2synth.js ] The MIT License */
(function() {
    'use strict';

    function k(g) {
        throw g;
    }
    var l = void 0,
        m = null,
        n = this;

    function p(g, e) {
        var b = g.split("."),
            a = n;
        !(b[0] in a) && a.execScript && a.execScript("var " + b[0]);
        for (var d; b.length && (d = b.shift());) !b.length && e !== l ? a[d] = e : a = a[d] ? a[d] : a[d] = {}
    };

    function v(g, e) {
        e = e || {};
        this.input = g;
        this.b = e.index || 0;
        this.length = e.length || g.length - this.b;
        this.offset = this.b;
        this.padding = e.padding !== l ? e.padding : !0;
        this.g = e.bigEndian !== l ? e.bigEndian : !1
    }

    function y(g, e, b) {
        this.type = g;
        this.size = e;
        this.offset = b
    }
    v.prototype.parse = function() {
        var g = this.length + this.offset;
        for (this.a = []; this.b < g;) {
            var e = this.input,
                b = this.b,
                a = l;
            this.a.push(new y(String.fromCharCode(e[b++], e[b++], e[b++], e[b++]), a = this.g ? (e[b++] << 24 | e[b++] << 16 | e[b++] << 8 | e[b++]) >>> 0 : (e[b++] | e[b++] << 8 | e[b++] << 16 | e[b++] << 24) >>> 0, b));
            b += a;
            this.padding && 1 === (b - this.offset & 1) && b++;
            this.b = b
        }
    };

    function z(g, e) {
        var b = g.a[e];
        return b === l ? m : b
    };

    function A(g, e) {
        e = e || {};
        this.input = g;
        this.h = e.parserOption
    }
    A.prototype.parse = function() {
        var g, e, b = new v(this.input, this.h);
        b.parse();
        1 !== b.a.length && k(Error("wrong chunk length"));
        b = z(b, 0);
        b === m && k(Error("chunk not found"));
        var a = this.input,
            d = b.offset,
            c;
        "RIFF" !== b.type && k(Error("invalid chunk type:" + b.type));
        c = String.fromCharCode(a[d++], a[d++], a[d++], a[d++]);
        "sfbk" !== c && k(Error("invalid signature:" + c));
        b = new v(a, {
            index: d,
            length: b.size - 4
        });
        b.parse();
        3 !== b.a.length && k(Error("invalid sfbk structure"));
        a = z(b, 0);
        d = this.input;
        c = a.offset;
        var f;
        "LIST" !== a.type &&
            k(Error("invalid chunk type:" + a.type));
        f = String.fromCharCode(d[c++], d[c++], d[c++], d[c++]);
        "INFO" !== f && k(Error("invalid signature:" + f));
        (new v(d, {
            index: c,
            length: a.size - 4
        })).parse();
        a = z(b, 1);
        d = this.input;
        c = a.offset;
        "LIST" !== a.type && k(Error("invalid chunk type:" + a.type));
        f = String.fromCharCode(d[c++], d[c++], d[c++], d[c++]);
        "sdta" !== f && k(Error("invalid signature:" + f));
        a = new v(d, {
            index: c,
            length: a.size - 4
        });
        a.parse();
        1 !== a.a.length && k(Error("TODO"));
        this.f = z(a, 0);
        b = z(b, 2);
        a = this.input;
        d = b.offset;
        "LIST" !==
        b.type && k(Error("invalid chunk type:" + b.type));
        c = String.fromCharCode(a[d++], a[d++], a[d++], a[d++]);
        "pdta" !== c && k(Error("invalid signature:" + c));
        b = new v(a, {
            index: d,
            length: b.size - 4
        });
        b.parse();
        9 !== b.a.length && k(Error("invalid pdta chunk"));
        a = z(b, 0);
        d = this.input;
        c = a.offset;
        f = this.C = [];
        var h = a.offset + a.size;
        for ("phdr" !== a.type && k(Error("invalid chunk type:" + a.type)); c < h;) f.push({
            F: String.fromCharCode.apply(m, d.subarray(c, c += 20)),
            z: d[c++] | d[c++] << 8,
            i: d[c++] | d[c++] << 8,
            A: d[c++] | d[c++] << 8,
            t: (d[c++] | d[c++] <<
                8 | d[c++] << 16 | d[c++] << 24) >>> 0,
            k: (d[c++] | d[c++] << 8 | d[c++] << 16 | d[c++] << 24) >>> 0,
            u: (d[c++] | d[c++] << 8 | d[c++] << 16 | d[c++] << 24) >>> 0
        });
        a = z(b, 1);
        d = this.input;
        c = a.offset;
        f = this.G = [];
        h = a.offset + a.size;
        for ("pbag" !== a.type && k(Error("invalid chunk type:" + a.type)); c < h;) f.push({
            B: d[c++] | d[c++] << 8,
            D: d[c++] | d[c++] << 8
        });
        a = z(b, 2);
        "pmod" !== a.type && k(Error("invalid chunk type:" + a.type));
        this.I = G(this, a);
        a = z(b, 3);
        "pgen" !== a.type && k(Error("invalid chunk type:" + a.type));
        this.H = H(this, a);
        a = z(b, 4);
        d = this.input;
        c = a.offset;
        f = this.l = [];
        h = a.offset + a.size;
        for ("inst" !== a.type && k(Error("invalid chunk type:" + a.type)); c < h;) f.push({
            p: String.fromCharCode.apply(m, d.subarray(c, c += 20)),
            m: d[c++] | d[c++] << 8
        });
        a = z(b, 5);
        d = this.input;
        c = a.offset;
        f = this.q = [];
        h = a.offset + a.size;
        for ("ibag" !== a.type && k(Error("invalid chunk type:" + a.type)); c < h;) f.push({
            n: d[c++] | d[c++] << 8,
            o: d[c++] | d[c++] << 8
        });
        a = z(b, 6);
        "imod" !== a.type && k(Error("invalid chunk type:" + a.type));
        this.s = G(this, a);
        a = z(b, 7);
        "igen" !== a.type && k(Error("invalid chunk type:" + a.type));
        this.r = H(this,
            a);
        h = z(b, 8);
        b = this.input;
        a = h.offset;
        d = this.J = [];
        c = this.K = [];
        f = h.offset + h.size;
        var q, r, s, B, C, D, E;
        for ("shdr" !== h.type && k(Error("invalid chunk type:" + h.type)); a < f;) {
            h = String.fromCharCode.apply(m, b.subarray(a, a += 20));
            e = (b[a++] << 0 | b[a++] << 8 | b[a++] << 16 | b[a++] << 24) >>> 0;
            g = (b[a++] << 0 | b[a++] << 8 | b[a++] << 16 | b[a++] << 24) >>> 0;
            q = (b[a++] << 0 | b[a++] << 8 | b[a++] << 16 | b[a++] << 24) >>> 0;
            r = (b[a++] << 0 | b[a++] << 8 | b[a++] << 16 | b[a++] << 24) >>> 0;
            s = (b[a++] << 0 | b[a++] << 8 | b[a++] << 16 | b[a++] << 24) >>> 0;
            B = b[a++];
            C = b[a++] << 24 >> 24;
            D = b[a++] | b[a++] <<
                8;
            E = b[a++] | b[a++] << 8;
            g = new Int16Array((new Uint8Array(b.subarray(this.f.offset + 2 * e, this.f.offset + 2 * g))).buffer);
            q -= e;
            r -= e;
            if (0 < s) {
                var w = s,
                    u = l,
                    t = l,
                    F = l,
                    x = l;
                for (e = 1; 22050 > w;) {
                    u = new Int16Array(2 * g.length);
                    t = x = 0;
                    for (F = g.length; t < F; ++t) u[x++] = g[t], u[x++] = g[t];
                    g = u;
                    e *= 2;
                    w *= 2
                }
                s *= e;
                q *= e;
                r *= e
            }
            d.push(g);
            c.push({
                M: h,
                O: q,
                j: r,
                sampleRate: s,
                v: B,
                w: C,
                L: D,
                N: E
            })
        }
        this.input = m
    };

    function G(g, e) {
        for (var b = g.input, a = e.offset, d = e.offset + e.size, c, f, h = []; a < d;) {
            a += 2;
            c = b[a++] | b[a++] << 8;
            f = I[c];
            if (f === l) h.push({
                type: f,
                value: {
                    code: c,
                    c: b[a] | b[a + 1] << 8 << 16 >> 16,
                    e: b[a++],
                    d: b[a++]
                }
            });
            else switch (f) {
                case "keyRange":
                case "velRange":
                case "keynum":
                case "velocity":
                    h.push({
                        type: f,
                        value: {
                            e: b[a++],
                            d: b[a++]
                        }
                    });
                    break;
                default:
                    h.push({
                        type: f,
                        value: {
                            c: b[a++] | b[a++] << 8 << 16 >> 16
                        }
                    })
            }
            a += 2;
            a += 2
        }
        return h
    }

    function H(g, e) {
        for (var b = g.input, a = e.offset, d = e.offset + e.size, c, f, h = []; a < d;)
            if (c = b[a++] | b[a++] << 8, f = I[c], f === l) h.push({
                type: f,
                value: {
                    code: c,
                    c: b[a] | b[a + 1] << 8 << 16 >> 16,
                    e: b[a++],
                    d: b[a++]
                }
            });
            else switch (f) {
                case "keynum":
                case "keyRange":
                case "velRange":
                case "velocity":
                    h.push({
                        type: f,
                        value: {
                            e: b[a++],
                            d: b[a++]
                        }
                    });
                    break;
                default:
                    h.push({
                        type: f,
                        value: {
                            c: b[a++] | b[a++] << 8 << 16 >> 16
                        }
                    })
            }
        return h
    }
    var I = ["startAddrsOffset", "endAddrsOffset", "startloopAddrsOffset", "endloopAddrsOffset", "startAddrsCoarseOffset", "modLfoToPitch", "vibLfoToPitch", "modEnvToPitch", "initialFilterFc", "initialFilterQ", "modLfoToFilterFc", "modEnvToFilterFc", "endAddrsCoarseOffset", "modLfoToVolume", , "chorusEffectsSend", "reverbEffectsSend", "pan", , , , "delayModLFO", "freqModLFO", "delayVibLFO", "freqVibLFO", "delayModEnv", "attackModEnv", "holdModEnv", "decayModEnv", "sustainModEnv", "releaseModEnv", "keynumToModEnvHold", "keynumToModEnvDecay",
        "delayVolEnv", "attackVolEnv", "holdVolEnv", "decayVolEnv", "sustainVolEnv", "releaseVolEnv", "keynumToVolEnvHold", "keynumToVolEnvDecay", "instrument", , "keyRange", "velRange", "startloopAddrsCoarseOffset", "keynum", "velocity", "initialAttenuation", , "endloopAddrsCoarseOffset", "coarseTune", "fineTune", "sampleID", "sampleModes", , "scaleTuning", "exclusiveClass", "overridingRootKey"
    ];
    p("SoundFont.Parser", A);
    p("SoundFont.Parser.prototype.parse", A.prototype.parse);
}).call(this); 